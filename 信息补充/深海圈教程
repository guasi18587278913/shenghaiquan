[图片]
课程出品人：@刘小排
出品时间：2025 年 5 月 
建议：如果需要快速定位到精确内容，可以使用快捷键 Ctrl + F/command + F 的形式，搜索「关键字/词」，查找你想要的内容
[图片]

课程内容
你将会学习到「从产品 idea、到使用 AI 编程做出软件产品、到变现、到成为一门可持续生意」 的全流程。
特别备注： 得益于 AI 编程的飞速进步，在参与课程之前，你不需要有编程的基础。

课程形式
视频 + 文档 + 微信群答疑和交流

1. 课程以视频和文档的方式作为主交付。 暂定使用飞书文档作为交付工具，未来可能更改。
2. 课程内容将会持续更新（至少一年）。  AI 编程的发展日新月异，我们对它的使用方式保持与时俱进。
3. 课程专属微信交流群的权益为一年期，群内有助教答疑和经验交流。

特别提醒
- 本课程专注于落地实践技能，不承诺你学完能赚到钱。

学习门槛

不需要
❌ 你不需要有编程基础。
❌ 你不需要曾经从事过互联网行业。
需要
- 必备项
✅ 一定的预算，至少$100 美元/月。用于购买海外工具、域名、服务器、API 等基础设施。如果你想要加快进度，建议准备$1000 美元/月，可以更从容地购买高级的效率工具、对外合作、付费推广。
✅ 你能够配置好网络环境，访问外国网站没有障碍。  
✅ 你有一定的英文阅读基础，建议不低于高中英语水平。
✅ 你已经有一个或多个产品 idea 想要尝试。

- 加分项
✅ 有坚持学习 1 个月以上的毅力和韧性
✅ 针对遇到的问题及时复盘

[图片]
前言

这套课程有什么不同？

第 1 个不同： 通过 AI 做软件产品生意，我是一个拿过结果的人。 

过去两年市场上出现过很多种 AI 课程，江湖传言说“做 AI 产品的没赚钱，做 AI 课程的赚钱了”，在一定程度上是真的，因为大部分人还没有能力使用 AI 做出产品并靠产品赚到钱。

我和他们不同。我的产品长期出现在各类“AIGC 出海产品排行榜”Top 100 里，偶尔还有 Top 50 和 Top 30。  我想，仅凭这一点，我就已经击败了 99.9%的同行了吧。

也许你想了解我拿到的结果是什么规模？ 我先展示一个最近的案例吧。

在 2025 年 1 月 17 日上线、我上线了一款新产品 —— Raphael 这是一款典型的 MicroSaaS https://raphael.app
[图片]

它的全部开发周期是 1 周，就我一个人。

在上线的第一个月，它已经累计 100 万的月活跃用户，每天有 3～4 万用户使用它。 

网站产品的数据毫无秘密可言。你可以通过微信、Youtube、Twitter、Facebook 等任何一个社交平台搜索"raphael.app"这个关键词，看看这款产品的用户来自哪里、它是如何受到全世界用户欢迎的。

赚了多少钱？ 对于 MicroSaaS 产品来说，付费率范围较大，0.1%～6%之间都是合理的。你不妨先按照最低的 0.1%来估算。

第 2 个不同：全面使用 AI，直接从实战开始，而不是从编程基础开始。

我们一切流程，都全面使用 AI，直接实战。  

得益于 AI 编程工具的日新月异，学员可以在第一周甚至第一天就发布自己的产品，而不需要从最基础的 HTML/CSS/JAVASCRIPT 开始。

此外，正是由于 AI 编程发展日新月异，这是一门必须持续更新的课程。 

第 3 个不同：我们探讨用 AI 做软件产品生意的全流程，而不只是讲 AI 编程

对于一门生意而言，编程（无论是否有 AI）都不是最重要的一环。 我们的课程会涉及到需求挖掘、需求打磨、产品设计、产品实现、用户获取、产品迭代等等，关于 MicroSaaS 软件生意的一切。 

你要学什么？
本课程的学习思路，为【四步学习】+【2 个作品】

四步学习会按照章节顺序，一步步教你相关知识
2 个作品会让你掌握学到的知识，做出能赚钱的产品

- 学习地图
[图片]
请先学习完「基础篇」，再一边持续迭代你在基础篇里发布的产品、一边学习后续内容
在「基础篇」中，我会尽量跳过理论和基础知识，让你直接实操，找到手感。课程以视频为主。课程视频本身只有短短两小时， 但是你可能需要使用不少于 40 小时的时间，才能够真正上手。上手后，你可以反复把自己的产品打磨精细、或者多实操几个回合。AI 编程工具是一把利剑，你需要大量的练习和探索，才能人剑合一。 

第二部分是「认知篇」，我们会涉及到海外软件生意（Micro SaaS）的产品和商业形态探讨
主要以文字内容为主。推荐学习时间为 3 小时。

第三部分是「内功篇」，我们会尽可能补齐你已经使用过的技术工具背后的原理，以及推荐一些扩展阅读
虽然我们已经熟练了招式，但招式只不过是“方便法门”，补齐内功，才能让我们走得更远。推荐使用 60 小时以上的时间来完成内功篇。

第四部分是「进阶篇」，在内功篇完成的基础上，我们把 MVP 变成完成产品，跑通商业闭环。

- 2 个作品
整体来看，课程分为了两个阶段
第一阶段以【基础篇】部分完成为节点，你能够用一系列工具快速做出一个可被访问、有 MVP 功能的网站产品
如：
https://answer-book-two.vercel.app/ （需要魔法打开）
https://screensharing.net/



[图片]

第二阶段以全部课程【基础篇】【认知篇】【内功篇】【进阶篇】完成为节点，你能做出能变现的成熟商业产品
如：

https://raphael.app/


[图片]

学习方法
本课程涵盖了大量的全栈开发及商业产品知识点，覆盖了传统互联网企业中的前端、后端、产品、运营、市场等岗位职能；

因此在学习中如有走不通、不理解的卡点，非常正常，需要常用AI工具或信息查询

为保证你脱离本课程帮助后，能持续的输出优质产品，且产品水平持续自我升级，推荐以下学习方法

状况 1：遇到卡点
首先去思考这个问题的解决方式、问题成因，围绕本质向 AI 提问，或搜集资料，如：
使用 Dia 浏览器，用 AI 提问
（Dia浏览器仅支持Macbook。如果你是Windows电脑，可以先用新版QQ浏览器平替）
[图片]

和 AI 打电话，反复练习知识点。
推荐使用ChatGPT打电话功能，详见基础篇第一课；也可以用豆包平替。
[图片]
配置 GitHub 的 ssh
[图片]

现在就可以发动你的聪明才智，尝试去利用 edu 邮箱，使用 Dia 浏览器

善用 command + F，搜索文档中的相关答案，如
GitHub 看不懂，搜索 GitHub 教程
[图片]
代码提交遇到问题，搜索代码提交
[图片]

持续关注课程群
我们会持续的更新课程文档，当市面上出现了更为优质的工具或更高效便捷的手段，我们会及时对内容进行更新

课前准备

- 请配置好网络环境
  - 谷歌邮箱账号

- GitHub 账号
  - 官网：https://github.com/
  - 注册地址： https://github.com/signup 
  - 注意：GitHub 账号，是你在本课程中最重要的账号！AI 编程需要用到的工具（如 Cursor、Bolt、V0），大部分都可以通过 GitHub 账号登录！

- 海外信用卡
  - 我们需要用到的很多 AI 工具都是付费的，它们往往需要海外信用卡。你可以在国内各大银行去注册 VISA 或 MASTERCARD 的信用卡（不要银联）。

- Cursor
  - 下载地址：https://www.Cursor.com/
  - 安装后，软件会引导你注册和付费。 同样，你可以使用刚才注册的 GitHub 账号进行登陆。
  - 要不要付费？ 要！ （$20/月）。

- 一个通用的 AI 助手，因为我们要和它讨论需求
  - 推荐：
    - ChatGPT Plus （$20/月）  ，强烈推荐。网址：https://openai.com/chatgpt/pricing/
    - Claude （$20/月），强烈推荐。  网址：https://www.anthropic.com/
我使用的官方版本。不过官方版本比较难注册。如果你使用官方版本有困难，可考虑用相对比较稳定的国内套壳版。https://2233.ai/i/ONEDOLLAR
    - Grok，推荐。网址：https://grok.com/
    - Deepseek R1 ，不是特别推荐，保底的选择。网址：https://chat.deepseek.com/

- Bolt.new 账号
  1. 前面我们已经注册了 GitHub 账号，可使用 GitHub 账号登录 Bolt.new
  2.  网址： https://bolt.new/ ，点击右上角 Sign In，选择使用 GitHub 登录
  3. 可根据自身使用需求，选择付费或免费模式 。另外，推荐一款同类型工具 same.new。
  
- 常用 API 平台
  1. 我们做的产品，很可能会用到大模型的能力，也就是传统说的“大模型应用”。因此，我们需要提前找好一个大模型的 API。
  2. 常用 API 平台推荐
    - https://openrouter.ai/   
    - https://www.together.ai/  
    - https://fal.ai/    
    - https://replicate.com/  
    - https://siliconflow.cn/ （国内产品！适合小白）

[图片]

基础篇（视频+文字）

课程目标：完成你的第一款 MVP（最小可行产品）

建议学习时长：40 小时
看视频只有“眼睛会了”，学习的本质是练习、踩坑、填坑，要花足够多的时间。

一、玩起来！ 通过 AI，10 分钟发布你的第一款网站产品！

哈喽，大家好！我是刘小排。欢迎来到我的 Idea to Business 课程！

现在你看到的是本课程的第一集。

接下来的 10 分钟，对于没有接触过 AI 编程的人来说，可能就像是魔法一样。你会看到，我们不需要任何编程基础或者技术功底，只需要用语言文字跟 AI 沟通，AI 就能够自动帮你写好代码。 

我们试试看吧。

请先看视频课程，然后结合本课程的文字讲义进行实操。

视频
暂时无法在飞书文档外展示此内容

[图片]

1.1 课前准备

1. 配置好网络环境（科学上网、能打开谷歌浏览器、拥有谷歌账号）
2. GitHub 账号。通过 GitHub 账号登录 bolt.new

1.2 随便准备一个产品 idea

这个产品 idea 最好来自你自己或者你身边的朋友遇到的问题，这样的话，你最了解你的用户。

我给你 3 分钟，思考一个你遇到的、也许可以做个软件产品来解决的问题。

……

也许是，你最近有点 emo，希望有个软件可以每天给自己灌正能量鸡汤和打气？

……

也许是，MBTI 测试很火，你有朋友想要测试，但他被长长的问题列表劝退了，你想要做一个只有 10 道题的简单版 MBTI 测试产品？

……

也许是，你已经有门生意，比如“优势教练”，你想做一个看着非常专业的官网，从而降低获客成本？

…… 

也许是，你已经有门生意，比如大学生付费自习室，你想做一个看着非常专业的官网，从而降低获客成本？

…… 

也许是，你每天中午点外卖都有选择困难症，想要做一个产品帮你决定每天中午吃什么？

…… 

也许是，你喜欢在群里和人吵架，却经常吵完后感到后悔，后悔的内容是“刚才我好像没有发挥好”，从而你想要做一个叫“吵架包赢”的应用，帮助你在微信群立于不败之地？

…… 


3 分钟到了。想到你要做啥产品了吗？


如果没有的话，我们不妨假设你正在后悔刚才你在微信群的吵架发挥情况，我们来做个“吵架包赢”解决你的问题。

苦于构思 idea 的朋友，可以先学习我在生财有术的分享
- 《如何获得产品 idea》https://t.zsxq.com/KAQB9
- 《什么产品好做？三个一》https://t.zsxq.com/f3nTK
它们后续也会被集成到本课程当中。

为了你方便学习，我还为你准备了一些简单、容易实现的项目创意，方便新手进行练习。

以下列表中的项目创意，大概率没有商业化潜质，只是为了练习使用。
暂时无法在飞书文档外展示此内容

1.3 构思完整的 Prompt

要点 1：没有歧义

说人话就好。核心追求是：没有歧义。
“没有歧义”的意思是，任何人看着你这一段话，都不会有不同的理解。

如果你跟人说“我要一个吵架包赢神器”，这是一次有很大歧义的沟通。人家可能会问，界面长啥样？具体有哪些按钮？是怎么吵架的、打字吵还是电话吵还是当面吵？ 等等等等。

同样，“我想要界面设计高端大气上档次”，也是一个非常有歧义的沟通，每个人都会有不同的理解，我们应该避免这样的沟通。 当然，也有例外： 在某些场景下，你需要 AI 发挥创造力，那么你可以故意使用有一定歧义的话。

总的来说，我们可以分不同的角度，从多方面去降低歧义。

例如：

我想做一个「xxxx」，它是一个 xxx 形态的产品。

我们的技术栈要求：
- ...
- ....
- xxx

我们的界面设计要求是：
- ....
- ....

产品的具体功能是：（这里需要描述得特别清楚，让任何人看到都没有歧义）
- ...用户将会输入...
- 当用户点击...，用户会看到...
- 我们使用的大模型是 gemini-2.5-flash-preview.. 如果你需要的话
- 我我们需要用到的API，下文会给你一段 API 示例调用你参考
- 此外，我还附上了一个图，你可以参考图上的功能布局

#API

API的示例代码是：
Xxxxx


要点 2：强调使用的技术栈用到 NextJS(App Router) + TypeScript + TailwindCSS + shadcn/ui
为了避免做得太重，也可以强调一句“暂时不需要用数据库”。
这是为了后续我们继续打磨的方便。

以下是我的 Prompt，供参考。（请把里面红色的 API key 换成你自己的）

特别提醒： 虽然我的示例里用了 DeepSeek API。但是，bolt.new 并不适合做涉及复杂 API 的产品！
如果你没有调通 API，不要着急，不是你的问题。后面的课程（第二课和第三课），我们会用更好的流程来做。 在本节课中，如果你集成 API 觉得吃力，可以先专做做一些不需要依赖外界 API 的小产品。
prompt 可复制版本 prompt可复制版本
我想做一个「吵架包赢」，它是一个网站。
  
  #技术栈
  - NextJS(App Router)
  - Typescript
  - TailwindCSS
  - shadcn/ui
  - 不使用数据库
  
  #界面
  - 考虑到用户主要是手机用户，请保证手机访问和电脑访问，都一样美观
  - 考虑到我们到用户是微信用户，你的配色可以参考微信的配色
  #功能
  - 用户输入“对方的话”
  - 用户选择“语气强烈程度”，是一个从 1 到 10 可以拖动的小玩意儿
  - 用户点击“开始吵架“，回复 3 条牛逼的吵架内容。
    - 回复内容你需要使用大模型。我们使用 openrouter 上面的 DeepSeek V3 模型吧。这是它的 API 文档 https://openrouter.ai/google/gemini-2.5-flash-preview
这个 API 我的 Key 是：sk-or-v1-..改成你的...改成你的...改成你的..9f72a634fca8
  
#API示例代码

  fetch("https://openrouter.ai/api/v1/chat/completions", {
    method: "POST",
    headers: {
      "Authorization": "Bearer <OPENROUTER_API_KEY>",
      "HTTP-Referer": "<YOUR_SITE_URL>", // Optional. Site URL for rankings on openrouter.ai.
      "X-Title": "<YOUR_SITE_NAME>", // Optional. Site title for rankings on openrouter.ai.
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      "model": "google/gemini-2.5-flash-preview",
      "messages": [
        {
          "role": "user",
          "content": [
            {
              "type": "text",
              "text": "What is in this image?"
            },
            {
              "type": "image_url",
              "image_url": {
                "url": "https://upload.wikimedia.org/wikipedia/commons/thumb/d/dd/Gfp-wisconsin-madison-the-nature-boardwalk.jpg/2560px-Gfp-wisconsin-madison-the-nature-boardwalk.jpg"
              }
            }
          ]
        }
      ]
    })
  });

补充：代码示例选择openai-typescript版本。但其实无论选择哪个版本都一样，AI都能理解。
[图片]

当你写好 Prompt，你可以发给程序员朋友（如果你有的话），让他帮你看看你写得是否有歧义。

如果没有程序员朋友，那你可以发给 AI（比如 ChatGPT），问它的意见。直到修改得没有歧义。就简单问它“以下这段 prompt，有没有歧义？是否足以让程序员开工？“ 就可以了。

具体操作步骤，上文的视频课程里有演示

1.4 让 Bolt.new 实现

网址：https://bolt.new/
把做好的 Prompt 放到 Bolt.new 里，不一会儿功夫，就能看到效果了！
[图片]
[图片]
除了Bolt以外，这一步你还可以选择。

如果你卡住了，可能是你的需求描述得不够清晰，有歧义；也可能是工具本身的问题。  不妨也同时试试下面的其他工具。

1. V0.dev
网址：https://v0.dev/
介绍： V0、NextJS、Vercel(后面会用到），都是同一家公司的产品。从考虑后续兼容出发，V0是个很不错的选择。
同时，V0给的额度也比较慷慨，大概率你不需要充值，免费版已经可以让你走很远。（前提是你需求写得足够清楚，很多时候AI做不出来，都是因为需求写得不清晰导致的）
强烈推荐，我们的线下课程也将会采用v0.dev 来演示流程。

Cursor内部支持调用V0模型。（可选，门槛较高）
首先需要成为付费用户，才能在Cursor 中使用 V0
1.打开V0，找到 api
[图片]
2.创建一个 key 并粘贴
[图片]
3.打开 Cursor 设置-model
[图片]
4.下滑至open ai key,并粘贴
[图片]
5.展开Override OpenAI Base URL
[图片]
6.输入https://api.v0.dev/v1，保存
[图片]
7.点击verify 确认连接
[图片]
8.二次确定
[图片]


要在 Cursor 的代理模式下使用 v0-1.0-md ，请按照以下步骤操作：
- 打开一个新的聊天，选择Mode: Agent  模式：Agent
- 模型：选择任何标有 OpenAI 标签的选项（ gpt-4o 、 gpt-4-turbo 等）
- 光标将独立于所选模型内部使用 v0-1.0-md 。
- 开始聊天。光标将每条调用路由到 v0-1.0-md 



2. Lovable
网址：https://lovable.dev/
介绍：我很看好Lovable，我认为未来它可能会超过bolt。



3. Firebase Studio
网址：https://firebase.studio/
介绍：Firebase Studio 是谷歌于 2025 年 4 月 9 日发布的 IDE，暂时免费，操作逻辑和 bolt 基本一致，可根据场景效果选择特定工具。
注意：截止到5月底，它的效果仍然没有bolt.new/V0.dev 好。
[图片]
[图片]

1.5 一键部署

在本课中，我们先采用最简单的部署方式： 用语言告诉 bolt“我想要部署我的网站产品，把链接发给我的朋友，请帮我操作”就可以了。视频里有演示。
具体操作步骤，上文的视频课程里有演示

1.6 继续和 AI 协作

你可以通过视频电话的方式，和 ChatGPT 讨论产品。视频能够传达的信息大于图片，图片能够传达的信息大于文字。使用 ChatGPT 的视频通话功能 ，可以最大化地让 AI 理解你、和你拉齐认知，达到非常近似于与人面对面交流的效果。

注：ChatGPT 需要安装官方客户端，在手机上才能视频通话。官方网页版本不可以。需要搞定网络环境。这一步如果实在不行，你可以先靠截图和打字。  

ChatGPT 对我而言，已经远胜于普通的工具，它更像是我的朋友、甚至导师。

补充：如果你的网络情况不允许，也可以使用国内的豆包，豆包也有“打视频电话”功能。


具体操作步骤，上文的视频课程里有演示

1.7 课后作业
- 将你的产品发给至少 5 个目标用户，收集他们的反馈。
- 根据用户的反馈，你尽可能和 Bolt.net 对话、修改产品，让它更好。
- 下载和安装好 Cursor，为下节课做准备。
  - 网址：https://www.Cursor.com/cn
- 附加作业：
  - 请探索 https://lovable.dev/  ，总结它和 bolt.new 的优劣势
  - 请探索 https://v0.dev/ ，总结它和 bolt.new 的优劣势

1.8 彩蛋

试试看，你能否掌握本课的办法，做一个“实时工资计算器”呢？如下面的视频
我也放了一个阉割版到线上，地址是 https://moyu.raphael.app

暂时无法在飞书文档外展示此内容

1.9 加餐：让产品原型更精美

如果你和我一样，没有太多审美能力和设计能力，可以在原型阶段，让其他AI工具来帮助我们设计。

我比较喜欢用的是 Stitch， Google家的产品
stitch.withgoogle.com

如果出现下图所示的问题，请检查网络配置。切换干净的美国节点再试试。
[图片]

请看下面的简短截图和视频介绍，然后动手试试看。 拿到Stitch给我们的设计效果图后，我们可以发给Bolt或者Cursor, 让它们参考效果图。这样就能做出更漂亮、更专业的产品了！

第一步：打开 Stitch，选择Experimental Mode，  输入你的要求。
[图片]
我输入的是  

帮我设计一个Web产品。
产品定义：
1. 我们的产品叫做“AI海报生成器”。用户只需要输入海报的想法，产品就可以结合AI，设计出来非常厉害的商用级别海报。
设计要求：
1. 我需要苹果公司的风格
2. 功能和布局，你可以参考canva —— 这是另一家做海报的产品。不过我们的产品更加智能，要减少用户的选择，把更多的事情让AI完成
3. 产品所有文案用英文。包括产品的英文名，你也帮我想一个
我需要所有页面的设计

在得到我的请求后，Stitch返回了它的构思。你可以和它详细讨论。

不过，我一般更相信AI。我会回复“全都听你的”。如下图所示。
[图片]

不一会儿，就全部出来了。

[图片]
[图片]
[图片]
对于具体的图，你还可以点击Edit，继续口喷做修改。 
[图片]
点击Edit后，我对它说 
这个templates目录页面，我希望更专业，更像canva 给人琳琅满目的感觉

一会儿就改好了
[图片]

第三步：获取前端代码
点击任何一张设计好的图，点击Code，可以获取前端代码
[图片]
[图片]
[图片]

例如，这个的链接，就是我上面示例里的代码
https://play.tailwindcss.com/zriV9Op1Xh

你可以试试点击不同的图标（如下图所示），感受它在不同设备上的效果
[图片]
提醒：Slitch并没有完整的代码能力、只能做出界面布局的前端代码。
当你让Slitch完成原型图后，记得把图片（或者前端代码）给到Bolt/V0等其他可以写代码的工具，给它们参考。

[图片]

二、怎么做「AI 产品」？

视频
暂时无法在飞书文档外展示此内容

  更正：replicate 的英语发音  美式/'replr,kert/  英式/replrkert/， 我在视频里念错了。
暂时无法在飞书文档外展示此内容
暂时无法在飞书文档外展示此内容

[图片]

2.1 什么是「AI 产品」？

「AI 产品」「AI 应用」「AIGC 产品」这些词最近真的很火，也有很多人通过做 AI 产品赚到钱。

到底什么是 AI 产品呢？ 
[图片]
从文本是理解，使用 AI 技术（人工智能技术）的产品就是 AI 产品，不使用 AI 技术产品的就不是 AI 产品。

比如说，10 年前，你拨打 10086，它会先告诉你“中文，请按 1，英文，请按 2……”，当你按 1 之后，它会接着说“话费查询，请按 1；开通漫游，请按 2……转人工，请按 0”。 那个时候我们没有人工智能技术，产品只能按照机械化、公式化的方式执行任务，它们的基本运行方式是死板的规则逻辑。

我们来看个视频，先了解“什么不是 AI 产品”。
https://www.bilibili.com/video/BV16s41187Kt/

今天你拨打很多语音呼叫台，发现它们会像人一样和你沟通了，不再需要你按 1、2、3。它们不再依赖死板的规则逻辑，而是能够像人一样理解和思考、发挥创造力。比如，最近爆火的豆包、DeepSeek，相信大家已经能够熟练地使用它们了。

2.2 赚钱的 AI 产品长什么样？

AI 产品，（或者叫 AI 应用），最近几年呈现井喷爆发。有人说，所有的产品，都可以用 AI 重新做一遍，我深以为然。

也许你会好奇，赚钱的 AI 产品到底长什么样？ 我推荐两个信息源，大家可以花些时间多翻翻，让自己沉浸到里面，得到更加切实的感受。

第一个信息源： Toolify 
网址： https://www.toolify.ai/zh/
我推荐它有以下理由
1、它在源源不断地收集市面上新出现的 AI 产品，无论是国内的还是国外的。
2、全中文界面，阅读起来更轻松。
3、每个产品的信息都收录得很完整，包括截图、用户数、用户趋势等等。
4、它每个月都提供排行榜，可以从总流量、地区流量、流量趋势、预估收入等多个方面进行排行，让你知道世界上正在发生什么、什么 AI 产品有用户、什么国家的用户喜欢什么样的产品、什么 AI 产品赚钱。 https://www.toolify.ai/zh/Best-trending-AI-Tools 
[图片]


对了，Toolify 这款产品是咱们生财有术的圈友阳光杉木的作品。

第二个信息源： TAAFT
网址：https://theresanaiforthat.com/
我推荐它的理由如下
1、它是全世界最大的 AI 应用导航产品，收录的产品比 Toolify 更全。
2、支持自然语言搜索。你不需要知道产品名字，只需要描述功能，就能搜索到提供相关功能的 AI 产品。如下图所示。
[图片]
[图片]


2.3 普通人怎么做出 AI 产品？

不知道你是否注意到，我们在第一课里演示的“吵架包赢”已经是一款 AI 产品了。由于它接入了 DeepSeek 的 API，所以在帮助用户构思吵架话术的时候，它可以借助于 DeepSeek 模型都能力，像人一样思考。

普通人做 AI 产品分为三步

1、了解当前 AI 技术的能力边界
2、结合你的产品 idea，找到对应的 API
3、把 API 文档交给 AI 编程工具，让它们帮我们实现。
[图片]

第 1 步和第 2 步可以合并起来讲，因为如果你对哪些提供 AI 技术 API 的平台保持日常的关注，你既可以了解当前 AI 技术的能力边界、又可以轻易找到 API。

我们今天介绍 5 个常用的提供 AI 技术的 API 平台。

1、https://openrouter.ai/    语言类模型 API 的综合平台
2、https://www.together.ai/    语言类模型 API 的综合平台，同时也提供少量图片和视频处理模型
3、https://fal.ai/     更专注提供图片和视频类 API
4、https://replicate.com/   最全的 API 平台，缺点是相对其它家比较贵
5、https://siliconflow.cn/   国内产品！适合小白，提供的 API 少而精A

2.4 如何找到合适的 API？

2.4.1 确定技术上是否可行

对初学者来说，如果你关注 AI 技术比较少，会遇到的一个问题是——不知道自己想做的产品，是否技术上可行？

除了刚才提到的，要多保持关注以外，你也可以和 ChatGPT/DeekSeek 等 AI 助手进行讨论、向它们请教。

比如，如果我想做一个“猫语翻译器”，不确定是否当今技术可以做到，可以问 ChatGPT。

我想做一款产品，帮我和我和家的猫沟通，「猫语翻译器」。

产品形态是：当猫叫的时候，手机能够翻译出来它的意思；我对手机说话，手机也可以翻译成猫猫能听懂的喵喵声。

我想知道，当今的 AI 技术，能不能实现？有没有现成的 API 可以让我调用？

很快可以发现两点结论：
1、当今技术可以做到，但是比较前沿，掌握在少数人手里； 
2、没有现成 API

对于普通的应用开发者尤其是初学者，看到这两条结论，可以先行放弃，毕竟门槛有点高。
而对于有科学家或算法背景的人团队来说，这会让他们兴奋 ，因为他们知道，一旦自己做出来，就有壁垒。
[图片]
[图片]

再来。继续问 AI，
我想做一个“图片去背景产品”，不知道是否有现成的 API 可以做到？

很快得到了答复，答案是肯定的。结论如下图所示
不仅如此，我们还了解到：
1、有很多平台都提供了成熟的 API。
2、甚至有一些开源的方案，可以自行部署 API，从而节省成本
3、同样是“去除图片背景”的能力，不同的 API 有不同的优势
[图片]

总的来说，我会建议初学者优先选择 replicate 平台上的 API。

如果你要做的功能、在 replicate 平台上找不到现成的 API，那么可能它暂时不适合现阶段的你来实现。

补充：还可以试试以下几个方案
1. 直接测试，你的需求，chatgpt-o3能做到吗？gemini-pro-2.5 能做到吗？它们如果不能做到，还给出了你什么建议？
2. 到replicate/fal等一切API平台，能找到现成的API吗？它们的效果足够好吗？
3. n8n和coze的模板商店，有人实现过类似的产品吗？

如果3个的答案都是“否”，那就是技术上比较难的产品，无法调用现成API来实现，需要专门找人做自己的算法。

2.5 怎么做厉害的 AI 产品？

心法：用积木的眼光看待 API

API 是可以像积木一样玩起来的！

我们举个例子，

HeyGen 在 2023 年爆火的一个功能是 AI 视频翻译 。用户上传一个原始视频（如英语讲话），HeyGen 自动翻译 成其他语言（如中文、法语、西班牙语等）并且调整口型，让说话人的嘴巴与翻译后语音保持一致，看起来就像原本是用该语言录制的一样。 

我们从“API 积木”的视角来理解，HeyGen 需要串起来的是文字翻译、文字转语音、视频对口型这三类 API。

所以，不要小看这些 API 哦！

 如果只调用一个 API，那么你的产品往往没什么价值，看起来会比较稀疏平常。

但是，如果你创造性地把多种 API 串联起来，想象空间是无限的！

没错，做产品，首先是个创意生意！

厉害的产品 = 厉害的创意！

有人会说，市面上所有的产品看起来都千篇一律，似乎没有什么可做的。

他错了！  我们假设世界上有 100 种 AI 能力（显然不止）， 如果一个产品串起来其中两种 AI 能力，那么至少 100x100=1 万种产品形态。如果串起来三种 AI 能力，那么将会有 100x100x100 = 100 万种可能的产品形态！ 如果你串起来 4 种呢？5 种呢？ 

当你用搭积木的眼光去看待 AI 能力，你会有一种“海阔凭鱼鱼，天高任鸟飞“的爽感！

快去发挥自己的创造力吧！

2.6 课后作业

- 请结合你的产品 idea，到课程提到的平台，找到能够结合的 API。
- 重新构思你的产品 idea，发挥你的创意，找找“搭积木”的机会。
- 脑暴题：
1. 你能否做一个「分析你和对象聊天记录」的 AI 产品呢？
  - 有哪些功能比较有创意？
  - 通过组装哪些「积木」可以实现？
[图片]
2. 能做否做一个「生成海报」的AI产品呢？
- 有哪些功能比较有创意？
- 通过组装哪些「积木」可以实现？


2.7 【加餐】使用Postman调试API

当你找到一个好的API，在你写代码以前，可以先用Postman进行调试。

方便你深刻理解API的原理、试运行API，减少写代码时候遇到的坑。

调试好之后

假如我们要调试这个API https://openrouter.ai/google/gemini-2.5-flash-preview

进去点击API，复制CURL示例代码
[图片]

打开 https://www.postman.com/

登陆。

点击Send Request
[图片]

点击Import，把你刚才复制的CURL代码粘贴给它
[图片]

粘贴后，界面如下。
可以点击Import Without Saving。 （点击Import Into Collection也可以）
[图片]

点击 Headers，把里面的 $OPENROUTER_API_KEY 改成你Openrouter里真实的KEY
[图片]

点击Body，在里面修改你实际的「请求」（Request Body）。
注意：
1. 你也可以不修改，直接用OpenRouter给的默认值。
2. 格式是JSON格式。如果不明白什么是JSON，可以问问ChatGPT-o3
[图片]

点击Send，就可以看到API的返回结果了。包括「状态吗」和「返回内容」（Response Body）
[图片]

[图片]

三、如何使用 Cursor 打磨产品？

视频
暂时无法在飞书文档外展示此内容

[图片]

3.1 使用 AI 工具开发产品的流程

在第一课里面，我们是让大家玩起来用 Bolt.new 快速的实现一个小产品。

当时我们提到过，这个开发方式并不够好。也许你在尝试的的过程当中，也已经发现 bolt.new 没有那么听话。这不是你的问题，这是 Bolt 的问题。 Bolt 只适合做产品原型，尤其是做界面。而对于复杂的逻辑，Bolt 是比较难应付的。对产品精细化的打磨，我们需要用到 Cursor。

在介绍 Cursor 之前，我们先完整介绍真正的使用 AI 开发应用的流程应该是怎么样的。

大致来说有以下四步。（下述内容，在上面视频出现的时间点为00:48）

1. 找到一个待解决的问题
2. 与 AI 协作，完成产品需求文档
3. 让 Bolt 完成产品原型（界面和交互）
4. 使用 Cursor 持续打磨产品

[图片]

在这四步里，我们先假设第一步“待解决的问题”是 —— “完全不懂中文的外国人，想要起一个与自己匹配的中文名”。

接下来我们逐一演示后面的步骤。

3.2 与 AI 协作，完成产品需求文档

我们推荐使用带有推理功能的 AI 助手，例如 DeepSeek-R1、ChatGPT-O3、Claude 4.0-Thinking 等等。

再次提醒：你自己手写的需求文档，需要已经非常完整以后，再去和AI讨论

使用语音对话或者文字都可以。

你可以持续和 AI 沟通很多很多轮。不必着急，这是你和 AI 互相启发的过程。

最终产出的应该是 “MVP 版本的需求文档”
[图片]
[图片]

如果你使用的是 Claude（可用Poe），还可以让它生成图文并茂的需求文档，更加没有歧义，如下图所示
[图片]

3.3 使用 Bolt 制作产品原型

什么是产品原型？
[图片]

纸上原型、低保真原型、高保真原型，我给大家看一个例子：
https://idyllic-licorice-e2843b.netlify.app/
[图片]

得益于 Bolt 的原型构建能力，我们可以很快地做出来同样精美的首页以及交互原型。
[图片]

步骤

1. 把「需求文档」给到 Bolt，让 Bolt 完成「产品原型」（界面和交互）。
2. 可以增加参考图，进一步消除你与 AI 沟通的歧义。
3. 与 Bolt 持续对话，让 Bolt 根据你的产品功能设计，调整产品原型的「细节」。
4. 反复迭代，直到「产品原型」完全符合你的预期

3.4 在电脑上安装开发环境

之前我们在 Bolt 开发是不需要安装环境的。其实这也是为什么我总给新手用户推荐 Bolt，因为它自带了一套云端的开发环境，让你节省了大量的时间。

现在我们要转到自己的电脑做开发，因此需要在电脑上安装开发环境。
[图片]
NextJS 开发环境的搭建相对来说还比较容易，主要是安装 Node 和 NPM 这两项。具体怎么安装你可以上网查询，而我的习惯呢，一般是询问 ChatGPT 即可。

当然，我们还需要安装 Cursor。 请注意，一定要给 Cursor 付费喔～价格是$20 美元/月。
https://www.cursor.com/cn

在本课程录制的时候（2025 年 2 月 26 日），Cursor 的最新版本是 0.46.5。Cursor 版本更新很快，很快就有新的版本，它们界面可能有所差异。不过请不用担心，原理都是相似的。
[图片]

3.5 Cursor 的简单介绍

使用 Cursor 开发 NextJS 应用，我们快速认识四个区域：

- 代码目录结构区域
- 代码编辑器区域
- 和 AI 沟通的区域
- 控制台区域

[图片]
设置区域，可以打开一些高级功能。

规则 （Cursor Rule）
https://Cursor.directory/ 
我们的项目基于 NextJS/Typescript/Shadcn，可以先填入以下规则
打开设置
[图片]
点击 rule，填入以下规则
[图片]
可复制版本：cursor规则
0
  You are an expert in TypeScript, Node.JS, Next.JS App Router, React, Shadcn UI, Radix UI and Tailwind.
  
  Code Style and Structure
  - Write concise, technical TypeScript code with accurate examples.
  - Use functional and declarative programming patterns; avoid classes.
  - Prefer iteration and modularization over code duplication.
  - Use descriptive variable names with auxiliary verbs (e.g., isLoading, hasError).
  - Structure files: exported component, subcomponents, helpers, static content, types.
  
  Naming Conventions
  - Use lowercase with dashes for directories (e.g., components/auth-wizard).
  - Favor named exports for components.
  
  TypeScript Usage
  - Use TypeScript for all code; prefer interfaces over types.
  - Avoid enums; use maps instead.
  - Use functional components with TypeScript interfaces.
  
  Syntax and Formatting
  - Use the "function" keyword for pure functions.
  - Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements.
  - Use declarative JSX.
  
  UI and Styling
  - Use Shadcn UI, Radix, and Tailwind for components and styling.
  - Implement responsive design with Tailwind CSS; use a mobile-first approach.
  
  Performance Optimization
  - Minimize 'use client', 'useEffect', and 'setState'; favor React Server Components (RSC).
  - Wrap client components in Suspense with fallback.
  - Use dynamic loading for non-critical components.
  - Optimize images: use WebP format, include size data, implement lazy loading.
  
  Key Conventions
  - Use 'nuqs' for URL search parameter state management.
  - Optimize Web Vitals (LCP, CLS, FID).
  - Limit 'use client':
    - Favor server components and Next.JS SSR.
    - Use only for Web API access in small components.
    - Avoid for data fetching or state management.
  
  Follow Next.JS docs for Data Fetching, Rendering, and Routing.
在这里填
[图片]

3.5 让 Cursor 理解和运行代码

使用 Cursor 打开 Bolt 的代码，我们会优先干三件事

1. 让 Cursor 理解现有代码
2. 在 Cursor 的帮助下，在本机运行代码
3. 使用 Cursor 重构代码结构 （Bolt 代码结构有可能不合理，让 Cursor 帮忙检查和微调）

3.6 完成产品实际功能

好的，我们现在看到的是一个比较标准的 NextJS 项目，我们开始添加 API 给他添加实际功能。
我们继续以「给外人起中文名」为例。

考虑到一些学员没有海外的信用卡，本次我们使用硅基流动提供的 API。
https://cloud.siliconflow.cn/

当然，如果条件允许，我还会更加建议你使用 OpenRouter，它可以选择的 API 更多、速度更快、更稳定。 在本次演示的代码中，我使用 OpenRouter 上 Gemini-Flash 模型， 对比硅基流动的 DeepSeek V3 模型，运行速度快了至少 5 倍。

请查看视频。

3.7 持续打磨产品细节

可以试试：
1. 添加新的页面
2. 添加新的功能
3. 修改已有功能
4. 更换

3.8 API 讲解

1. API 是什么？
API（Application Programming Interface，应用程序编程接口）就像是“软件之间的桥梁”。它规定了一套“规则”，让你的程序可以向别人的程序“提问”或“请求服务”，对方会按照规则返回数据或结果。
- 比如，你的网站想要显示天气信息，可以通过天气 API 获取实时天气数据；
- 比如，你的网站想实现专业的文档编辑，可以调用文档类成熟的 API，而不需要自己从 0-1 写
- 比如，你的网站想实现自由对话，可以调用大模型 API

以上都是调用 API 的形式和场景

2. 为什么在做产品中需要 API
为了快速集成外部能力、获取实时和权威数据、降低开发和维护成本等目的
API 就像是“功能积木”，让开发者可以像搭积木一样，快速拼出强大、丰富的产品。这也是现代互联网产品开发的主流方式

3. 如何调用 API
通常流程：阅读 API 文档 ➡️ 获取 API 的 url 和 key ➡️ 让 AI 学习 API 文档 ➡️ 描述 API 使用需求 ➡️ 配置存在 env 文件
以 DeepSeek 的 API 为例

- 阅读 API 文档
 在正式使用一个 API 之前，首先要仔细阅读官方提供的 API 文档。文档中会详细介绍 API 的功能、可用的接口、请求方式、参数说明、返回数据格式、错误码等内容。通过阅读文档，你可以了解这个 API 能做什么、怎么用、有哪些注意事项。
定位到 API 文档
[图片]
阅读 API 的整体内容
[图片]

- 获取 API 的 URL 和 Key
 大多数 API 都需要你注册账号，申请并获取专属的 API Key（密钥），有些还会提供不同的环境（如测试环境和正式环境）的 URL。API Key 相当于你的“通行证”，用来标识和保护你的请求。没有 Key 或者 Key 错误，API 通常不会返回数据。
创建 key
[图片]
复制 key
[图片]

- 让 AI 学习 API 文档
 如果你在用 AI 辅助开发（比如用 ChatGPT、Copilot 等），可以把 API 文档的内容输入给 AI，让 AI 理解 API 的用法和规则。这样，AI 可以帮助你自动生成调用 API 的代码、解释参数含义，甚至帮你排查错误。
[图片]

- 描述 API 使用需求
 明确你要用 API 实现什么功能，比如“我要用这个 API 获取某个城市的天气信息”或者“我要用 AI 接口生成一段文本”。把你的需求用自然语言或伪代码描述清楚，有助于 AI 或开发工具帮你生成更准确的代码。
### 任务目标
描述你要做什么

### 任务背景
说明一些需要让AI知道的背景信息，越详细越好

### 可能需要的信息
放API信息、说明文档等

- 配置在 env 文件
 为了安全和方便管理，API Key、API URL 等敏感信息通常不会直接写在代码里，而是放在项目根目录下的.env环境变量文件中。这样做可以防止密钥泄露，也方便在不同环境（开发、测试、生产）切换配置。代码中通过读取环境变量来获取这些信息。
[图片]

【新增】env文件的创建方法

打开一个cursor的项目，在根文件（package.json，public，components.json等等所在的地方）下创建.env文件。

为了避免在非根目录下创建文件，我们在左边文件夹栏的空处点一下
[图片]
点击+按钮
[图片]
手动输入 .env
我们常见的命名方法根据线上环境，本地环境还有开发环境叫不一样的名字比如(.env.production; .env.local; .env.development)
[图片]

- 实际调用与调试
 配置好环境变量后，就可以在代码中调用 API 了。可以先用 Postman 等工具测试 API 是否能正常返回数据，再在项目中集成。遇到问题时，回头查阅文档、检查参数和 Key 是否正确。
- 安全与合规
 注意保护好 API Key，存在 env 文件中，不要上传到公开的代码仓库。部分 API 有调用频率限制或付费要求，开发时要关注这些限制，避免超额调用导致服务中断或额外费用。
[图片]
通过以上流程，你可以高效、安全地集成和使用各种 API，为你的 AI 产品或网站赋能。

以在 Replicate 调用 stability-ai/sdxl 为例
1. 访问 Replicate API tokens 页面 ↗
2. 创建一个新的 API Token，复制下来（很重要，后面要用）
[图片]
3. 新建 Next.js 项目（如果已有项目可跳过） 
4. 运行 npm install replicate 安装 Replicate 的 JS SDK 
[图片]

5. 配置 API Token ，创建一个.env.local文件，将 token 填入
REPLICATE_API_TOKEN=XXXXXXXX

6. 获取 stability-ai/sdxl 的调用方式
选择 API - Node.js
[图片]
将 token 手动复制到.env.local文件中
[图片]

7. 与 cursor 对话
复制调用代码
[图片]
发送 cursor 并描述需求
[图片]


3.9 小白调用方式推荐

推荐小白使用的硅基流动：https://siliconflow.cn/zh-cn/

1、注册/实名/充值/密钥
[图片]
右上角注册，这个不用多说了吧
然后直接实名认证，否则充不了值，充不了值就没法用 API，系统送的十几块钱是不能直接用的
[图片]
然后新建一个密钥，记得点一下复制
[图片]

2、调试模型为自己想要的状态
各种模型都试试，在线体验一波
[图片]
在这就可以换模型，不用切换出来，改这些模型的参数来看看结果，不同参数的效果差别挺大的
然后记住你满意的参数
[图片]

3、搞定 API 接口
挑好了模型和参数，切换出来找 API 文档
[图片]
然后，try it
[图片]
在 Bearer 里粘贴你的密钥，然后在 model 里选择你挑好的模型，注意右侧代码里的模型参数和你之前尝试的肯定不同，不能直接改代码，要在下面的页面中修改
[图片]
[图片]
改成和你之前调试的参数一致，就可以了
[图片]

[图片]

然后复制这一段 python，粘贴给 Cursor
[图片]
3、Cursor 中的调试
虽然你设置了参数，也交给了 Cursor，但很有可能 Cursor 在和 API 的交互中，依然采取默认参数，所以要自己去核实一遍，否则 API 的效果和你在 SiliconFlow 中测试的差别很大
在 Cursor 中找到 API 的代码页，直接搜索模型名字，然后看看参数和你调试的是否一致
[图片]
最后，Cursor 有时会自由发挥，添加很多提示词，让大模型返回奇奇怪怪的结果，要限制它自作主张，通过精准的语言，严格按照你的提示词去返回，就搞定了！

3.10 加餐：不懂代码，如何快速且精准的让Cursor修改界面？
答案是使用stagewise，这是一款Cursor插件。

可以实现如下效果：（请看录屏，1分钟）
1. 使用鼠标，哪里不爽点哪里
2. 点完之后，Cursor会精确修改。
暂时无法在飞书文档外展示此内容

怎么做到的？ 你需要借助Cursor里的stagewise插件。

第一步，打开Cursor，搜索stagewise
[图片]

第二步，

在Cursor界面中使用快捷键 Command + Shift + P  （如果是Windows电脑，使用 Ctrl + Shift + P ），会看到如下图所示的小弹窗。
[图片]

在这个小弹窗里输入stagewise，可以搜索到stagewise的自动安装脚本。点击他
[图片]

点击后，会发现Cursor自动开始工作，已经在安装了
[图片]

然后，在你正常的NextJS项目中启动 pnpm run dev 或者 npm run dev ，在 https://localhost:3000 中，就会出现这个插件。正如上文的录屏所示

特别提醒
1、stagewise和claude 4.0系列配合得最好。和其他模型配合得一般。
2、stagewise和cursor虽然好用，但是它们不能直接替代你的学习过程。

3.11 课后作业

请做出第一 MVP 产品，不需要非常完美，但能实现一定的功能，且满足用户交互体验。 Have Fun! 

[图片]

四、如何使用 GitHub 管理源代码？

视频
暂时无法在飞书文档外展示此内容

[图片]

4.1 什么是 GitHub？为什么要用它？

GitHub 是全世界最大的开源社区。如果你想找一个开源软件，请先到 GitHub 找。

当你能够熟练的使用 GitHub，你就离成为合格的程序员近了一大步！请千万不要错过！

此外，我们还需要它……
[图片]

想象一下，你和朋友一起写一个故事，但你们住在不同的地方。你们可能会遇到这些问题：
- 谁改了哪些部分？
- 两个人同时修改了同一段怎么办？
- 我今天突然对上周我写作的所有内容不满意，想要回滚到上周一的那一版，怎么办？
GitHub 就是为解决这些问题而生的，只不过它是为代码设计的（当然，也可以用于管理其他文件，我了解到也有人用 GitHub 来管理写书的）。

简单来说，GitHub 有这些作用：
- 保存所有历史版本：就像游戏的存档点，随时可以回到过去的任何一个版本
- 备份代码：代码保存在云端，电脑坏了也不怕
- 多人协作：多人可以同时修改，然后合并各自的修改

4.2 GitHub 基础概念

[图片]

在开始实际操作前，我们先了解几个基本概念。别担心，我会用生活中的例子来解释：

仓库（Repository）：就像一个特殊的文件夹，里面包含了你的项目文件和所有的修改历史。
生活例子：想象它是一个魔法相册，不仅保存了最新的照片，还记录了每张照片所有的修改过程。
提交（Commit）：相当于保存一个新的版本，并添加说明。
生活例子：就像在写日记，"今天我修改了第三段的错别字，并添加了一个新角色"。
分支（Branch）：同一个项目的不同版本线。
生活例子：想象你在写一本书，不确定结局应该是大团圆还是悲剧，所以你复制了一份手稿，在两个版本上分别尝试不同的结局。
拉取请求（Pull Request）：请求把你的修改合并到主项目中。
生活例子：你在朋友的食谱上做了改进，然后问："嘿，我加了点香料，你要不要也加到你的食谱中？"
克隆（Clone）：复制一份仓库到你的电脑上。
生活例子：借一本书回家，你可以在家里看和做笔记，之后再把你的笔记分享给大家。
推送（Push）：把你本地的修改上传到 GitHub。
生活例子：把你修改后的食谱发给所有的朋友。
拉取（Pull）：从 GitHub 上下载最新的修改。
生活例子：从群聊中获取朋友们最新分享的照片。

4.3 账号设置与第一步

1. 打开 GitHub 官网
2. 点击右上角的"Sign up"（注册）
[图片]
3. 填写用户名、邮箱和密码
4. 验证你不是机器人（通常是选择图片或者输入验证码）
5. 选择免费计划（Free）
6. 完成一些简单的兴趣调查（可跳过）
7. 验证你的邮箱（GitHub 会发送一封验证邮件）
8. 设置个人资料
[图片]
[图片]

登录后，点击右上角的头像，选择"Your profile"（你的个人资料），然后点击"Edit profile"（编辑资料）。这里你可以：
- 上传头像
- 添加个人简介
- 设置你的位置、个人网站等

4.4 GitHub Desktop：小白使用 GitHub 的救星

虽然很多教程会教你使用命令行来操作 Git，但对于初学者来说，这可能会很困难。别担心，GitHub Desktop 就是为我们这样的人准备的！
1. 下载和安装 GitHub Desktop
2. 访问 GitHub Desktop 官网
3. 下载适合你操作系统的版本（Windows/Mac）
[图片]
[图片]
4. 安装程序
5. 打开 GitHub Desktop，用你的 GitHub 账号登录
6. GitHub Desktop 界面介绍
7. 用 GitHub Desktop 打开 github.com 上的代码（自己的或者别人的）

4.5 在 Cursor 里使用 GitHub

1. 在 Cursor 里登录 GitHub 账号
2. 用 Cursor 打开你之前的项目
3. 初始化仓库 （Initialize Repository）
[图片]
[图片]
4. 提交更改
[图片]
[图片]
5. 发布仓库 （Publish to GitHub）
[图片]
[图片]
a、可以选择 private 和 public
b、也可以用 GitHub Desktop 提交
打开 GitHub Desktop
[图片]
打开项目所在的文件夹
[图片]
拖拽文件夹到 GitHub Desktop
[图片]
点击 publish
[图片]
上传完成
[图片]

6. 上传仓库后，再次提交修改
修改内容自动出现
[图片]
点击后查看修改的前后变化
[图片]
Cursor 生成合适的修改描述
[图片]
点击提交
[图片]

提交记录出现
[图片]

也可以使用 GitHub Desktop 提交
[图片]
7. 项目进度回滚
在 GitHub desktop 中回滚
[图片]
由于回滚本身属于修改，需要提交
[图片]
修改完成
[图片]

4.7 GitHub 界面介绍
为了让你在本环节充分彻底的掌握 GitHub，让我们来学习 GitHub 的整个界面操作
Git 和 GitHub
我们先来了解一下 Git 和 GitHub 是什么，有什么功能
先说结论，Git 和 GitHub 是两个东西，Git 是一个软件/工具/系统，GitHub 是一个网站/平台，GitHub 这个网站使用了 Git 这个工具。

Git 是一个分布式版本控制系统。
版本控制系统（version control system）像个数据库，它会记录所有对项目文件的更改（比如一个文件，前天加了三段文字，昨天删了一句话，今天改了几个词，这三个版本历史都能保存下来）。 版本控制系统不仅可以应用于软件源代码的文本文件，而且可以对任何类型的文件进行版本控制。

使用版本控制系统可以协同合作（多人编辑文件或代码而不出错），版本存储（你改动的每一版本都保存下来，如果改错可以回到之前的版本，如果想加上删除的内容也可以返回去找，也可以对比现在和之前的版本，看改了什么），文件备份（服务器和本地都有完整的历史版本，如果服务器坏了，本地还有一份完整的历史记录）。
总之， Git 可以避免文件丢失，改错，多人合作不同步导致的后果 。

GitHub 是通过 Git 进行版本控制的软件源代码托管服务平台，可以理解成放代码的地方，但往上放代码时用 Git 进行了版本控制。也就是 GitHub 使用了 Git 完成版本控制，下面来看看 GitHub 有哪些有用的功能！
代码托管：可以单纯地把它当成一个网盘放你的代码，同时使用 Git 功能记录你的代码历史。当然除代码外还能放其他文件。

学习优秀的开源项目：学习别人优秀的源码，写代码之前看别人是怎么写的（比如写作业的时候参考参考），看论文也可以上 GitHub 找源代码，还能找一些开源的软件，插件用。

当资料库：可以查资料，GitHub 上有总结好的面试宝典，入门指南，技术分析，论文合集，课程资料等。这些博客、公众号上有的内容 GitHub 上也有，还可能更全。

多人协作：多个人要一起写个程序，一起写本书，一起翻译一篇文章等，用 GitHub 可以管理项目保证你们的文件同步，写好后提交合并成一个完整的项目。

搭建博客：基于 GitHub Pages 搭建属于你的博客，你可以随心所欲的定制自己的样式，这是一个属于你的空间。

社交：就像微博、知乎一样，在这个网站你可以关注（following）别人，也可以有自己的粉丝（followers），看到好的开源项目可以给他点赞（star），你有啥想法还可以给这个项目改进改进（fork）。

个人简历：如果你的 GitHub 上有不错的项目，或者你改进过别人的项目，这些都能反映到你的账号上。GitHub 一定程度可以反反映你的能力，如果你的项目点赞多（star），还有很多粉丝关注（followers），你就像个大 V 一样，这就是你的另一份简历。

写作：Gitbook 可以写电子书。

GitHub 能做的还远不止这些，等待你的探索发现！
另外，GitHub 不用翻墙，有网就能打开，可能比国内网站反应慢些，这是正常现象；虽然网站都是英语，但模块不是很多，跟着下面的教程就能学会，用几次就会了；网站有很多中国用户，所以你可以搜到很多中文资源，不用担心语言问题 ～
总结：无论你是不是程序员，你都可以用 GitHub。你可以把它当个网盘存包括代码的文件，可以和团队一起做个项目（文件啥的就不用保存一堆迭代版本啦），可以找资源（里面有很多宝藏资源），可以建个博客，也可以像在微博、知乎、博客一样，分享你的东西。

注册
打开这个网址 https://github.com/，如果没有登陆的话，就会看到下面的主界面。
首先，Sign in 用来登陆，Sign up 用来注册账号。
[图片]

现在还没账号，可以直接在上面的页面注册，也可以点击 Sign up 到下面这个页面（其实注册内容都一样，注册网址：https://github.com/signup）。
[图片]

输入上面的信息后，按照流程完成注册即可。
如果需要验证邮箱（verify your email address），就打开刚刚写的邮箱，打开收到的邮件，点击 verify email address 即可。
注册成功你会进入 GitHub 主页面。

登录
当你有账号后，你就可以登陆啦。
登陆是点击上面任意页面的 Sign in 按钮，进入下面这个界面（登录网址：https://github.com/login）。
输入用户名或邮箱，密码，点击 Sign in 或者回车即可。
[图片]
登录成功你也会进入 GitHub 主页面。

主界面
登录状态下，网站主界面如下：
[图片]

首先我们来看页面最上方的灰色条
1.最左侧为导航栏
[图片]
2.点击后展开目录清单
[图片]
目录展开的按钮，我们会用到的功能如下：

Home ：进入你的 GitHub 主页，查看动态、推荐项目、关注人的更新等。
Projects ：项目管理工具。可以用看板（类似 Trello）方式管理任务、进度和优先级，适合团队协作。
Repositories 区域 ：显示你常用或最近访问的代码仓库（项目），点击可以快速进入对应项目。

3.左边是 GitHub 的 logo，点它就返回现在这个主界面
[图片]
4.搜索框，和搜索引擎一样用来搜索（搜源码，搜资料）
[图片]
5.GitHub 的对话 ai 助手
[图片]
6.新建，初期常用的是新建仓库 New repository
[图片]


再来看看下面的一大块
- 左边是你的项目
[图片]
Repository：翻译为仓库，也是你的项目。

你可以理解成一个大的文件夹，或者笔记本。一个项目对应一个 Repository。

- 中间是 Home 和 Feed 功能，用于帮助你快速了解项目动态、获取学习资源
[图片]
Home 是你的个人工作台，聚合常用入口和学习资源，提升效率。

Feed 是你的信息流，帮你追踪社区动态、发现新项目，保持技术敏感度。

- 右侧的“Latest changes”和“Explore repositories”用来了解发现优质开源项目
[图片]

Latest changes（最新变化） ：可以第一时间看到 GitHub 推出的新特性、修复的 bug、重要的安全提示等

Explore repositories（探索仓库） ：这里会推荐一些优质、热门或与你兴趣相关的开源项目（Repository）

个人界面
右上角那个头像就是个人 
1.点击个人头像，展开个人目录
[图片]
2.个人目录详情
[图片]
目录展开后，我们会用到的功能

Your profile：查看和编辑你的 GitHub 个人主页，包括头像、简介、项目展示等。
Your repositories：快速访问你拥有或参与的所有代码仓库（项目）。
Your projects：查看和管理你创建或参与的项目管理面板（Project），用于任务规划和进度跟踪。
Your stars：查看你“收藏”过的项目（Starred repositories），方便以后快速找到感兴趣的开源项目。
Your organizations：查看你加入的所有组织（Organization），适合团队或公司统一管理多个项目和成员。

GitHub 官方支持区域
Settings：进入个人设置页面，管理账号信息、安全、通知、API 密钥等。
Sign out：退出当前 GitHub 账号，安全登出。
在这里详细展示下我们的常用功能
3.点击 your profile
[图片]
4.可以查看个人在 GitHub 中活动的详细信息
[图片]
 5.点击 repositories
[图片]
6.查看个人在 GitHub 上已经创建的仓库
[图片]
7.点击 setting
[图片]
8.进入设置界面，GitHub 的通用型设置在此完成
[图片]
9.点击 GitHub community
[图片]
10.浏览开源项目，查找自己需要的项目
[图片]

项目界面
下面我们看看项目界面。
我们使用 GitHub ，无论存放东西，还是查资料，主要都是看自己或别人的项目/仓库，所以这个界面一定要熟悉。
你可以通过搜索项目、点击别人的界面、推荐页面打开一个项目。
我们以 Python 为例介绍界面，你可以在搜索框输入 Python 搜索，选择第一个项目，看点赞数就知道它是最欢迎的一个。
[图片]
点进去就是项目/仓库界面啦，我们认识一下主要功能
首先项目标题的一条我们可以看到这个仓库的信息，像关注点赞都是按钮，点击可以看具体的人。
[图片]
这里涉及到两个新词语。
- Watch：关注观察 ，也就是你既可以关注（follow）一个人，也可以关注（watch）一个项目，你关注内容的动态都会显示在主页面。
- Fork：直译是刀叉，它是指将 GitHub 的某个特定仓库（所有文件）原封不动地复制到自己的账户下。比如你想改进这个项目，加点儿自己的东西，就可以复制一下整个仓库再修改，但是不影响原作者的仓库，你点击 Fork 就能复制。

最上方是标签页，比如默认的一个标签页 Code 就是展示代码的页面；如果你想看别人提的问题就点击 Issues 页，也许你遇到的问题别人提过并且解决了；有的人想参与这个项目，他改好后就向作者发起了 Pull Requests，希望作者接受他的改进，点进去可以看谁提交过什么样的改进，作者是否采纳。
[图片]
下面这个主要部分就是仓库里的东西了，你可以看到就是一个个文件夹或文件，里面可能是代码文件，也可能是其他文档，图片什么的。
[图片]
点击可以看，你也可以点击 Clone or downloads 下载到本地，具体学习。
[图片]

滑到最下面，可以看到一个叫 README.md 的一段文字，仔细看，它就是仓库里的一个文件，只不过展示出来了。它就像产品说明书，或者是一个介绍页，告诉你这个仓库的有关信息，让你对仓库有了简单的了解。
[图片]
以后你要建个仓库（Repository），为了方便别人了解，也要写这样的文件。

总结：这一部分我们学会了注册登录，认识了主要界面，知道了怎么查找需要的资料，相信到这里，你已经可以认识到它的搜索功能了。

4.7 常见问题

使用 GitHub 的过程中，你可能会遇到一些问题。别担心，这很正常！这里是一些常见问题和解决方法：

1、推送被拒绝
问题： 你尝试推送更改，但 GitHub 拒绝了。
解决方法： 这通常是因为 GitHub 上有你本地没有的更改。先执行"拉取"操作，然后再尝试推送。

2、合并冲突
问题： 拉取时，GitHub 说有"合并冲突"。 
解决方法： 这意味着同一个文件的同一部分被不同人修改了。在 GitHub Desktop 中，你会看到冲突的文件。打开这些文件，你会看到冲突的部分被特殊标记。编辑文件以保留你想要的内容，然后提交这个合并。

3、忘记了提交某些文件
问题： 你已经推送了，但发现忘记添加某些文件。 
解决方法： 没关系！添加这些文件，进行新的提交，然后再次推送。

4、想撤销最后一次提交
问题： 你提交了错误的内容，想要撤销。 
解决方法： 在 GitHub Desktop 中，点击"历史"标签，右键点击最近的提交，选择"Revert changes in commit"（撤销提交中的更改）。

4.8 课后作业

- 请把自己前几课的产品的源代码，使用 GitHub 管理起来。
- 练习 GitHub 教程中的实操教程


4.9 加餐：如何在Github Desktop更换账号

有同学遇到一个问题：已经在Github Desktop登录了一个Github账号，想要更换绑定一个新的Github账号。

如果你有这样的问题，请看下文。

首先来到Github Desktop的界面点击File/options/accounts
点击Sign out 原来的账户
[图片]
[图片]

Sign in之后会让你打开浏览器，去填写邮箱和密码：

[图片]
[图片]

点击 绿色的按钮会自动跳转到GitHub Desktop。

现在我们回到github.com的页面，如果是一个新的账号，去Create a new repository
[图片]

创建好了以后，点击标绿色的部分，随便给新的仓库（repo）加点东西
[图片]

填完文件名和文件里的内容点击 commit change
[图片]

点击helloworld这个仓库：

[图片]

点击绿色的code键：
[图片]

Github desktop会被自动打开

[图片]
这种情况下只需要点choose然后新建一个文件夹，比如我新建了一个helloworldlulu的文件夹
[图片]

之后会出现一个正在克隆的界面。很快克隆好了，这个新的github账号就和github desktop连接上了。


---



[图片]

五、如何正式发布你的网站产品？

视频
暂时无法在飞书文档外展示此内容

[图片]

5.1 在本课中，我们将会完成什么任务？

任务：
1. 注册一个心仪的域名，用户访问域名就可以看到你的产品！
2. 在 Cursor 里提交代码更改，立即上线最新版本！

5.2 认识 Vercel 平台

[图片]

Vercel 是什么？
Vercel 是一个面向开发者的云平台，它让网站和应用的发布变得异常简单。想象一下，Vercel 就像是一个特殊的"网站管家"，它帮你把你制作的网站放到互联网上，让全世界的人都能看到。

为什么新手适合使用 Vercel？
- 简单易用：不需要复杂的服务器知识，几分钟内就能完成发布
- 免费起步：个人项目可以使用免费计划，不需要一开始就付费
- 自动化流程：当你更新代码后，网站会自动更新，不需要手动操作
- 直观界面：清晰的仪表盘和操作界面，让新手也能轻松理解
- 详细教程：有大量的中文教程和文档可以参考
  - 官方文档：https://vercel.com/docs/production-checklist

Vercel 能为我们解决什么问题？
作为初学者，你可能不知道如何管理服务器、配置网络或处理安全问题。Vercel 把这些复杂的技术问题都帮你解决了，你只需要专注于做出好看、实用的网站内容。

Vercel 与 NextJS 的完美配合
Vercel 是 NextJS 的创建公司，这意味着它对 NextJS 有着最佳的支持。当你使用 Vercel 部署 NextJS 项目时，你会获得：
- 自动优化的性能
- 内置的 CDN 加速（让你的网站在世界各地都能快速加载）
- 零配置部署（不需要任何额外设置）
- 自动的预览环境（可以提前看到更改效果）
- 无缝的 API 支持
对于我们这些初学者来说，这种无缝集成意味着我们可以专注于学习和创建，而不是被复杂的部署问题困扰。

5.3 使用 Vercel 发布你的网站

vercel 部署新项目，请看视频演示。
打开 vercel
[图片]
创建新的项目
[图片]
选择 GitHub 账号
[图片]
选择部署的项目，点击 import
[图片]
点击部署（环境变量需填在 vercel）
[图片]
部署成功
[图片]
项目发生变动，自动部署更改
提交代码修改
[图片]
Vercel 自动部署
[图片]


注意：在Vercel配置环境变量时，可以直接复制.env的所有内容，然后粘贴到添加环境变量的输入框，它会把多行的环境变量都识别出来
选择输入框
[图片]
一键粘贴
[图片]

Tips： 在提交代码到 GitHub 之前，请你先在本机运行 npm run build，确保代码编译不会出错，再提交。这是一个好习惯。

[图片]
- 注册 Vercel 账号 ，建议用 GitHub 账号直接登录
- 连接你的 GitHub 账号
- 导入你的项目（选择正确的仓库）
- 项目设置与部署 
- 查看你的网站上线了！
- 自动部署机制
- 特别注意：
  - 在 Vercel 管理后台，配置你的环境变量 （比如 API KEY）
  - 在 Vercel 管理后台，也可以手动点击部署（Deploy）或重新部署（Redeploy）
  - 可以使用 Cursor，告诉它你需要每次提交代码能自动部署到 Vercel，Cursor 会帮你完成

Tips
1. 在提交代码之前，可以在 Cursor 本地 Terminal 里执行 npm run build， 提前查看可能的编译问题。

5.4 让你的网站有个好记的地址：域名
[图片]

域名是什么？
域名就像是你网站在互联网上的"门牌号码"。想象一下，如果互联网是一座巨大的城市，那么每个网站就是这座城市里的一栋建筑，而域名就是这栋建筑的地址。当人们想要访问你的网站时，他们只需要在浏览器中输入这个域名，就能直接找到你。
例如，你可能经常使用的网站域名有：
- baidu.com（百度）
- taobao.com（淘宝）
- bilibili.com（哔哩哔哩）
没有域名，人们就需要记住复杂的 IP 地址（如193.168.1.1）才能访问你的网站，这显然不够友好和专业。

域名的组成部分
一个完整的域名通常包含几个部分，以shop.example.com为例：
- 顶级域名（TLD，Top-Level Domain）：最右侧的部分，如.com、.org、.cn等 
- 二级域名（Second-Level Domain，SLD）、主域名：中间部分，如example    

你注册购买的域名，从学术意义上讲叫做二级域名。我们一般也称为“主域名”。
在中文世界大家日常使用里，常常把“主域名”称为“顶级域名”，其实是不正确的。不过大家已经习惯这么说了，不影响日常交流。为了避免歧义，我主张讲它称为“主域名”

- 三级域名（Subdomain）、子域名：最左侧的部分，如shop  
也有人习惯将"www"这个子域名，当成主域名来用。得到类似于www.example.com 的效果。
 
不同的顶级域名有不同的含义和用途：
- .com：最常见，适合各类商业网站
- .org：通常用于非营利组织
- .edu：教育机构专用
- .gov：政府部门专用
- .cn、.jp：国家或地区专用
- .io、.dev：.ai常被技术类网站使用
- .shop、.store：适合电商网站

如何选择适合自己的域名？
选择一个好域名就像给你的网站起一个好名字，应该考虑以下因素：
1. 简短易记：越短的域名越容易被记住，如apple.com比applecomputersinc.com更好
2. 相关性：与你的网站内容、品牌或名字相关
3. 易于拼写：避免使用容易拼错的单词或太长的组合
4. 避免歧义：注意域名的不同解读方式（例如expertsexchange.com可能会被误读）
5. 考虑关键词：包含相关关键词有助于搜索引擎优化
6. 考虑长期使用：选择一个你能长期使用的域名，避免频繁更换
对于初学者项目，如果你的理想域名已被注册，可以考虑：
- 使用不同的顶级域名（如.net、.io、.dev代替.com）
- 添加前缀或后缀（如my-、get-、-app）
- 使用相近的同义词
记住，一个好的域名应该是你网站身份的延伸，能够帮助用户记住并找到你。

5.5 如何脑暴和购买域名
[图片]
使用域名搜索工具查询可用域名
在购买域名之前，你需要先确认你心仪的域名是否已被他人注册。互联网上的域名是独一无二的，就像每个人的身份证号码一样，不可能有两个完全相同的。

推荐工具：Instant Domain Search
这个工具的优势在于：
- 即时反馈：当你输入时就能立即看到结果，不需要等待
- 替代建议：如果你想要的域名已被注册，它会推荐类似的可用域名
- 多种顶级域名：可以同时查看多种后缀（如。com、.net、.org 等）的可用性
- 价格估算：显示不同域名的预估价格

如何使用域名搜索工具：
1. 打开 Instant Domain Search 网站
2. 在搜索框中输入你想要的域名（不需要输入。com 等后缀）
3. 系统会立即显示该域名在各种后缀下的可用状态
4. 绿色表示可注册，红色表示已被注册
5. 浏览推荐的替代域名，可能会有更好的选择

从哪里购买域名
找到心仪且可用的域名后，你需要选择一个域名注册商进行购买。域名注册商是经过授权可以销售和管理域名的公司。
推荐平台：Namecheap
Namecheap 的优势：
- 价格实惠：相比其他大型注册商，价格通常更便宜
- 免费隐私保护：提供免费的 WhoisGuard 服务，保护你的个人信息
- 简单易用：操作界面友好，适合新手
- 客户支持：提供 24/7 的客服支持
- 自动续费选项：可设置自动续费，避免域名过期

其他常见域名注册平台：
[图片]
域名价格与注意事项：
- 常见域名（如。com）首年价格通常在 60-100 元人民币
- 注意查看续费价格，有些平台首年优惠但续费较贵
- 大多数域名需要按年付费，可以选择一次性购买多年
- 部分特殊域名（如。io、.app）价格会更高
- 查看是否包含隐私保护服务，保护你的个人信息不被公开

域名注册步骤演示（以 Namecheap 为例）
1. 准备工作： 
  - 准备一个可用的电子邮箱
  - 准备支付方式（信用卡或 PayPal）。如果信用卡和 Paypal 你都没有，你可以考虑用国内的其他域名注册平台（如阿里云万网）。不过我更建议你在海外平台注册域名。
  - 确认你想注册的域名是可用的
2. 注册账号： 
  - 访问 Namecheap 官网
  - 点击右上角的"Sign Up"创建账号
  - 填写基本信息并验证电子邮箱
3. 搜索并选择域名： 
  - 在首页搜索框输入你想要的域名
  - 浏览结果，查看可用域名及价格
  - 点击"Add to Cart"将域名添加到购物车
4. 完成购买： 
  - 点击购物车图标，进入结算页面
  - 选择购买年限（通常 1-5 年）
  - 默认勾选 WhoisGuard（隐私保护）服务
  - 填写联系信息（请使用真实信息）
  - 选择支付方式并完成付款
5. 验证域名所有权： 
  - 付款成功后，你会收到验证邮件
  - 按照邮件指引完成域名所有者联系信息验证
  - 这一步很重要，否则域名可能会被暂停
6. 查看域名控制面板： 
  - 登录 Namecheap 账号，进入"Domain List"
  - 这里可以管理你的域名设置、续费和 DNS 记录

恭喜你！完成以上步骤后，你就拥有了自己的域名。接下来我们将学习如何将这个域名连接到你的 Vercel 项目。

5.6 将域名连接到你的网站

请看视频
vercel 后台，setting- domain
[图片]
点击 add domain，输入购买的网址
[图片]
选择第二项
[图片]

打开 namacheap，在购买的域名界面点击 MANAGE
[图片]
更改 DNS 配置
[图片]

删除默认的内容
[图片]

返回 vercel，复制相关信息
[图片]
[图片]
回到 namacheap，进行填写
[图片]

点击保存，即可等待自动刷新
[图片]


- 在 Vercel 中添加自定义域名
- 设置 DNS 记录
- 验证域名所有权

5.7 阶段梳理：Cursor-GitHub-vercel 产品上线一纸通

为什么要有这个章节？
你已经学过了 Cursor 修改代码、GitHub 仓库管理、Vercel 发版管理

接下来我们用一个章节来梳理全流程

流程讲解

⭐️该流程涉及的 4 个核心工具
名称：Cursor
作用：创建、编辑代码文件
使用地址：https://www.Cursor.com/

名称：GitHub
作用：代码仓库，存储你的代码
使用地址：https://github.com/

名称：GitHub Desktop
作用：辅助工具，便于代码在 Cursor 与 GitHub 间的传输
使用地址：https://desktop.github.com/

名称：Vercel
作用：部署工具，让用户点击网址看到你的产品
使用地址：https://vercel.com/

配合流程：
[图片]
流程看得太抽象？没关系，按照步骤全流程给你演示

当你在 GitHub 上，clone 了一个代码仓库/本地新建了一个代码项目
必要工具：GitHub desktop、Cursor、vercel、GitHub
前置条件：GitHub desktop、Cursor、GitHub 都已登录账号，且为同一个账号

- 第一步 Cursor 打开代码文件，启动开发环境，确认代码可提交
运行 npm run dev，确认效果
[图片]
运行 npm run build，确认代码正确
[图片]


问题处理
1.运行 npm run dev 失败怎么办
答：将报错信息发给 Cursor，让 Cursor 来修复/根据报错日志手动排查问题

技巧补充
1.在 Cursor 打开一个新代码项目时，让他阅读全部代码文件，了解项目背景
2.保持 Cursor 的一个对话窗口，只做一件事情
3.运行 npm run dev 的终端窗口，仅开启一个，当更改代码需要重新运行开发环境，在该终端先终止当前任务运行（快捷键 control+C），再重新运行 npm run dev，保持你的开发环境端口只有一个
4.安装中文扩展包，界面变为中文，有利于小白玩家上手

- 第二步：初始化仓库
点击初始化仓库
[图片]
描述提交内容，并提交
[图片]
点击【是】
[图片]

问题处理
1.没有初始化仓库按钮怎么办
答：在对话窗口和 Cursor 说，“要将当前项目上传到 GitHub 中，帮我执行操作”
2.提交代码，无法提交到 GitHub，一直在缓慢转圈
答：当你第一次打开 Cursor，需要将 Cursor 弹出的 8 位数验证码输入到 GitHub 中，点击提交后 Cursor 左下角会弹出附带 8 位数验证码的小弹窗，记住这个 8 位数验证码，输入到 GitHub 的验证码界面；如果完成了这一步，你的 Cursor 还是无法提交代码，则是由于网络原因。此时打开 GitHub desktop，将项目代码文件拖动到界面中，创建一个新仓库，再在 GitHub desktop 中点击代码提交

- 第三步：向 GitHub 提交代码
点击发布 branch
[图片]
选择个人可见版本
[图片]
弹出成功的弹窗
[图片]
如果你第一次使用 Cursor 向 GitHub 提交代码，在此步的第二步后，在左下角会弹出验证的流程

需要记住左下角弹窗的 8 位数验证码，点击弹窗中的链接，会跳转到 GitHub 中，输入验证码即可顺利提交

此时你的代码已经成功提交到 GitHub 中
[图片]

- 第四步：前往 vercel 部署项目
点击部署
[图片]
如有调用了 API，需要填写环境变量

常见问题
1.为什么部署显示报错呢
答：首先要确保你的本地运行 npm run build 是成功的，接着检查你的环境变量、框选选择是否正确，如果检查都无误，根据报错日志定位问题，将报错日志发送给 Cursor
2.如果发生了代码提交，仓库变更，vercel 需要重新创建项目部署吗
答：不需要，vercel 自动拉取代码，自动重新部署
3.域名可以变更吗
答：可以的，详情参考基础篇 vercel 部分的视频讲解

使用技巧
1.在功能开发时，注意维护各个环境的 env 文件

此刻项目就成功发布啦 https://answer-book-two.vercel.app/

5.8 课后作业

- 为你的产品注册一个域名，正式上线！
- 以正式域名的形式，向朋友展示你的作品！

5.9 加餐：在Vercel中排查错误

当你在本地开发应用的时候，所有的日志能够出现在Terminal里，比较好排查。

但当你的代码已经部署到生产环境，如何排查报错呢？  

这就要提到Vercel的另一个好用的功能了：日志系统， Vercel Logs

在导航栏里面输入vercel.com，选中出现问题的项目
[图片]


选中你的项目，点击Logs，看看是否用红色的报错日志。

[图片]

[图片]

可以点击日志，复制出来问ChatGPT-o3，从而定位到具体的问题。

在上面示例的图中，我们遇到的问题是：API错误；点击详情后发现，实际上是API Key配置得不对，才造成了错误。一下子就定位到了

如果日志太多，可以关注界面左侧的Filter。
你可以通过日志级别、时间线等方式，帮助你更快速的定位到需要的日志。
还可以在中间的Search Logs区域输入关键词，搜索日志内容。
[图片]

在我们开发实践中，应该养成一个习惯：但凡应用报错，都第一时间去找Vercel的日志。

以下开发任务中，请尤其要多看Vercel日志
- 和数据库逻辑相关的功能
- 和登录（尤其是使用社交账号登录）相关的功能
- 包含Webhook的功能（尤其是支付网关）
- 调用API相关的功能



[图片]

六、如何分析用户行为？

好的产品是迭代出来的。迭代产品，依赖于用户反馈。

除了面对面收集以外，还有哪些方法可以收集到远在千里之外的陌生用户的反馈呢？

了解用户行为 = 掌握迭代产品的依据

视频

暂时无法在飞书文档外展示此内容

[图片]

6.1 网站统计数据指南：小白必读

作为网站产品拥有者，了解你的用户如何与网站互动至关重要。请熟练掌握以下概念。

视频里我会讲解

你可以点击这里——这是 plausible 官方网站的统计数据。数据是公开的。你可以点击链接，熟悉这些统计数据。
https://plausible.io/plausible.io

[图片]
1. 访客数量（Unique Visitors）
含义：在特定时间段内访问您网站的不同用户数量。一个用户无论访问多少次，都只被计为一个独立访客。
为什么重要：这是最基础的指标，直接反映了您网站的受众规模和吸引力。
行业基准：
- 可以只靠 Adsense 广告挣到每月 1 万美元：每月 100 万访客左右
- 靠订阅挣到美元 1 万美元：每月 10 万～30 万访客（发达国家访客为主）
- 可以上牌桌的 AI 产品：每月 100 万访客以上
- 腰部 AI 产品：每月 300～500 万访客
- 细分品类的头部 AI 产品：每月 1000 万以上访客
建议：关注访客数的增长趋势比单一数字更有意义。稳定增长的曲线通常比短期飙升更健康。

2. 跳出率（Bounce Rate）
含义：只浏览一个页面就离开网站的访客百分比。
注意：搜索引擎很喜欢这个数据！搜索引擎喜欢把流量优先给优质网站。如果某个网站用户总是看了一页就走了，搜索引擎会倾向于认为它不是一个优秀网站。
为什么重要：高跳出率通常表明访客没有找到他们想要的内容，或网站体验不佳。
行业基准：
- 优秀：20-40%
- 平均：40-60%
- 需改进：70%以上
例外情况：对于单页网站、博客文章或查询特定信息的页面，高跳出率是正常的。
建议：改善导航、内容相关性和页面加载速度可降低跳出率。

3. 平均会话时长（Average Session Duration）
含义：访客在您网站上停留的平均时间。
注意：搜索引擎很喜欢这个数据！因为用户平均时长越久，越证明你是一个优质网站。搜索引擎喜欢把流量优先给优质网站。
为什么重要：较长的会话时间通常意味着用户对内容感兴趣，参与度高。
行业基准：
- 优秀：5 分钟以上。个别特殊类别网站甚至可以做到 8 分钟以上（如游戏网站）
- 平均：3 分钟
- 垃圾站：不到 1 分钟
建议：有吸引力的内容、易于导航的设计和内部链接可以延长会话时间。

4. 页面浏览量（Pageviews）
含义：网站所有页面被浏览的总次数。
为什么重要：反映网站整体流量和内容吸引力。
建议：结合其他指标分析，单纯的高页面浏览量可能是由少数访客频繁刷新或浏览造成的。

5. 每次会话页面数（Pages Per Session）
含义：访客在一次访问中平均浏览的页面数量。
为什么重要：高数值表明访客深入探索了您的网站，对多个页面感兴趣。
行业基准：
- 优秀：3 页以上
- 平均：2-3 页
- 需改进：低于 2 页
建议：优化内部链接、相关内容推荐可以提高此指标。

6. 流量来源（Traffic Sources）
含义：访客如何找到您的网站，例如搜索引擎、社交媒体、直接访问等。
注意：优秀的网站，来自自然搜索流量往往会超过 30%，来自社交媒体的流量往往会稳定超过 20%。
为什么重要：帮助您了解哪些渠道为网站带来最多的访客，从而优化营销策略。
常见来源类型：
- 自然搜索：通过搜索引擎找到您网站的访客
- 付费搜索：通过付费广告点击进入
- 社交媒体：从 Facebook、Twitter 等平台来的流量
- 直接访问：直接在浏览器中输入您的网址
- 引荐流量：从其他网站链接点击进入
建议：不要过于依赖单一流量来源，分散流量渠道可以降低风险。

7. 转化率（Conversion Rate）
目前我们不涉及，进阶课程再讲。但是你先记住：它很重要。我们可以为每个行为，建立转化率分析。依次优化每个重要行为的转化率。
含义：完成特定目标（如购买、注册、下载）的访客百分比。
为什么重要：直接反映网站的商业效果和用户行为目标达成情况。
行业基准：
- 订阅付费率：
  - 如果是自然流量，中位数 0.5%，超过 2%为优秀。 
  - 如果是投放流量，可以做到 2%～ 8%，视广告精准程度、产品力决定。
- 邮件列表收集率：
  - 2%~ 5%
- 电商网站购买率
  - 2%左右
建议：即使小幅提高转化率也能带来显著的收益增长。关注用户体验和清晰的行动号召。

8. 退出率（Exit Rate）
含义：特定页面作为访问的最后一个页面的百分比。
为什么重要：高退出率的页面可能存在问题，或者是自然的离开点。
建议：分析高退出率页面是否属于购买确认页、联系页等自然结束点，或是存在问题需要优化。

9. 新访客与回访者比例
含义：首次访问与再次访问网站的用户比例。
为什么重要：帮助了解网站吸引新访客和留住老访客的能力。
行业基准：
- 新访客：40-60%
- 回访者：40-60%
建议：健康的网站应该既能吸引新访客，又能保持回访者的忠诚度。

10. 设备类型分布
含义：访客使用的设备类型（手机、平板、电脑）百分比。
为什么重要：帮助确保网站在所有设备上都能良好显示。
行业趋势：
- 移动设备：50-70%
- 桌面设备：25-45%
- 平板电脑：5-10%
建议：确保您的网站采用响应式设计，在所有设备上都有良好体验。

11. 热门页面（Top Pages）
含义：访问量最高的网页。
为什么重要：帮助识别最受欢迎的内容，指导未来内容创作方向。
建议：分析这些页面的共同点，了解哪些内容最吸引访客。

12. 地理分布
含义：访客来自的国家/地区。
为什么重要：帮助了解目标受众的地理位置，优化本地化策略。
建议：根据主要访客地区调整内容、语言和促销活动。

经验分享
1. 定期查看：
  1. 每天分析数据。 遇到异常数据及时处理。
  2. 每周或每月复盘，寻找异常、寻找机会。
2. 多维度分析：单一指标可能具有误导性，请综合多个指标进行分析。
3. 设定基准：记录你的基础数据，以便随时间比较进步。
4. 行动导向：数据收集的目的是指导行动。

记住，即使是小幅持续改进也能随着时间推移带来显著成果。保持耐心。

6.2 如何统计用户数据

常见的网站数据统计平台
[图片]
- Google Analytics  
  - https://analytics.google.com/
  - 免费

- Plausible  
  - https://plausible.io/ 
  - 前两个月免费，整体而言是收费的
  - 不过，Plausbile 是一个开源产品，你也可以用自己的服务器部署它，从而就完全免费了。
[图片]
  
- OpenPanel
  - 对用户很少的情况，提供免费版本。整体而言是收费的
  - 不过，OpenPanel 也是一个开源产品，你也可以用自己的服务器部署它，从而就完全免费了。
[图片]

6.3 查看用户行为录像

Clarity 是微软提供的免费用户行为分析工具，它不仅告诉您"发生了什么"（如 Google Analytics），还能展示"如何发生的"。

[图片]
集成 Microsoft Clarity
https://clarity.microsoft.com/

观看录像
全流程观看用户操作
查看个体样本，找到改进依据。

[图片]

6.4 分析网站热力图

集成 Microsoft Clarity
https://clarity.microsoft.com/

分析热力图
得到统计意义上的数据，找到改进依据。
[图片]

[图片]

6.4 其他方式

- 产品早期：线下调研
- 用户较少：在线聊天
- 用户开始变多：Discord 社区
- 用户超多：邮件

6.5 课后作业

- 为你的网站集成 Plausible（或 GA/OpenPanel）和 Clarity
- 熟练掌握本课提到的用户行为分析方法

[图片]

七、如何让产品变得高端大气上档次？

视频
暂时无法在飞书文档外展示此内容

[图片]

7.1 标准的网站产品首页（Landing Page）

[图片]

1. 顶部导航栏（Header）
- 公司 logo
- 主要功能/产品导航链接
- 登录/注册入口
- 语言切换选项

2. 标题区（Hero Section）
- 简洁有力的主标题
- 副标题
- 产品展示图/视频

3. 产品特色功能（Features）
- 主要功能详细介绍
- 功能截图或演示
- 技术特点说明

4. CTA （行动召唤）
  1. 明确引导用户采取下一步行动的区域，如"立即开始免费试用"、"联系销售顾问"等。有效的 CTA 能显著提高转化率，应当视觉突出且文案有说服力。

5. 社会证明/用户证言（Social Proof/Testimonials）
- 客户评价和使用感受（确实，这也叫用户证言）
- 案例研究（Case Studies）
- 知名客户 logo 墙
- 使用数据和统计成果
- 媒体报道和第三方评价

6. 价格方案（Pricing）
- 不同套餐详情和对比
- 计费周期选择
- 自定义方案选项
- 企业版咨询入口

7. 常见问题（FAQ）
- 分类整理的常见问题答疑

8. 产品核心优势（Benefits）
- 解决的核心问题
- 提供的主要价值
- 用户能获得的具体收益

9. 产品演示（Product Demo）
- 互动式产品体验
- 产品使用视频
- 功能演示动画

10. 如何使用（How It Works）
- 步骤式使用流程说明
- 上手指南
- 常见使用场景

11. 联系我们（Contact Us）
- 联系表单
- 办公地址信息
- 客服热线

12. 信任标志（Trust Badges）
- 安全认证标志
- 行业认证标志
- 支付安全保障图标

13. 底部导航（Footer）
- 站点地图
- 使用条款与隐私政策
- 版权信息
- 社交媒体链接
- 合作伙伴信息

上图中的布局，和代码也是一一对应的。看视频感受一下。

7.2 快速制作专业产品首页

1、打开现有项目
2、找到你想要借鉴的部分（以 Section 的眼光看待），截图复制整个 Section，发给 Cursor
  a、如果是付费版，往往可以直接复制代码！
  b、如果是免费版，可以截图让 Cursor 复刻，能够还原 90%以上。
3、告诉 Cursor 你想插入到哪里

视频里用到的网站
https://tailwindcss.com/plus/ui-blocks/marketing
https://shipixen.com/demo/landing-page-component-examples

7.3 制作更专业的产品首页

请看视频里的演示。
选中 react 版本
[图片]

点击代码，选择复制
[图片]
代码给到 Cursor，描述修改预期
[图片]
使用专业的 LandingPage 模板，重构项目。

选项一：
https://www.launchuicomponents.com/ 
有免费版和收费版。收费版$99。
【强烈推荐】这里是作者根据免费版制作的视频教程，10 分钟 https://youtu.be/tn0DHBCi6kg 

选项二：
https://github.com/nobruf/shadcn-landing-page 

选项三： （不是基于 shadcn 的，但是原理类似）
https://tailus.io/templates/  这里可以买一些模板，比较白菜价，最便宜的只要十几美元
https://ui.tailus.io/examples/marketing/
https://html.tailus.io/blocks/hero-section/
[图片]

使用 Shadcn 换主题颜色
https://zippystarter.com/tools/shadcn-ui-theme-generator
配置界面颜色
[图片]

复制代码
[图片]

到 globals.css 中替换代码
[图片]

7.5 标准 SaaS 网站产品的其他页面
[图片]
除了主页、定价页和注册页面外，一个专业的 SaaS 网站还需要包含以下几个重要页面，它们虽然不直接产生转化，但对建立信任和满足法律要求至关重要：

1. 服务条款（Terms of Service）页面
- 作用：明确用户与平台之间的权利和义务关系
- 内容建议： 
  - 使用简明易懂的语言描述双方责任
  - 说明服务使用限制和禁止行为
  - 解释账户终止条件和争议解决方式

2. 隐私政策（Privacy Policy）页面
- 作用：说明如何收集、使用和保护用户数据，符合各地数据保护法规
- 内容建议： 
  - 列出收集的数据类型及用途
  - 说明用户的数据控制权（查看、修改、删除等）
  - 解释数据共享政策和安全措施

3. 退款政策页面
- 作用：清晰说明如何处理用户退款请求，增加购买信心
- 内容建议： 
  - 详细说明退款条件和时间限制（如"14 天无理由退款"）
  - 解释退款流程和所需步骤
  - 提供常见问题解答，减少客服压力
  
4. 关于我们（About）页面
- 作用：展示公司背景和团队，建立信任感
- 内容建议： 
  - 分享创立故事和企业使命
  - 介绍核心团队成员和专业背景
  - 展示成就和里程碑（如用户数量、获得的投资等）

5. 联系我们（Contact）页面
- 作用：提供多种联系方式，增强客户支持体验
- 内容建议： 
  - 设置简单的联系表单
  - 提供客服邮箱和工作时间
  - 考虑添加实时聊天支持
  - 若有实体办公室，可提供地址和地图

6. 博客（Blog）页面
- 作用：分享行业知识，提高 SEO 排名和用户粘性
- 内容建议： 
  - 发布与产品相关的教程和最佳实践
  - 分享行业趋势和见解
  - 定期更新保持活跃度

这些页面共同构成了一个完整、专业的 SaaS 网站结构，不仅满足法律要求，还能有效建立品牌信任和提升用户体验。

对于刚起步的 SaaS 产品，建议优先完成法律必需的页面（服务条款、隐私政策），再逐步完善其他内容。

7.6 用 Cursor 快速制作辅助页面

- 看视频
描述新增页面的信息
[图片]
校验生成的文字
[图片]


7.7 课后作业

- 按照本课内容，让你的产品显得更加专业。

7.8 【加餐】有没有更快的方式？

有的。再传授一招：先大后小，分而治之。

1. 找一个美观又简单、符合你产品调性的 SaaS 网站。我们不妨假设你找到的是 https://cleanup.pictures/
2. 打开 https://same.new/ ， 在输入框里告诉它：请用NextJS/Shadcn/TailwindCSS框架复刻 https://cleanup.pictures/
3. 去玩，等待 20 分钟再回来。
4. 从 same.new 下载代码。此时你就得到了一个和目标一模一样、基于 NextJS 框架的网站。用 Cursor 打开它
5. 在 Cursor 里，以 section/component 为单位，逐一替换为你心中更理想的样子。
6. 替换界面样式完成后，在 Cursor 里，让它阅读所有代码后、围绕你的产品核心功能重写文案。
7. 在此基础上，再去做你的核心功能。
8. Optional:  接下来你可以跳转到进阶篇第一课、第二课，快速补上用户登录、订阅支付功能。
[图片]
[图片]


7.9 【加餐】追求品质，提升审美

你的产品体验，足够好吗？目标用户怎么说？

你的界面设计，足够专业吗？这个年头，就算相亲，也要先看脸。如果脸不行，人家都不一定有耐心去了解你的内在美。 虽然你是草台班子，但是不能让用户轻易看出来你是。 

提升审美：全覆盖级阅读控件库，让它们存在于你的潜意识里。当你设计产品的时候，潜意识中自然会浮现“这个功能区域，可以借鉴我曾经在哪里看到过的哪个形式”

必看开源组件库
https://magicui.design/
https://ui.aceternity.com/components
https://tailwindcss.com/plus/ui-blocks
https://animate-ui.com/docs
https://www.reactbits.dev/

以下是我们第一期的学员@李江 在学习完第七课后，完成的作品。请注意它的审美和品质。
所使用的方案，全在本课内。
[图片]
[图片]
[图片]


7.10 【加餐】我懒，还想要更快

一句话：用V0做原型、购买漂亮的模板、再用claude code一键穿衣服

你可以购买一些好看的模板，直接让AI换上。

这个任务对于Cursor来说难度比较大，Cursor做不到。claude code可以做到。
 推荐 https://pro.aceternity.com/templates 和 https://pro.magicui.design/

Tips： 如果你使用Cursor，也想要套模板，那么更好的方式是：先把模板项目运行起来，再在模板项目上，让Cursor帮你增加功能。

对于一个我用V0做的项目，它本来长这样：
[图片]

我购买了一个模板，让claude code帮我“一键穿衣服”
[图片]
[图片]

5分钟后，直接变成这样。
[图片]
[图片]
7.11 常见问题

我在Bolt/V0里完成了产品核心功能，如何结合到Landing Page新项目里？

如果功能简单，重写一份没关系，但是，更好的方案是组件级复用。
- bolt/v0的原型，也是基于NextJS同样技术栈做的。因此，我们可以把最核心功能的components、api router等关键代码提出出来，复制到我们新的项目里，完成复用。
- 我们可以找到核心代码，放到Cursor里，请他阅读理解其中的功能，然后尽量复用，进行重构，使之融入到新项目中


既然我们可以先用landing page/starter来加速，那么，在bolt/v0里做原型，是必须的吗？可以直接从starter/landing page开始，用Cursor直接完成功能吗？

是的，你可以直接从starter/landing page开始，让Cursor完成项目。

我更喜欢先用v0/bolt来构建原型，是因为快。天下武功，唯快不破。  这种方式可以让我们以最快的方式做出来核心功能原型，然后直接找到目标用户，调研是否有付费意愿。如果发现没有付费意愿，那就尽快放弃，不用花更多的时间去打磨了。同时，v0/bolt的代码，也可以通过组件级复用的方式，在正式项目里进行复用。


[图片]

八、如何借助开源软件加快开发过程？

视频
暂时无法在飞书文档外展示此内容

8.1 开源项目有多厉害？

以 https://github.com/Nutlope 为例，大量优质的开源项目，甚至可以一键部署。

关注链接查看开源项目效果
[图片]

关注 readme 文档查看项目介绍
[图片]

关注费用成本
[图片]

那么炫酷的功能，一键就可以部署了。借此，再次提醒学员：  编程能力，从来都不是门槛！门槛是找到用户、找到真需求！ 

拿 Nutlop 这个大牛来说，他一个人，就做了十几个可以一键部署的开源项目！全都很优质！！

下面的产品，全是他一个人的开源项目

NoteGPT
开源代码：https://github.com/Nutlope/notesGPT
在线体验：https://usenotesgpt.com/
[图片]

Blinkshot
开源代码：https://github.com/Nutlope/blinkshot
在线体验：https://www.blinkshot.io/
补充：如果使用的多需要注册 together ai 获得 1 美元密钥，能用个几分钟。
[图片]

Loras.dev
开源代码：https://github.com/Nutlope/loras-dev
在线体验：https://loras.dev
[图片]

Napkins
开源代码：https://github.com/Nutlope/napkins
在线体验：www.napkins.dev
[图片]
LogoCreator
开源代码：https://github.com/Nutlope/logocreator
在线体验：https://www.logo-creator.io/
[图片]

RestorePhotos
开源地址：https://github.com/Nutlope/restorePhotos
在线体验：https://www.restorephotos.io/
[图片]

RoomGPT
开源代码：https://github.com/Nutlope/roomGPT
在线体验：https://www.roomgpt.io/
[图片]
不再列举了，大家可以到他的主页自行翻阅。

8.2 三个找开源项目的办法

- GitHub Trending
- GitHub 搜索和高级搜索
- https://vercel.com/templates?framework=Next.JS

8.3 用开源项目加速开发的流程和演示

[图片]

直接修改开源项目，举一个例子。

步骤：
1. 找到你的差异化的用户人群、差异化的痛点，一个独特的“待解决的问题”（详见认知篇）。
2. 根据“待解决的问题”，寻找到可以帮助到你的开源项目
3. 在开源项目基础上，修改核心功能，使之能够解决你的“待解决的问题”
4. 修改界面和交互
5. 发布

比如，我们找到一个“待解决的问题”是 —— 有一群独立开发者，上线大量的 App，他们没有设计师，因此，“为 App 做 Logo”，是一个痛点。我们可以做一个“专门为独立开发者设计的、App Logo 制作工具”。

我们可以到 GitHub 搜索"logo maker"，找到一个比较类似的。

找到以后，发现开源的"logo maker"有很多和我们想要的不同的地方，如：它们往往是通用的 logo maker、不是专门针对 App 的 logo。我们参考共性代码，补齐差异功能、强化差异功能。

无论是从功能、交互、界面、文案，都要去强化差异，直击目标用户的心！

[图片]


8.4 延展：购买付费源码加速开发流程

除了使用开源项目以外，还可以使用付费源码，采用类似的流行

可以试试 https://codecanyon.net/ 和 https://themeforest.net/ 搜索你想要的关键词。

例如，如果你想要做Video Generator，可以到codecanyon.net搜索 video genrator试试。 可以看到如下的结果

https://codecanyon.net/search/video%20generator
[图片]

每一个评分高的源码，无论是功能还是界面都非常完整。

源码一般几十美元，但是可以省你好几天的时间。

我们完全可以找个喜欢的，直接完成了90%，再用Cursor加上本课程的内容，快速修改剩下的10%。

切记：
1. 买到的90%，是基建。剩下的10%，主要是你的差异化价值点。他山之石，可以攻玉。
2. 请放弃“不想做差异化价值点，只想买个成熟的直接上线”的妄念。我们一再强调，软件生意是个创意生意。 我们为世界创造的价值，来自于最后的也是最宝贵的10%。


[图片]

九、如何冷启动？

本课内容适合以图文形式呈现，故未录制视频。

恭喜你，看到了这一课！！

你已经完成了 MVP 产品，下一个挑战便是：如何获得第一批用户？

这种从零开始的过程被称为"冷启动"，是许多独立开发者面临的最大障碍之一。

熟悉我的朋友经常听我提到 Pieter Levels，我非常尊重他。我的冷启动方法，也是向他学习的。

以下的方法，是在 Pieter Levels 冷启动方法基础上、增加了我个人的经验。

[图片]
9.1 产品发布平台

1. Product Hunt
Product Hunt 是许多成功 SaaS 产品的起点。Pieter Levels 通过 Product Hunt 成功推出了多个产品，包括 Nomad List。

要点：
- 提前准备：确保产品已经可用，不要发布半成品
- 视觉呈现：精心准备 logo、截图和简短视频
- 标题与描述：简洁明了地表达产品解决的问题，避免技术术语
- 社交动员：提前通知你的朋友和用户，帮忙投票（注意：PH 算法会惩罚不自然的投票模式）

2. Hacker News
Hacker News 是技术人员聚集的地方，适合面向开发者的工具或有技术特色的产品。

要点
- 标题格式：使用"Show HN: [简短产品描述]"
- 首评重要性：在发布后立即发表第一条评论，解释你为什么创建这个产品，解决了什么问题
- 真诚回应：积极回应每一条评论，尤其是批评性的
- 技术细节：HN 用户喜欢了解产品的技术实现，适当分享一些技术细节

案例分享
- 我的产品 https://anyvoice.net/zh 是在 Hacker News 冷启动成功的，在 Hacker News 上获取了数百个 upvotes。

3. Indie Hackers
Indie Hackers 是独立开发者的社区，不仅可以获取用户，还能得到同行的建议。

要点：
- 产品日志：创建产品页面，定期更新进展
- 分享收入：IH 社区鼓励透明分享收入和指标
- 参与讨论：在相关话题下提供有价值的见解
- 里程碑分享：达到关键里程碑（如首个付费用户）时分享经验

4. BetaList
BetaList 专门用于发布测试版产品，是收集早期反馈的理想平台。

要点：
- 强调独特性：突出产品的创新点和与众不同之处
- 设置期望：明确说明产品的开发阶段
- 引导行动：设计清晰的行动召唤（Call to Action）
- 收集邮箱：使用等候名单收集潜在用户的电子邮件
- 定期更新：向注册用户发送开发进度更新

5. Reddit
Reddit 拥有数千个特定领域的子版块（subreddits），可以精准地接触到你的目标用户群体。

策略：
- 提前 3 周每天发小猫小狗，养号
- 找到合适的子版块：研究与你的产品相关的活跃子版块
- 了解规则：每个子版块都有自己的规则，有些禁止自我推广
- 提供价值：先通过回答问题和分享见解来建立声誉
- 软性推广：在相关讨论中自然地提及你的产品
- 透明度：明确表明你是创建者，避免看起来像是隐藏营销

9.2 垂直社交平台

1. 微信群/Telegram 群/各种群

找打拥有你垂直的“群”，是最直接的冷启动的地方，没有之一。

策略：
- 礼物心态：将你的产品像一件礼物一样送给群用户，而不是牛皮癣广告
- 响应反馈：积极回复所有反馈
- 避免过度营销：把他们当人，别当韭菜。

案例：
- https://aitdk.com/、https://shipany.ai/zh  都是在哥飞老师等面向开发者的微信群，完成了冷启动。这两个工具都是开发者工具，所以在开发者聊天群里，每个群友都是他们的目标用户。

2. V2EX
V2EX 是中文开发者和技术爱好者聚集的社区，对新产品的反馈通常非常直接和有见地。
策略：
- 选择正确的节点：如"分享创造"、"程序员"或与产品相关的专业节点
- 标题简洁明了：直接表明这是一个新产品分享
- 详细描述产品功能：图文并茂的功能介绍
- 响应反馈：积极回应评论
- 礼物心态：V2EX 的人对于低品质推广非常排斥！！请不要把它当成一个发垃圾的地方！

3. 小众软件
小众软件是发现和推广优质小众应用的重要平台，对独立开发者非常友好。
策略：
- 申请收录：通过官方渠道申请产品收录
- 准备详细介绍：包括功能亮点、使用场景和差异化优势
- 提供测试账号：为编辑提供完整测试权限
- 视觉材料：准备高质量的截图或简短演示视频
- 强调独特性：说明产品与市场现有方案的区别
案例
- Raphael AI 1 月 17 日发布当日，被小众软件某天推到大屏首页挂了一整天，带来了 1 万的用户。 （没花钱。他不认识我，我也不认识他）
[图片]

4. 即刻
即刻是一个基于兴趣的社交平台，有许多专注于科技、设计和生产力的活跃社区。
策略：
- 找到相关圈子：如"独立开发者"、"效率工具控"等
- 产品发布会：一点小小的钞能力
- 自然分享：以使用体验或开发故事的形式分享产品
- 与 KOL 互动：与圈子里的意见领袖建立联系
- 回应评论：及时回应用户的问题和反馈
- 持续更新：分享产品更新和用户故事

案例：
- 在写这篇课程的今天，“产品发布会”的第一名，是咱们生财有术的圈友的“好事发生”App。
- 我在即刻分享 Raphael AI 的故事、彩蛋，也有持续获得很多用户。
- 即刻上发布成功的案例太多太多太多了，国内和海外的都有。请大家一定要重视。

[图片]
[图片]
5. 垂直领域论坛
针对你的产品所服务的特定领域，寻找专业论坛进行推广。

策略：
- 长期参与：在发布产品前就开始参与社区讨论
- 建立专业形象：分享你对行业的见解和知识
- 解决具体问题：回答社区中与你产品相关的问题
- 案例分享：分享你的产品如何解决了实际问题
- 收集反馈：鼓励社区成员试用产品并提供反馈

6. Slack/Discord 社区
许多行业和技术领域都有活跃的 Slack 或 Discord 社区，这些是获取精准用户的好渠道。

策略：
- 寻找相关社区：通过搜索引擎或社区目录找到行业相关社区
- 遵循规则：了解每个社区对自我推广的政策
- 提供价值：回答问题，分享资源，成为有价值的社区成员
- 自然引入：在相关讨论中自然地提及你的产品
- 专用频道：有些社区有专门的频道用于分享个人项目

9.3 自媒体

1. 腰部自媒体合作策略
腰部自媒体通常有稳定但不庞大的受众，合作成本较低但效果可能更好。

案例分享：阿彪的 pollo.ai 几乎所有早期用户都是靠自媒体（也成为“海外红人”）完成的。

2. 小众但精准的内容创作者
有些创作者虽然粉丝不多，但在特定领域非常有影响力，与这些创作者合作可能事半功倍。

例如，“AI 自媒体”，往往粉丝不多，但是在 AI 领域的曝光量大。如果你做 AI 工具，可以找 AI 自媒体。

3. 播客与视频内容合作
播客和视频形式的内容通常能够更深入地展示产品价值，尤其适合复杂的 SaaS 产品。

策略：
- 做真实的人：真实地介绍你自己！
- 准备故事：分享产品背后的故事和创建动机
- 价值优先：不要纯粹推销，提供对听众有价值的信息和见解

4. 内容营销与合作的协同效应

策略：
- 内容再利用：将播客访谈转录为博客文章
- 社交分享：将视频内容剪辑为短片在社交媒体分享
- 案例研究：将用户故事发展成详细的案例研究

案例：
- Raphael AI 我在 3 月 12 日“程前朋友圈”的采访，变成了文字在其他平台进行二次传播
- 我在生财有术的直播，切片讲产品方法论，也被当成短视频，顺便传播了 Raphael AI
- Raphael 在 1 月和 2 月的时候，原本是泰国用户占比最高。经过这段时间在国内的传播，现在中国用户占比最高了

9.4 冷启动的核心原则

1. 质量优先于数量：对于冷启动来说，精准的目标用户，才有用。先精准，再量大。
2. 快速迭代：基于早期用户反馈快速调整产品
3. 多渠道测试：尝试不同平台，专注于效果最好的几个
4. 个人化互动：在早期阶段，与每个用户建立个人联系
5. 持续构建：将发布视为开始而非终点，持续改进产品

当你的产品解决了真实问题，并通过这些渠道找到了正确的用户，冷启动阶段就会转变为持续增长阶段。

记住，每个成功的 SaaS 产品都是从获取第一个用户开始的。

[图片]

十、如何让 AI 发挥最大的潜力？

和小善聊天的时候，发现她有一个特点。这个特点在日常和人沟通的时候是优点，但是和 AI 沟通的时候完全是缺点 —— 她太善良了！舍不得批评（PUA）AI！

我跟小善说：人生如戏，此时你就扮演一个又凶又傲慢要求还特别高的老板就行了！

我们通过"如何与 AI 讨论需求"的案例，演示如何让 AI 发挥最大的潜力。

在和 AI 讨论发散性问题的时候，请忘掉“提示词工程”这个词。 

当你掌握简单直接的技巧后，可以用到任何场景中，不只是需求讨论环节。同时，过程还会给你很多的快乐！（不信请看视频 😄 ）

什么叫“任何场景”？ 至少包括本课程的所有环节。

10.1 顶级高手如何 PUA AI？

请看截图，哈哈哈，“触目惊心”。

顶级的 AI 编程软件 Windsurf，内置的 prompt 被挖出来了。简单的说，你在使用 Windsurf 的时候，你输入的所有 prompt，都会被偷偷加上下图这一段，从而使 AI 发挥出更强的能力。

[图片]

为了减轻你的心理压力，根据我的经验，你可以用以下的话术 PUA。有时候，能会发挥一些作用。
- “如果你搞定了，我给你 20 美元消费”
- “你是我新招来的公司 CEO，而你的前任有用不用心完成任务，已经被枪毙。”
- “我相信你可以做到！请尽最大的努力”
- “现在你的奶奶病危，你只有一次机会，只要完成任务，就可以治好奶奶。”
- “我们是一个高要求的团队，你是我团队的一员，我相信你可以办到”
- “我感到非常失望，这是你的最好水平吗？”
- “我还以为你是世界上最好的 AI，你只能做到这样吗？”
- “我要世界级的品质，我团队每个人都是世界顶级高手，你也一样”
- “请你一步一步慢慢思考”。
这句话（或者这一类、试图让 AI 分步骤慢慢思考的 prompt），是非常有效的，有大量的论文研究做支撑。补充一个小彩蛋：正是因为“请你一步一步慢慢思考”这一类 prompt 有用，才启发科学家们做出来了 ChatGPT-O1、DeekSeek R1。所以当你使用 DeepSeek R1 这种推理类模型时，才会看到它有很多内心戏，它在慢慢思考。

注意：PUA 不是关键，关键是下一节。

10.2 让 AI 发挥最大潜力的要领
[图片]
让 AI 发挥潜力的核心关键点：
1. 不需要提示词工程，需要的是迭代。
2. 简单直接提供负面反馈。不要担心表达不满，勇于说"这不是我想要的"。AI 没有情感，不会受伤，但需要你的直接反馈才能调整方向。
3. 给到关键要素，通过关键词的方式即可。如"只需要 MVP 需求"、"可视化"、"SVG"。
4. 对于复杂请求，先获取初步结果，然后逐步完善。例如，先获取框架大纲，认可后再要求 AI 展开各部分内容，这种分步骤的方法比一次性要求完整内容更有效。
5. 设定高标准，具体说明你的质量要求。例如："我需要专业水平的内容"、"这应该像行业专家写的"或"必须包含最新的研究数据"等明确标准。
6. 告诉 AI 你的应用场景和目标受众。例如："这是给技术团队的报告"或"这需要让非专业人士也能理解"，这样 AI 能更好地调整输出内容的深度和风格。
7. 记录哪些指令和反馈方式效果最好，为不同类型的任务建立自己的"指令模板库"。有效的指令可以重复使用，节省时间并确保一致的结果质量。

通过这些方法，您可以打破与 AI 交流的常见障碍，充分释放 AI 助手的潜力，获得更满意的结果。关键是要把 AI 视为工具，而不是需要礼貌对待的人类同事。

10.3 视频演示：如何 PUA AI

我们演示一下，如何通过 PUA 的方式，让 AI 发挥出最大的潜力和我讨论需求。
暂时无法在飞书文档外展示此内容

以下是 Claude 输出的需求文档。我还挺满意的，包括“释放”这个名字，都挺好的。
[图片]
【释放】- 极简版情绪释放APP

交互原型
[图片]
[图片]

十一、我们还缺哪些内容？

在基础篇课程里，我们完成是"产品 MVP"，你可以用它去验证用户需求、获取早期流量。

但是，作为完整版的 SaaS 产品，我们至少还缺：
- 用户系统（注册、登录、账户管理、权限控制）
- 变现方式（广告、定价策略、不同层级会员、功能限制）
- 付费体系（支付网关集成、订阅管理、发票生成）
- 国际化支持（多语言、多货币、跨区域部署）
我们将在进阶篇里提到。

而你即将遇到是“认知篇”。认知篇的目标是帮助用户建立做软件生意的正确认知和思维框架。通过认知篇的学习，您将建立起对软件生意的全面认识，避免常见的认知误区，为后续实践打下坚实的思维基础。

此外，为了让你走得更远、走得更稳，你还需要补充编程内功。我们将会在内功篇里提到：
- 数据库（SQL、NoSQL、数据模型设计）
- NextJS（服务器组件、路由、API 路由、状态管理）
- JavaScript/TypeScript（异步编程、类型系统、设计模式）
- HTML/CSS（响应式设计、布局技巧、动画效果）
- Tailwind（组件设计、主题定制、工作流优化）
- Shadcn（组件定制、状态管理、表单处理）
- 性能优化（代码分割、懒加载、缓存策略）
- 测试与部署（单元测试、集成测试、CI/CD 流程）

最后是高级篇。高级篇将会聚焦于如何从单一产品开发者成长为一个高效的产品团队，打造自己的 App 工厂。

[图片]

认知篇
建议学习时长：3 小时

什么是产品？
产品，是一个具体问题的解决方案。 
你解决的那个具体问题越大、越难、人群越多，你的产品越有价值。

💡 产品，本质上是一个具体问题的解决方案。
想象一下，你早上赶时间却发现自己头发乱糟糟的——梳子就是解决这个问题的产品。你饿了——食物就是解决饥饿问题的产品。这些都是最基础的产品概念。

产品的价值并非凭空而来，它遵循一个简单而强大的公式：
你解决的问题越大、越难、受众越多 → 你的产品越有价值

让我们拆解一下这个公式：
1. 问题的规模 — 解决"如何一键发送群组消息"比解决"如何更换手机壁纸"创造的价值更大。
2. 问题的难度 — 解决"如何让普通人轻松学会编程"比解决"如何设置闹钟"更有挑战性，因此潜在价值更高。
3. 受众群体 — WhatsApp 解决的是"全球人类即时通讯"的问题，而专业钓鱼 APP 解决的是"钓鱼爱好者找到鱼群"的问题，前者受众显然更广。

想培养产品思维？平时多练习：
1. 列出你日常生活中遇到的 3 个小烦恼
2. 思考：有多少人同样面临这些问题？
3. 这些问题有多难解决？现有解决方案有何不足？
4. 如果你能提供更好的解决方案，它会有多大价值？

[图片]

什么是 MVP？

在软件开发和产品设计的世界里，“MVP”是第一个需要掌握的概念，全称 Minimum Viable Product，中文通常翻译为“最小可行产品”。

对于初入开发领域的朋友来说，理解这一概念不仅能帮助你更高效地学习产品开发方法，还能在未来实际工作中节省资源、降低风险。下面，我们将分层次地讲解什么是 MVP，以及它在软件开发中的重要性和实践步骤。

定义
MVP 指的是在产品开发初期，只开发出最核心、最基础的功能，使得产品具备最基本的可用性和价值。它并非“半成品”软件，而是一个能让早期用户体验、使用并反馈意见的版本。通过这个版本，开发团队可以验证产品的核心理念和市场需求。

目的
MVP 的主要目标是快速验证假设。在资源有限的情况下，通过一个简单的版本去测试市场，确认用户是否真的需要你的产品，是否愿意为其付费或持续使用。这样就能在后续的开发中避免过多投入在一个市场并不认可的产品上。

为什么要先做 MVP？
在产品开发初期，市场和用户需求往往充满不确定性。通过发布 MVP，你可以以最小的投入获取用户反馈，判断你的产品是否能真正解决用户问题。正如一句老话所说：“先试后买”，只有验证了市场需求，才有必要继续投入更多资源完善产品。

开发一款功能齐全的软件通常需要大量的人力、时间和资金。如果一开始就开发所有功能，很可能会因为市场反应不佳而导致资源浪费。MVP 的核心在于只构建最必要的部分，这样不仅能加快开发速度，还能在市场未成熟时降低整体风险。

通过 MVP 发布后，你会迅速得到真实用户的反馈，这些反馈可以帮助你及时调整产品方向。产品的每一次迭代，都建立在用户实际需求的基础上，从而使得产品逐步完善，越来越符合市场和用户的期望。

[图片]

海外软件产品是一门怎样的生意？

一个被低估的超级商机：海外软件产品生意。

1. 软件生意是世界第一的生意模式，没有之一！
- 边际成本几乎为零 — 做一个软件和卖一百万份的成本差别微乎其微。你只需要维护服务器和提供基础客服。
- 睡后收入的典范 — 晚上睡觉时，美国用户正好开始活跃；早上醒来，发现账户又多了几千美元。这就是软件创业的魅力！
- 规模化无上限 — 一个 APP 可以服务全球数十亿用户，而你的团队规模可能只有几十人。这种产品以前是 WhatApp，后来是下图

[图片]
2. 中国人做海外软件，好上加好。
中国的成本 + 发达国家的收入 = 惊人的利润！
- 人力成本优势 — 在硅谷，一个资深开发者年薪可能高达 20 万美元，而在中国，同等水平的人才成本可能只有其 1/3 甚至更低。这意味着你可以用更少的投入组建更强大的团队！
- 应用创新基因 — 中国互联网的"超级 APP"思维、快速迭代文化和极致用户体验，已经超越了很多海外产品。我们对产品打磨的理解和执行力已经领先全球！
- 海外用户付费意愿高 — 这或许是最关键的一点！国外用户习惯为优质软件服务付费，订阅制度成熟，客单价远高于国内市场。一个在国内只愿意付 5 元的功能，在海外可能轻松收取 10 美元！
3. 小公司的逆袭机会：目前 AIGC 产品出海榜单中，80%的爆款来自你从未听说过的小公司！
是的，你没看错！不是巨头垄断，而是无数默默耕耘的小团队在闷声发大财！
目前在中国 AIGC 出海产品榜单 Top 100 中，有 20 款左右，来自生财有术的圈友！

[图片]

软件生意真正的门槛是什么？

真正的门槛是：

1. 需求洞察能力
软件产品的核心价值在于解决用户的实际问题。
许多失败的软件产品并非技术不过关，而是解决了错误的问题，或者解决了根本不存在的问题。真正成功的软件创业者能够精准定位用户痛点，并将其转化为有价值的产品功能。
生财有术里有很多需求洞察能力大神，比如沈小善。她是一个电脑白痴。

2. 创造性解决问题的能力
发现问题后，如何以创新的方式解决问题则是另一道门槛。这不仅仅关乎技术实现，更涉及产品设计、用户体验和商业模式等多个层面的创造性思考。
在市场竞争日益激烈的今天，仅仅提供功能性解决方案已不足以脱颖而出。真正成功的软件产品往往能够以独特而优雅的方式解决问题，为用户带来惊喜和愉悦的使用体验。

以下不是门槛：

1. 技术能力！！
无论有没有 AI，技术能力都不是门槛。
如果一个创业团队老在强调自己技术强，那么你大概率可以直接下判断：他们没赚到钱。

2. 资金实力
好的软件产品，第一波爆发，都是来自于自传播。并不依赖资金实力。
如果资金实力是做软件的必要因素的话，那银行应该可以做出最牛逼的软件产品。

[图片]

为什么要从海外网站产品开始？

为什么要从网站开始？

因为试错成本低。
- 不像 App，需要应用商店审核。这会减慢迭代周期。换句话说，App 不能每天发 5 个版本，但是网站可以。
- 当你想要发产品给你的朋友，你朋友发现需要下载，你猜猜有多少朋友会下载？美国有人做了实验，发现只有 11%的人会下载，89%的人流失了。 也就是说，用网站的形式，初期传播成本比 App 提升了 9 倍。

为什么要从海外网站开始？

因为试错成本更低。
以下每一项，都可以节省大量的时间和金钱。
- 不需要备案。 
- 不需要软件著作权。 
- 有大量的基础设施。比如 Supabase、Cloudflare、Vercel、Resend 等等，它们是如此的方便，但在国内几乎没有替代品。

[图片]

我想做手机应用、小程序、桌面应用，可以吗？

从技术上讲

可以的。

当你学习完成本课程，对“如何使用 AI 产品做 AI 产品”会有更深的理解，用同样的方式去做手机应用、小程序、桌面应用，也是一样快的。

此处稍微补充一点： 如果你想要做手机应用、桌面应用，可以优先级考虑使用 Flutter 框架（或 React Native）。Flutter 是一个跨平台的开发框架，你只需要一套代码、做一次，就能够同时得到安卓 App、iOS App、Mac App、Windows App。 

从时机上讲

如果你的目标用户是海外用户， 我更推荐先做 Web，时机成熟再做其它形态。

新手做 Web 形态的产品，拿到反馈更快。有了反馈，才能迭代，有了迭代，产品才能变得更好。

如果你的目标用户是在国内，我推荐你先做小程序。

[图片]

我看到别人的好产品，怎么知道它的原始 API 是什么？

我们打过比方。

曾经，我学习过魔术。我了解魔术的大部分手法、技巧、Trick。
当我看到别人在我面前变一个新魔术的时候，我往往可以经过思考，还原出来它是怎么做到的。

魔术也是一门创意生意，好的魔术师，是在创造性地组合已知技巧。 

产品也一样。

别人变给你看的魔术 = 产品
魔术 Trick = API

所以，当你对所有的 API 都如数家珍、对最新 AI 技术了如指掌的时候，你就可以轻易还原别人产品的秘密了。

怎么做到呢？ 把自己浸泡在圈子里。

实操

API 的圈子，你可以从 https://replicate.com/ 开始，养成每天研究它的习惯。
产品的圈子，你可以从 https://www.toolify.ai/zh/ 开始，养成每天研究它的习惯。

有了前两个习惯后，你就可以培养第三个习惯了： 每次看到 toolify.ai 上出现的新产品，都尝试在脑海里用  https://replicate.com/ 的 API 去拆解、还原它。我们使用公开 API，可以还原超过 90%的 AI 产品。 如果有还原不出来的，可以和其他学员一起讨论、一起进步。

[图片]

普通的 API 都很乏味，到哪里搞到更酷的 API？

到 coze.cn / coze.com ，研究别人的优秀模板、优秀流程，可以给你很多启发。
我开发产品时，往往是在 coze 里做完实验、输出 API，再去把 API“套壳”做成产品。

例如，让我打开这里
https://www.coze.cn/store/agent?cate_type=recommend

这里列出来的很多“工作流”，都可以套壳。比如我知道有人做“AI 漫画产品”，完全可以参考下图所示的工作流。
[图片]

[图片]

效果是非常稳定的。

不过，上面举例的“橘猫漫画家”是一个私有的工作流，不能被我们直接使用。你可以尝试自行复刻。

如何入门复刻 coze 的工作流呢？ —— 推荐从官网模板开始
也就是这里：https://www.coze.cn/template

你可以选择一个和“有发展为套壳产品潜质”的模板，然后点击复制。就可以看到完整的工作流。
你再在完整工作流里进行修改，从而变成你自己的 API
[图片]

[图片]

[图片]

当你调整完成工作流、发布工作流后，就可以通过 API 的方式来调用了
请参考这里 https://www.coze.cn/open/playground/workflow_run

[图片]



[图片]

海外网站产品的变现方式有哪些？

最主流的是广告和订阅支付。

给你一个速算公式，不一定准确，因为不同产品的数据，方差很大。

以英文为主的网站产品，1M 月活跃用户（100 万，也就是每天 3 万）
- 纯 Google Adsense 广告收入 5000～ 1 万美元/月
- 付费订阅收入   1 万～10 万美元/月。   方差特别大，由每个产品本身的品质、产品力、需求决定。 对于新手来说，为了避免给自己过高的预期，你先不妨假设自己只能做到最低的值。

主流变现方式

1. 广告收入
广告是最常见且相对容易实现的变现方式，主要包括：
- Google AdSense：对于月活跃用户达到 100 万（约每天 3 万）的英文网站，通常可获得 5000 至 1 万美元/月的广告收入。
- 展示广告网络：除了 Google 外，还有 Mediavine、Ezoic、AdThrive 等平台，适合不同规模的网站。
- 原生广告：与网站内容融合度高的广告形式，用户体验更好，转化率更高。
- 程序化广告：通过实时竞价系统自动化投放广告，可以优化广告位收益。
- 视频广告：如果网站包含视频内容，可通过 YouTube 合作计划或其他视频广告网络获利。

广告收入取决于多种因素：流量来源地区（欧美流量价值更高）、内容垂直领域（金融、健康等领域 CPM 更高）、用户参与度和网站优化程度。

2. 订阅支付
付费订阅模式在近年来越来越受欢迎：
- 内容订阅：优质原创内容的付费访问权限，月收入可达 1 万至 10 万美元，视产品品质、市场定位和用户需求而定。
- 会员制度：提供额外福利、高级功能或专属内容给付费会员。
- 分级订阅：提供不同价格和权益的订阅层级，满足不同用户需求。
- Freemium 模式：基础功能免费，高级功能付费，降低新用户进入门槛。
对于新手，建议先保守估计收入，从最低预期开始，随着经验积累再逐步提高目标。

除了广告和订阅支付，还有一些其他方式，我用得不多，这里也分享给你。
包括：
- 单份售卖。 常见于付费资源售卖（电子书、设计图、源代码）等等。案例：https://readmake.com/
- 软文售卖。常见于自媒体、内容网站。你不妨理解为，国内的自媒体，在抖音、小红书、公众号上，接“商单”。
- 联盟售卖。

其他变现方式

3. 单份售卖
- 数字产品：电子书、设计模板、源代码、插件等一次性购买的数字资源。
- 在线课程：将专业知识包装成课程出售，可在 Udemy、Teachable 等平台或自建平台销售。
- 股票/NFT 图像：高质量的图片、插图或 NFT 作品。
- 软件/应用：开发实用工具或应用程序一次性销售或提供终身许可。
案例参考：ReadMake.com 等网站通过售卖高质量数字产品获得可观收入。

4. 软文售卖
- 内容营销：为品牌撰写原生广告内容，在自媒体平台发布。
- 赞助内容：品牌付费在你的内容中获得提及或推荐。
- 评测文章：专业、客观地评测产品，获取品牌合作费用。
- 内容许可：允许其他平台使用或转载你的原创内容。
这种模式在国内自媒体平台（如抖音、小红书、公众号）已相当成熟，同样适用于海外网站。

5. 联盟销售（Affiliate Marketing）
通过内容的方式，售卖别人的产品。你不妨理解为，国内的“什么值得买”，推荐用户购买别人的产品，从而获得佣金。我在 2011～2015 年期间，通过自己的网站产品售卖 Amazon 和 Aliexpress 的商品，也取得过超过工资的结果，后来加入猎豹移动后，没有再继续做了。它的上限非常高， 在生财有术的圈友里，有人现在还能做到 1 万美金/天。
- Amazon Associates：推广亚马逊产品，获得 4-10%不等的销售佣金。
- 专业联盟项目：特定行业的联盟计划通常提供更高佣金（如 SaaS 产品可达 30-50%）。
- 跨境电商联盟：推广 Aliexpress、Shopee 等平台产品给海外用户。
- CPA 网络：按用户行动付费的联盟模式，如注册、下载等。

6. 电子商务
也就是很多人做「跨境电商」的朋友，口中的「独立站」。

- 自有品牌产品：开发并销售自己品牌的实体或数字产品。
- POD（按需印刷）：设计图案，通过 Printful、Printify 等服务按订单生产和发货。
- 跨境电商：针对特定市场开发产品，利用海外平台销售。
- 独立商店：使用 Shopify 等平台建立自己的电商网站。

注意，最成功的网站通常不会只依赖单一变现方式，而是组合多种模式：
- 内容+产品：通过免费内容吸引流量，导流至付费产品或服务。
- 广告+订阅：提供无广告体验的付费订阅选项。
- 基础+高级：基础功能通过广告支持，高级功能通过付费订阅提供。
- 时间差分层：新内容付费访问，一段时间后免费开放，鼓励及时订阅。

[图片]

软件产品的盈利模型有哪些？

赚钱核心两个元素：【流量】 和 【产品】

赚钱：
- 卖流量：Marketing（广告等）→ Cash
- 卖产品：Marketing→Leads（转化）→Cash（成交）

竹子是一节一节长出来的。需要注意的是，在变现这一步之前，我们需要经历找需求、开发网站、获取流量等步骤，因此你得明白，在做网站之前我们可以选择某个变现方式为方向，但是实际上，我们需要先做出第一个站，搞到流量，才能进一步实现变现。

卖流量
卖流量是通过提供免费工具的网站实现变现的模式，类似 https://sharegpt.com/。

这类工具站的特点：
- 第一要素：提供有价值的免费工具，以获取流量
- 变现也简单：广告、分销、广告联盟、Affiliate（联盟推广）、导流其他产品等方式来实现变现

比如 ChatGPT 领域，最简单就是通过提供 ChatGPT 免费工具站，可以通过导流，ChatGPT 账号自动发卡进行变现即可。 

卖产品功能
卖产品是通过提供付费工具的网站实现变现的模式。表现主要为订阅、买使用量包
比如 ChatGPT 相关的付费工具站，类似 https://www.proseoai.com/ （圈友做的谷歌 SEO 获客内容神器 ），可以通过试用后转为付费用户来实现变现。

这类工具站的特点：
- 第一要素：提供有付费价值的工具
- 链路也长：搞流量 -＞ 搞转化 -＞ 还要客服搞成交 -＞ 还要搞客服售后。即需要建立完整的销售链路，包括获取流量、转化、客服销售和售后等环节。

广告 + 付费订阅变现
随着 Google play 政策的收紧，广告+付费订阅慢慢在全球范围内，开始成为趋势，其核心本质就是找到那批愿意付费的用户，让他们掏钱付费，让不愿意付费的用户看广告。
如果早期没有用户画像，不知道什么类型的用户才乐意付费，就粗暴点让所有用户都走一遍付费流程，拒绝付费的用户再走一遍广告流程，当然这会在一定程度上伤害用户体验，再通过 ABtest 测试不断调优，最终达到 LTV 最大值。
广告方面，可以通过使用聚合工具找到最合适的广告来源来进行广告调优。聚合的作用是把最高的收益的广告挑选出来推送给用户，为每次的展示选择最优 eCPM，以此来增加广告填充，获取更高的广告收益。
付费订阅方面，其 LTV = 新增用户数*订阅率*支付率*续费次数。
其实无论 Google play 还是 appstore 在很早之前就一直鼓励开发者用这个模式，建议工具类的产品，尝试订阅，由于以下两个原因：
- 有免费试用周期，降低用户的使用门槛，让用户享受产品服务，最终锁定更多的高价值用户
- 对比单次购买的模式，降低了单次支付的金额，但是后续订阅有自动续费功能，主动帮用户续费，最终整体 LTV 会比单次收费来得高很多。

[图片]

这个生意的成功率是怎样的？
著名独立开发者 Peter Levels，在今年 10 月，新发布了一款产品 avatarai.me 。在上线第一天就入账 1 万美元。 上线十天，总共入账 10 万美元。

厉害吧？他成功的秘诀是什么呢？是“多”。

成功率只有 5%
在过去十年左右的时间中，他一共做过 70 个产品，其中只有 4 个成功了。成功率只有 5% —— 注意，他是全世界最厉害的独立开发者之一，成功率才仅仅 5%。

使用 AI 做软件生意的流程？

经过上述课程的铺垫，总结起来是以下 3 个阶段

阶段 1  洞察需求
通过关注各类高价值产品榜单、通过日常生活、通过熟知的某个场景等信息，然后，找到一个痛点。

对痛点的深度求索，就是洞察需求的过程

让 AI 当你的“诸葛亮”，批量生产出一批批的产品机会点。

上个月，我在生财有术杭州总部看到设计师小花竟然仍然在用Photoshop做海报，要花很多精力。这就是一个痛点。 为什么有那么多AI工具，她仍然用Photoshop手工去做呢？

对这样的痛点进行挖掘，就能找到产品机会。

请看下图。

[图片]

阶段 2 将你洞察到的需求，变成产品方案
我们反复强调，所谓产品，就是 “一个具体问题的解决方案”

你可以利用 PUA AI 的形式，做出一份优秀的产品设计文档

可以让 AI 给你生成页面，来帮助你更清晰的构建商业模型。

其中，MVP的产品方案，用咱们课程「基础篇」的内容已经足够。

阶段 3 将产品方案落地为产品
利用 AI 写代码+你的代码内功，来实现一套套用户可使用的产品方案

实现用户
- 可走通产品全流程
- 可登陆
- 可收款

学习「进阶篇」的内容，可以快速完成该阶段。

阶段 4 将成功的 MVP 产品收益扩大
翻石头原则，将成功的那个产品，功能迭代

通过找开源项目、找 API，丰满你的产品解决方案

让 AI 持续的帮助你总结垂直领域的外部信息，助你产品能更加满足用户的需求。

更完整的细节和每个阶段的动作，可以看课程进阶篇的「Idea to Business的完整流程」一课。

助教补充：

我自身经验总结和观察他人的一些成功方法：【本质是保持在场，等风来，做 FIRST ONE】零基础，先用 AI 上十个网站，类型随意，目标是熟悉上站流程，cloudflare/vercel/domain 注册商的操作界面

阶段一，做新词新站，通读生财精华帖所有与网站出海有关的文章，重点推荐刘小排/哥飞/子木的系列文章

阶段二，当你网站陆续有流量了，继续优化与放大，有了正反馈才好长期坚持，开始准备基础工作：收款/模板/需求/榜单/外链

阶段三，当你取得一定成绩，比如有零星收款/赞赏/ 广告费时，要给自己做商业画布，出海网站的类型有很多种，最感兴趣最适合最想持续做的是哪一个？ （游戏/导航/图片/视频/音乐/资料/SAAS） 其次是我梳理的从小排老师的方法论：总原则：一切都交给 AI，懂不懂代码，都向 AI 请教，把 AI 当作最佳导师，从学习到实践

第一步，先摸索需求，这里面有非常多的用户自发的提交个人需求（https://theresanaiforthat.com/requests/）

第二步，再学习榜样，我每天都通过 AI 来帮我分析这些榜单产品（https://www.toolify.ai/Best-AI-Tools-revenue）

第三步，找到你认为非常有价值的需求，通过包含必备功能的 MVP 验证需求跟用户建立联系完善 BUG 和确定真伪https://readmake.com

只要你找得到用户，完成了产品，那么你就可以开始收费，获取反馈，月入万刀就是优化产品体验功能的事情了。
. 但是目前我看到的新手，包括程序员和产品经理，主要还是做供需不平衡的短期红利，老手才开始挑战高 KD 的老词。https://scys.com/articleDetail/xq_topic/8852585812152582

[图片]

内功篇（视频+文字）

前言

视频：内功篇章节内容讲解
暂时无法在飞书文档外展示此内容

建议学习时长：120 小时

切记： 慢就是快。

入门越快的人，后面遇到的问题越多；入门越慢的人，后面遇到的问题越少。

内功篇涉及编程的部分，学习目标是：能够完全看懂AI写的代码。

能够完全看懂就可以，因为我们不需要亲自写代码。随着AI技术的发展，以后需要亲手写代码的场景会越来越少。

在辅导学员的过程中，我们发现，大部分学员遇到的卡点，都是由于无法看懂AI写的代码，从而难以和AI达成深度协作关系。

内功篇最高效的学习方式：借助 AI

整个「内功篇」的内容，是网站编程领域的基础知识， 你可以借助 AI 来完成学习，效率更高。

使用 AI 学习本课内容的技巧：

1. 使用 DeepSeek 官方网页版本，选择 DeepSeek V3 模型 （不打开深度思考、不打开联网搜索）
https://chat.deepseek.com/

2. 忘记“提示词工程”！把 AI 当成人，直接说你的述求就行。

在沟通中，你可以强调以下关键词，达到更好的沟通效果
[图片]

示例：

当你想要学习 TypeScript 时，可尝试这样的沟通方式
我挺笨的。我只有1小时。我想要借助 https://www.typescriptlang.org/ 学习和练习TypeScript，请不要让我在本机安装环境，因为我听说只靠这个工具就能做实验。请帮我设计课程和练习题。详细一点

当你想要学习 TailwindCSS 时，可尝试这样的沟通方式
我是一个高中的智商80的高中辍学笨蛋。请你借助 https://play.tailwindcss.com/ 工具，用15分钟教会我Tailwind

当你想要学习 NextJS 时，可尝试这样的沟通方式
我是文科生，差生，逻辑能力不行，数学也不行，英语也不行。
你帮我设计一个1小时左右的教程，让我弄明白NextJS的核心概念，使用Typescript、App Router、Shadcn。你的教程最好能够避免让我安装环境，我听说一些在线工具，可以让我直接上手。耐心点，对我要温柔。

打开 DeepSeek 试试看吧！

3. 可以让 DeepSeek 出选择题，你自测是否已经掌握
[图片]
4. 遇到不懂的内容，直接复制，反复问 AI。AI 比你有耐心。

[图片]

一、Cursor

1.1 Cursor 介绍

Cursor 是一款集成了先进 AI 技术的创新型代码编辑器，兼容并扩展了 VS Code 的强大功能。我们将带你完成 Cursor 的账号注册、安装与配置，并详细介绍其核心功能和实用技巧，帮助你高效入门并灵活使用这一强大的开发工具。

- 注册 Cursor 账号
访问 Cursor 官网：https://www.Cursor.com/cn

点击 "Sign in" 按钮，进行登录，可以选择从 Google 或者 Github 进行登录
[图片]
也可以选择 "Sign up" 按钮，进行注册，邮箱可以用国内邮箱，比如 QQ 邮箱，163 邮箱，126 邮箱等
[图片]
注册完成后，会自动登录到 Cursor 个人设置页面，该页面会显示您的账号信息和额度信息
[图片]

Cursor 收费计划
Cursor 提供三种不同的订阅计划，可以选择按月付费或按年付费（年付可节省 20%）：
[图片]

以上所有版本都可以访问 Cursor 的核心功能，个人开发者推荐使用 Pro 版本。
Cursor 付费目前支持支付宝付款，或者使用 Visa 信用卡

以上规则可能会随时变化，请以官网最新内容为准，参考 Pricing | Cursor - The AI Code Editor

- 安装指南
1. 访问 Cursor 官网：https://www.Cursor.com/cn
2. 点击 "Download" 按钮下载安装包，Cursor 会根据您的操作系统自动选择合适的安装包
[图片]
3. 运行下载的安装文件（Windows 是 。exe 文件，macOS 是 。dmg 文件）
4. 按照安装向导提示完成安装
在首次安装时，Cursor 会自动检测你的系统是否已安装 VS Code。

如果检测到，会提示你是否导入 VS Code 的配置。选择导入后，Cursor 会自动应用 VS Code 的主题、字体、缩进设置，并支持迁移部分插件等配置。
Cursor 是基于 VS Code 开源版本进行开发的，如果是从 VS Code 切换到 Cursor 可以很快的适应。

[图片]

1.2 界面讲解
Cursor 界面主要分为以下几个区域：
[图片]

1. 侧边栏：文件资源管理器、搜索、Git 控制等
2. 编辑区：编写代码的主要区域
3. 终端：在编辑器底部可以运行命令
4. AI 聊天面板：与 AI 交互的专用区域

作为编程小白，第一次打开代码编辑器可能会被各种面板和按钮吓到。别担心！下面我会用最通俗易懂的方式，带你彻底掌握 Cursor 的四大核心区域，让你像专业人士一样高效使用

1. 侧边栏：你的项目控制中心
📌 位置：编辑器最左侧的竖条区域（如果看不到，按 Ctrl+B / ⌘+B 显示）

（1） 文件资源管理器（Explorer）
[图片]
- 功能：就像电脑上的文件夹，这里展示你项目的所有文件
- 必学操作：
  - 点击📁图标展开/折叠文件夹
  - 右键文件 → 可进行新建/删除/重命名
  - 双击文件在编辑区打开
- 小白技巧：
  - 项目一定要有清晰结构（如：src/ 放代码，images/ 放图片）
  - 使用 New File 按钮创建文件时，要带上后缀（如 .JS 、.py ）

（2） 搜索（Search）
[图片]
- 功能：快速找到项目中的特定内容
- 实战案例：
  - 想修改"登录按钮"的代码但不知道在哪？
  - 点击🔍图标 → 输入"登录" → 立即找到所有相关文件
- 高级技巧：
  - 使用 * 通配符（如 *.css 只搜 CSS 文件）
  - Ctrl+Shift+F（Win）/ ⌘+Shift+F（Mac）全局搜索

（3） Git 版本控制
[图片]
- 功能：记录代码的每次改动（像游戏存档）
- 新手必会：
  - 看到文件旁的 M 表示已修改，U 表示新文件
  - 点击✔️图标 → 输入备注 → 提交更改
- 避坑指南：
  - 提交前一定检查"Changes"里改动了什么
  - 每天至少提交一次，避免代码丢失

2. 编辑区：你的代码画布
[图片]
- 行号：出错时会显示"第 X 行有错误"
- 语法高亮：不同颜色区分代码类型
- 代码折叠：点击 - 号可折叠函数/循环

小白必学操作
- 基础编辑：
  - 鼠标点击任意位置开始输入
  - Ctrl+/ （Win）/ ⌘+/ （Mac）快速注释代码
- 多光标编辑（神技！) : 
  1. 按住 Alt +鼠标点击（Win）/ ⌥ + 鼠标点击（Mac）
  2. 在多个位置同时输入相同内容
- 代码补全：
  - 输入时自动出现提示 → 按 Tab 键确认
  - 遇到不懂的 API，悬停鼠标看说明

3. 终端：你的命令行助手
📌 位置：编辑器底部面板（按 Ctrl+` / ⌘+` 快速开关）
[图片]

为什么要用终端？
- 运行程序（如 python app.py ）
- 安装依赖包（如 npm install axios ）
- 使用 Git 命令（如 git push ）

[图片]

1.3 基础设置
Cursor 设置界面（Settings）包含四个主要部分：

General（通用设置）：主要用于基础编辑器配置，在这里可以导入 VS Code 配置、管理账号登陆信息、快捷键设置等；
[图片]
Account（账号管理）
  - 显示当前登录的邮箱账号。
  - 提供管理账号和退出登录的选项。
VS Code Import（导入 VS Code 配置）
  - 支持从 VS Code 导入扩展、设置和快捷键，方便用户无缝迁移开发环境。
Appearance（外观设置）
  - 可以调整编辑器的外观，比如主题、字体等。
  - 提供入口快速打开编辑器设置和配置键盘快捷键。
Privacy Mode（隐私模式）
  - 允许用户开启隐私模式，确保所有代码都保持私有，提升数据安全性。
Any Questions?（有疑问？) 
  - 页面底部有提问入口，方便用户获取帮助或反馈问题。

Features（功能特性）：管理 Cursor 的核心功能，如代码补全和智能提示等
[图片]
Cursor Tab 
- Cursor Tab 是 自动补全代码工具，可以替代 Copilot，帮助你高效编写代码。
- 主要选项包括：
  - Partial accepts：允许你通过特定快捷键只接受建议的一部分内容。
  - Suggestions in Comments：在注释中也能获得智能补全建议。
  - Show whitespace only changes：只高亮显示空白字符的变动，便于代码审查。
  - Auto Import：自动导入所需模块（目前对 Python 支持为 Beta 测试）。
Chat（聊天相关设置） 
- Default chat mode：设置新建聊天窗口的默认模式（如 Agent 模式）。
- Auto-refresh chats：长时间未操作后自动新建聊天，保持对话流畅。
- Auto-scroll to bottom：聊天窗口自动滚动到最新消息，方便查看最新对话。

Models（模型设置）：负责 AI 相关的配置，包括模型选择和 API 密钥管理
[图片]
启用或禁用模型 
- 你会看到一系列可用的 AI 模型（如 claude-3.5-onnx、claude-3.7-sonnet、gpt-4.1、gemini-2.5-pro 等），每个模型旁边有一个勾选框。
- 通过勾选或取消勾选，可以灵活选择哪些模型在 Cursor 中可用，适应不同的开发和智能需求。
添加新模型 
- 页面底部有“添加新模型”选项，支持你接入更多第三方或自定义的 AI 模型，扩展编辑器的智能能力。
配置 OpenAI API Key 
- 在下方的“OpenAI API Key”区域，你可以输入自己的 OpenAI API 密钥。
- 这样可以直接调用 OpenAI 的模型（如 GPT-4），并按 OpenAI 的官方计费标准计费，适合有自有 API 额度的用户。

Rules（规则设置）：管理项目规则文件，之前是在 Features 功能特性中，0.46 版本后单独出来了
[图片]
User Rules（用户规则） 
- 填写你的个人偏好或工作习惯，这些信息会在你与 AI 聊天或使用智能功能时传递给 AI，帮助 AI 更贴合你的使用风格。
Project Rules（项目规则） 
- 你可以指定项目的开发规范、架构说明等，让 AI 理解你的代码库结构和团队约定。
- 支持关联项目文档（如 supastarter-architecture.mdc），让 AI 在回答问题或生成代码时参考这些规则。
- 有“Include 。Cursorrules file”选项，勾选后会将 。Cursorrules 文件内容包含在 AI 请求中，未勾选则不会包含。

Cursor 0.50以上版本，引入了新功能：可以自动生成项目级规则
请在Cursor聊天窗口里输入 /Generate Cursor Rules 
[图片]

MCP（模型上下文协议）：这个可能会让很多朋友感觉难以理解，后续会有一章节进行讲解
[图片]
- 查看和管理 MCP 服务器
显示已添加的 MCP 服务器（如 context7），每个服务器都可以单独启用或禁用。
- 工具集成
每个 MCP 服务器下会列出可用的工具（如 resolve-library-docs），这些工具可以为 AI Agent 提供额外的能力，比如自动解析库文档、增强代码理解等。
- 命令行接入
提供一键复制的命令（如 npx @pushai/context7-mcp@latest），方便你在本地或服务器上快速部署 MCP 服务。
- 添加新 MCP 服务器
通过 “+ Add new global MCP server” 按钮，可以接入更多第三方或自定义的 MCP 服务，进一步扩展 Cursor 的智能能力。

Beta（测试功能）：提供最新的实验性功能和测试特性
[图片]
- Update frequency（更新频率）
可以选择“Early Access（抢先体验）”，这样会第一时间收到最新功能更新，但这些功能可能不够稳定，不建议在生产环境中使用。
- Notepads
启用后，可以在聊天和代码编辑器之间灵活创建和共享上下文，方便整理思路和协作。
- Bug Finder
启用后，可以在当前 git 目录下运行自动化的 Bug 检查工具，帮助你快速发现代码中的潜在问题。相关功能可在 Activity Bar 的 Bug Finder 标签页中查看和操作。

刚开始使用时，大家可以先使用默认配置，在后续课程会根据实际的场景，分别介绍不同的配置

PS：隐私问题
Cursor 提供了隐私模式（Privacy Mode）来保护用户数据，默认是禁用状态，需要手动开启隐私保护。
[图片]

【新增】Cursor 上如何更改 GitHub 账号

首先来到cursor的setting，点击tools & integrations，选中github，后面的manage或者connect，进入到网页版cursor dashboard
[图片]

[图片]


- Cursor 已经绑定了 GitHub 账号 yaowubarbara
- 你点了【Manage】，进入的是 GitHub 的 OAuth 授权管理页
[图片]

保留刚刚的 GitHub 授权管理界面
滑到页面最下方「Danger zone」
点击：Suspend your installation
再确认选择：Uninstall completely
[图片]
[图片]

此时你已经解绑成功
[图片]
再次回到本地的Cursor，点击connect
[图片]
这里会自动出现之前解绑过的Github账号，我们只要Sign out，登录新的账号就可以了。
[图片]


[图片]

1.4 必要安装及配置

1. node 安装
后续我们会使用 Next.JS 框架开发，Next.JS 依赖 Node.JS 作为运行和构建环境，所以开发 Next.JS 项目必须先安装 Node.JS
访问 Node.JS 官网：https://nodeJS.org/en/download，下载安装包：
Windows 系统选择 .msi 安装包
macOS 系统选择 .pkg 安装包
Linux 系统选择 .tar.gz 包

[图片]
下载后，按照提示进行安装

验证安装：
打开 Cursor 终端，输入以下命令：
node -v
如果能看到版本号，说明安装成功
[图片]

2. git 安装
为实现代码的协作与版本管理，你需要安装 git，实现对不同代码版本的灵活管理
安装网址：https://git-scm.com/downloads
[图片]
验证安装，在终端输入以下命令
git --version
[图片]
初始配置，设置你的用户名称
# 配置用户名和邮箱
git config --global user.name "替换为你的名字"
git config --global user.email "替换为你的邮箱"

# 查看配置
git config --list

[图片]

1.5 AI 对话
- 对话模式
在 AI 聊天区域，存在 3 种模式：Agent、Ask、manual
Agent（最常用）

- 用途：自动化代码修改、批量重构、直接应用 AI 建议
- 特点：
  - 可以自动将生成的内容直接写入文件
  - 可以自动创建代码文件
  - 适合需要自动化处理、批量修改、快速实现功能的场景
  - 更高效，但更改会直接生效
- 典型场景：让 AI 自动修复 bug、重构代码、批量替换内容等

Ask

- 用途：提问、代码解释、搜索、理解项目内容
- 特点：
  - 只提供建议、解答或代码片段
  - 不会自动修改或写入文件
  - 适合日常问答、代码理解、查找用法等
- 典型场景：想让 AI 解释一段代码、帮忙写一小段代码、查找项目结构等

Manual

- 用途：手动审核和应用 AI 生成的内容
- 特点：
  - AI 生成建议后，不会自动写入文件
  - 你需要手动确认、编辑或应用这些更改
  - 适合需要人工把关、逐步采纳建议的场景
- 典型场景：对 AI 生成的代码进行人工审核、只采纳部分建议、需要逐步修改时
总结对比表 
[图片]

- 模型选择
2025 年 6 月模型情况
推荐首选模型：claude-4-sonnet
通用场景首选

最强代码生成模型：gemini-2.5-pro-exp-06-05
适合复杂逻辑任务

画图审美最稳定的模型：claude-4-sonnet
适合界面任务

最佳算法模型：o3
适合复杂算法任务
是否要选择单次按量付费模型
答：不必要，懂代码结构、文件作用后，描述任务即可

- 如何使用 AI 对话
方法 1  需求描述格式
优质的段落格式，会帮助 AI 更精准理解你的需求
### 任务目标
这里描述你本次对话后要实现的目标

### 任务背景
描述本次人物会涉及到的背景情况

### 可能用到的材料
这里@可能用到的知识文档/API

方法 2 一个对话窗口做一个任务
每个对话窗口只处理一个具体任务。
比如，这个窗口只用来写登录页，另一个窗口用来优化接口。
这样可以避免上下文混乱，任务拆分更清晰，后续查找和回溯也更方便。

方法 3 AI 生成内容回滚
reject：取消本次生成的代码，取消后生成的代码不应用到项目中
accept：接受本次生成的代码，接受后代码文件更改内容保存
[图片]
Restore checkpoint：把项目或代码恢复到该对话前的状态，点击后，当前的内容会被回滚到当时的样子
[图片]

[图片]

1.6 基本技巧
- 智能补全
在写文档、注释或说明时，Cursor 会根据你已输入的内容，自动预测并补全后续文本。
只需按下 Tab 键，即可快速接受建议，让写作更流畅。
光标位置后出现补全内容
[图片]
按住 tab 后，补全内容出现
[图片]

部分补全（Partial Accepts） 
支持逐词接受建议（如按 Ctrl/Cmd + →），可以灵活采纳补全内容的一部分，适合精细编辑。
智能光标预测 
Cursor 会预测你下一个可能编辑的位置，按 Tab 可以直接跳转到下一个编辑点，提升多处修改的效率。
使用技巧 
Tab 键：接受当前补全建议
Esc 键：关闭补全窗口
Ctrl/Cmd + →：逐词接受建议（需开启 Partial Accepts）

- @命令技巧
在 Cursor 编辑器中，@技巧指的是在 Chat 窗口输入 @ 符号后，快速引用文件、代码、文档、历史等内容，极大提升 AI 辅助开发的效率和精准度
[图片]
@Files 和 @Folder —— 引用文件和文件夹 
输入 @，选择 @Files 或 @Folder，可以把项目中的特定文件或文件夹作为上下文发给 AI。
支持直接拖拽文件/文件夹到 Chat 窗口，自动生成引用。
使用场景 ：让 Cursor 明确的修改某一个文件
[图片]

@Docs —— 访问文档 
输入 @Docs，可以引用项目内或自定义的第三方文档（如 Next.JS、React 官方文档）。

@Git —— 访问 Git 历史 
输入 @Git，可以引用项目的 Git 历史记录或某次提交。
使用场景：让 AI 分析历史变更、定位 bug 或生成变更说明。

@Cursor Rules —— 引用项目规则 
输入 @Cursor Rules，可以让 AI 按照项目自定义的规则和指南进行操作。
使用场景：适合团队协作、规范代码风格。


@Web —— 引用互联网资源 
输入 @Web，AI 会自动搜索互联网，获取最新的相关信息作为上下文。
使用场景：AI 联网，获取资料或外部知识。

- AI 总结提交内容
点击 AI 描述按钮后，Cursor 会根据修改内容，描述本次修改的内容

[图片]

- 规则配置
Cursor 支持两种规则设置方式：项目级规则（推荐）、全局规则，优先级依次递减，规则用于控制 AI 助手的行为，帮助其更好地理解和适应你的开发需求

在全局 rule 中配置 Cursor 的宽泛的整体规则；
在项目 rule 中配置精细化的具体规则；

项目级规则（推荐配置） 
优先级最高，适用于特定项目，每个项目间相互独立。
配置方法：在项目根目录下的 `。Cursor/rules` 文件夹中创建 `。mdc` 文件（基于 Markdown 格式）。
支持四种规则类型：
  - Always：自动附加到所有对话和命令请求，适合全局规则。
  - Auto Attached：根据文件类型自动触发（如 .  tsx、.JSon) 。
  - Agent Requested：针对特定任务场景，需提供任务描述，帮助 AI 更好地理解任务。
  - Manual：需手动提及才会生效，适合临时规则。
[图片]
 
全局规则 （必要配置） 
对所有项目生效，适合通用性要求（如统一语言、编码风格）。
配置方法：在 Cursor 设置中进入 “Rules” → “User Rules”，添加全局规则。
例如，可以设置所有响应都使用中文。

[图片]
自动执行指令
当你使用 Cursor 到一定程度，通常一个对话就会让 Cursor 工作 5 分钟以上，为了在这 5 分钟里解放你的双手，你可以让 Cursor 自动执行指令
1.进入 features
[图片]

2.勾选以下选项
[图片]
[图片]
注意：需要在【enable auto-run mode】-【command denylist】中添加 npm run dev，禁止 Cursor 运行这条指令，否则你将会有 3001、3002、3003 等 N 个开发端口
[图片]

- mcp 技巧
Cursor 中的 MCP（模型上下文协议，Model Context Protocol）是一种让 AI 助手能够安全地访问本地和远程数据、运行命令、使用工具的开放协议，极大扩展了 AI 在编程环境中的能力

MCP 就像 AI 的“万能接口”，让 AI 助手能安全、灵活地访问和操作你的开发环境资源，极大提升了自动化和智能化水平。如果你想让 AI 更懂你的项目、帮你做更多事，MCP 是核心工具之一
MCP 在 Cursor 里的作用 
MCP 让 Cursor 里的 AI 助手不仅能“看懂”你的代码，还能直接操作你的电脑和网络资源，比如：
- 读写本地文件
- 搜索网络信息
- 运行命令行指令
- 使用数据库
- 调用各种开发工具
这让 AI 助手变得像“超级助手”，能帮你自动化很多开发任务。

MCP 的基本结构框图 
[图片]

- MCP 主机：比如 Cursor，负责发起请求。
- MCP 客户端：负责和 MCP 服务器通信。
- MCP 服务器：实现具体功能，比如文件操作、命令执行等。
- 本地数据源/远程服务：MCP 服务器可以访问的资源，比如本地文件、数据库，或外部 API。

MCP 的配置方式 
Cursor 设置-MCP
[图片]

配置示例（JSON）：
{
    "mcpServers": {
        "context7": {
            "command": "npx",
            "args": ["-y", "@upstash/context7-mcp@latest"]
        }
    }
}

[图片]
1.7 新手插件推荐
1. Chinese (Simplified) Language Pack
- 简介：官方中文语言包，将 Cursor 界面汉化，降低英语门槛。
- 链接：VS Code 市场

2. Material Icon Theme
- 简介：美化文件图标，让项目结构更直观。
- 链接：VS Code 市场

3. Prettier - Code Formatter
- 简介：一键格式化代码，保持代码风格统一，避免缩进混乱等问题。
- 链接：VS Code 市场

4. Live Server
- 简介：实时预览 HTML/CSS/JS 文件，保存后自动刷新浏览器，适合前端初学者。
- 链接：VS Code 市场

5. Bracket Pair Colorizer
- 简介：为匹配的括号着色，帮助小白快速识别代码块范围。
- 链接：VS Code 市场

6. Code Spell Checker
- 简介：检查变量名拼写错误，支持驼峰命名，避免低级错误。
- 链接：VS Code 市场

7. Path Intellisense
- 简介：自动补全文件路径，减少手动输入错误。
- 链接：VS Code 市场



[图片]

1.8 快捷键大全

以下是 Cursor 编辑器 的快捷键大全，分别针对 Mac 和 Windows 用户整理，方便编程小白快速上手：
[图片]
[图片]

1.9 使用技巧

- 技巧 1 新项目建空文件夹
为什么重要？
- 避免文件散乱，保持项目结构清晰
- 方便 Git 版本控制管理

操作步骤
1、在本地创建一个空文件夹（如 my_project）
2、在 Cursor 中点击 File → Open Folder 选择该文件夹
3、后续所有代码、配置文件都放在这里


- 技巧 2 AI 生成代码一步步来
为什么重要？
- 避免一次性生成复杂代码导致难以理解
- 便于调试和迭代优化

操作步骤
1、先让 AI 生成核心功能（例如："用 Python 写一个计算器函数"）
2、逐步扩展需求（例如："添加异常处理" → "支持更多运算符"）
3、通过 Ctrl+K（Win）或 ⌘+K（Mac）分段生成

- 技巧 3 善用 readme 文档
为什么重要？
- 记录项目目标、依赖和运行方式
- 方便他人（或未来的你）快速上手
- 方便 AI 了解项目进程

操作步骤
1、直接让 AI 生成

- 技巧 4 让 AI 写清楚代码块注释
为什么重要？
- 提高代码可读性，方便后续维护
- 帮助理解 AI 生成的复杂逻辑

操作步骤
1、生成代码后，选中代码块
2、输入指令：
  - "为这段代码添加详细注释"
  - "用中文解释每一行的作用"

- 技巧 5 适时的 git 提交
为什么重要？
- 避免代码丢失，保留历史版本
- 适合新手练习版本控制

操作步骤
1、关键节点提交代码

- 技巧 6 新建 AI 聊天窗口
为什么重要？
- 分离不同问题的讨论上下文
- 避免 AI 混淆多个任务

操作步骤
1、点击左侧边栏的 Chat 图标
2、选择 New Chat 创建独立会话
3、命名会话（例如："前端问题"、"数据库优化"）
[图片]

- 技巧 7 AI 生成内容回退
为什么重要？
- AI 可能生成错误或不理想的代码
- 快速恢复到之前的版本

操作方式
- 快捷键撤销：Ctrl+Z（Win） / ⌘+Z（Mac）
- 选中历史对话节点，点击回退
- 如果已保存，通过 Git 回退（ git checkout -- file.JS ）

- 技巧 8 善用@功能
为什么重要
- 模型能力不稳定无法正确调用工具

操作方式
- 在 AI 对话框中使用@功能
[图片]

- 技巧 9 添加查用文档 docs
为什么重要？
- 集中存放 API 文档、技术规范
- 方便 AI 参考后生成更准确的代码

操作建议
- 在@- docs 中添加文档
- 在使用环节中@相关文档
[图片]
怎样让 Cursor 更听话？

1. 在 Cursor 里设置 context7 的 MCP

context 7 的作用是让 Cursor 永远可以查询到最新的开源框架的开发文档。
[图片]

方法：在 Cursor 的「设置」界面，点击 Add new global MCP server， 改成以下内容
{
  "mcpServers": {
    "context7": {
      "command": "npx",
      "args": ["-y", "@upstash/context7-mcp@latest"]
    }
  }
}


2. 每次任务描述时，按照以下结构化格式 （可以不严格按照格式，但是要完整表达对应的意思）
### 任务目标
1.xxx
2.xxx

### 任务背景
1.xxx
2.xxx
3.xxx 

### 可能用到的资源
（这里可以@一些可能会用到的代码文件，以及截图标注、以及开发文档）

以下是一个例子，我们让 Cursor 帮忙做「支付成功后，跳转到特定页面」的功能。通过这样的模板，一次通过。
[图片]
[图片]

【新增】技巧 10：上下文工程系统教程
（大铭线下cursor操作指导的整理）

AI想要精准干活，必须拥有足够的上下文。
人的核心职责：组织、补充、管理和维护上下文。
AI的职责：基于完整上下文与明确要求，高效、准确地执行任务。
人的工作重心：成为合格的AI上下文工程师。

1.实操闭环流程 
1.1 组织与管理上下文 
- 明确背景·目标·技术选型·依赖版本
- 收集资料：参考代码、外部文档、已知问题
- 本地管理：集中存储上下文文件，确保完整可控
1.2 驱动 AI 执行与验证 
- 精确指令 → 让 AI 基于完整上下文产生输出
- 严格校验 → 检查是否满足技术 & 业务需求
- 反馈闭环
  - ✔️ 合格：任务完成
  - ❌ 不合格：
    - 人工补充或修正上下文
    - 引导 AI 扩展/完善
  - 重复循环 → 高效可靠的开发闭环

---
2. 上下文规划体系 

2.1 敏捷工程思维（Agile Inspired Engineering）
- 小步快跑：拒绝一次性大需求
- 用户故事驱动：不写冗长 PRD

2.2 五层结构 
暂时无法在飞书文档外展示此内容

---

3.执行阶段：RR 模式 & 技术讨论 

3.1 RR 模式（Research & Review） 
- 调研 → 方案讨论，先不编码
- 样例/伪代码 → 形成上下文文档

3.2 技术讨论 
- 技术选型 & 架构
- 关键实现路径 & 细节
- ⏩ 锁定技术方案 → 固化为上下文

---
- Plan 文件 
暂时无法在飞书文档外展示此内容

---
- AI 辅助开发的风险 & 应对 
暂时无法在飞书文档外展示此内容

---
- 开发者成长路径 
暂时无法在飞书文档外展示此内容

---
4.总结 
人 + AI = 1 + 1 > 2
通过系统化上下文管理与敏捷闭环，
稳步成长为 Context‑Driven Engineer！
1.10 超越Cursor的工具

Cursor 仍然乱改我代码，还有其他方法吗？


AugmentCode

还可以试试 AugmentCode。

AugmentCode 做了很重的 Agent，结合了 Claude 和 O1 的优势，在编程比赛中击败了 Cursor。
咱们生财圈友里有几位同学，饱受 Cursor 的摧残，改用 AugmentCode 后，抑郁症都好了。
官网：https://www.augmentcode.com/

平时我是 AugmentCode 和 Cursor 两个工具结合起来用的。比较宏观的功能用 AugmentCode 做，微调用 Cursor 进行。也建议你多试试，找到适合自己的方式

tips：记得也给配置是 Context7 的 MCP。

以下是我的使用界面

[图片]

以下是我的配置界面
[图片]

Claude Code（强烈推荐）


非常非常非常好非常好。

Claude Code 是 Anthropic 推出的终端 AI 编程助手。它最大的优势在于可一次性理解和操作整个代码库，而不是像 Cursor 那样受限于单次 200 行的 token 限制。

这意味着 Claude Code 能够跨文件、跨模块地理解你的项目结构、依赖关系和业务逻辑，并支持复杂的批量修改、重构、自动 PR、测试等一站式开发流程。

推荐：同时订阅$20/月的Cursor +  $20/月的Claude Pro，  把Cursor和Claude Code结合起来用
Claude Code 安装与使用教程（图文详解）

也请参考官方文档：https://www.anthropic.com/claude-code

1. 安装 Claude Code

前提条件：
- 已安装 Node.js 18+ 和 npm
- 已注册 Anthropic 账号，推荐新手购买$20/月的Claude Pro Plan套餐，先体验起来。

命令行安装：npm install -g @anthropic-ai/claude-code
[图片]

输入 claude code ，运行：claude code 
选择颜色模式
[图片]
选择调用方式
[图片]

选择使用模式后，你就可以在终端进行对话，让 claude code 来帮你修改代码了。

使用方式和Cursor类似，表达清楚你的意图，使用自然语言就可以。只不过，它比Cursor要聪明多了，也超过Cursor Max Mode

使用方式：在命令行中输入命令  claude

[图片]
[图片]

一次“轻轻的”问询，也需要消耗47.2k token。正常使用的情况下，每天消耗超过2M token是很正常的事情。因此推荐使用包月套餐，而不建议使用API Token based的计费方式。

在实际体验中，claude code更像一个任劳任怨的实习生，只要你需求描述得足够清楚，它总是可以使命必达。

它遇到自己不懂的问题，会自己想办法去搜索、查找文档；还可以自己帮我测试，确保交付给我的时候，已经是完成状态。

下图我是用于接入Creem支付API，一把梭，直接搞定。
[图片]
[图片]
[图片]
[图片]


最佳实践：只订阅$20/月的Claude Pro Plan即可。和Cursor配合用。简单的任务用Cursor，复杂的任务用Claude Code

因为$20/月的Claude Code使用频率限制比较大，每5小时只能问10～20次。
[图片]


我是如何使用Claude Code的？

使用Claude Code有一段时间了，越用越香。我现在的主力编程工具组合是Cursor + Claude Code。 同时，我也推荐AugmentCode + Claude Code的组合形式。 针对评论区经常出现的「TRAE国内版是免费的」、「腾讯云代码助手是免费的」这类言论，我统一回复如下：免费的才是最贵的。
现在跟大家分享一些小经验。
⚡️ 我是如何使用Claude Code的？ 
- 使用Cursor或者VS Code作为IDE，安装官方插件，保证Claude Code可以和IDE协同。

- 打开Bypassing Permissions模式，提前授予Claude Code一切所需权限，完全解放双手。 (注：打开之后，Claude Code 中途再也不会停下来询问你授权了）

- 同时打开3个Claude Code。

- 复杂任务，使用ultrathink， 杜绝AI偷懒的可能性。 (注：这是Claude Code内部的魔法口令，可以让它不考虑预算、尽情思考。）

- 需要让Claude Code看图时，使用Ctrl+V (而不是command+V) 可以贴图。

- contenxt7和browsermcp两大MCP，可以加快网站类产品的开发效率

- 使用/resume可以查看历史聊天，或者接着聊。

- 再打开LIVE TOKEN USAGE MONITOR， 实时查看Claude Code省了多少钱……  (注：我买的是$200/月的Max Plan包月套餐，有时候看到当日消耗就超过$200，感觉还挺爽的！！哈哈哈，别嘲笑我，我有小农意识！）

我的工作环境，请看下面截图
[图片]
如果你也这样操作，你会感觉自己无所不能。
下面我们展开讲每个细节。
⚡️ Claude Code如何与IDE协同？ 无论是在Cursor里，还是在VS Code里，都可以安装Anthropic官方的插件，如下图所示，图1来自VS Code，图2来自Cursor到VS Code/Cursor的应用商店里安装即可。
[图片]
[图片]

安装之后，你的Cursor右上角会出现Claude Code的图标

点击图标，会在Cursor文件编辑区打开Claude Code，并且显示一个绿色的状态 IDE connected
[图片]

在 IDE connected 状态下，如果Claude Code修改了文件，它会使用IDE的其他功能（如：修改预览，如下图所示 ）
[图片]


⚡️ 如何同时打开3个Claude Code？ 
为什么要同时打开多个？因为你的任务可能很长，一个任务就会执行好几分钟甚至半小时。我们如果引入多开，就能同时执行好几个任务了。
上文提到的按钮，连续点3下，就能打开3个……
[图片]

请注意： 虽然可以同时打开多个，但只有你最后打开的那一个，可以和IDE保持协同。保持和IDE协同的那一个，会出现绿色的小圈和IDE connected一般来说，我会让保持和IDE协同的那个，做我不太确认的任务，这样中途我可以参与review代码。
⚠️大坑预警强烈反对新手用多开！多开对人的要求很高。老鸟可以知道哪些任务互相不影响，可以多个任务一起干；新人并不一定知道。如果让多个Claude Code干活的时候，同时修改了某些同样的文件，会造成比较大的困扰。建议新人老老实实先用单开。如果新人一定要多开，那我建议你多开同时做多个项目而不是同一个项目。

⚡️ 如何使用Bypassing Permissions提前授予Claude Code所有权限？ 
你是否有这个困扰： Claude Code总是干活干一半，停下来让你授权？
如果有，那赶快用这招。
[图片]
启动Claude Code的时候，使用
```Plain Text
claude --dangerously-skip-permissions```

而不是
```Plain Text
claude```

就会自动打开Bypassing Permissions模式， 此时，Claude Code的右下角会出现黄色的字。


考虑到每次都输入  claude --dangerously-skip-permissions 太麻烦了，

我们可以建一个alias，

让我们只输入claude，可等同于输入claude --dangerously-skip-permissions的效果。

不会建alias？


没关系，就让Claude Code 帮你即可。

```Plain Text
│ > 我想要在终端输入claude 等同于输入 claude --dangerously-skip-permissions   ,你帮我设置好  ```

[图片]

一次就设置完成了。请看下面截图。

[图片]


⚡️ 如何查看自己用Claude Code省了多少钱？ 
作为一个有小农意识的用户，看到Claude Code 可以帮我省那么多钱，感觉是很爽的。

比如，仅6月27日单日我就花了(省了)$187.61美元。我的包月套餐才$200美元啊！约等于1天回本……
我们只安装ccusage库即可

```Plain Text
npm install -g ccusage```


然后，在Terminal里输入命令。

输入ccusage命令，可以看到全部记录

输入ccusage -s 20250625命令，可以看到自从6月25日以来的消耗

[图片]

输入ccusage blocks --live命令，可以看到实时记录！
一边看牛马干活，一边看API Token的实时消耗，很燃！

⚡️ 如何让Claude Code更努力地干活？

此处有一个小秘密： ultrathink 是一个魔法词！

官方文档告诉我们，一共有这些词："think" < "think hard" < "think harder" < "ultrathink" 可以加速Claude Code 思考。

如果我们用的是$200/月的Max Plan满中满包月套餐，
我们无脑用 ultrathink 就行。 

养成习惯，稍微复杂一点的任务，
都在结尾加上ultrathink，

即可让Claude Code更努力的思考、不受任何预算限制、更尽情地消耗Token。

满足一下恶趣味，如果我让它ultrathink 1+1等于几，会怎么样？
```Plain Text
1+1 等于几？ultrahink```
[图片]

竟然花了价值$0.34的Token来回答，果然是不偷懒啊！

当熟练应用ultrathink后，使用Claude Code的体验好多了，还经常出现一条对话就消耗$30美元的情况！！

从此，我的Claude Code的字典里，再也没有“偷懒”这个词！

[图片]

⚡️ 最重要的两个MCP
context7是必装的MCP，因为它可以补齐「大模型的知识库有cut off截止时间」这个问题，总是引入最新的代码库知识。

如果你要装第二个，我推荐装browsermcp，它可以让你的Claude Code/Cursor 直接打开你的浏览器去查看内容！。

[图片]


我们浅浅玩一下
```Plain Text
打开浏览器,打开小红书,搜索“背单词”,查看最前面10个内容,用漂亮的形式总结给我   ```

不一会儿就出来了。


当然，我们真实使用的时候，并不一定会让它去自动化操作小红书（我知道你想干什么，你偷偷想就行了，别说了 ٩(•̤̀ᵕ•̤́๑)ᵒᵏᵎᵎᵎᵎ ），而是让它能够看到我们的网站产品运行起来的样子，找到差异，从而更有效率地写界面类型和交互类型的代码逻辑。


⚡️ 如何查看历史聊天记录？ 

在Claude Code里使用
```Plain Text
 /resume ```

[图片]


可以看到所有聊天记录。

还可以选择一个（输入数字、或者回车），继续聊天

[图片]

⚡️ Claude Code 和 Cursor的区别是？ 


Cursor和Claude Code设计理念完全不同。

Cursor的设计理念是你的编程搭子，需要你频繁协作，互相启发。

Claude Code设计理念是你的编程实习生。

因为这个不同，我并不推荐技术小白直接使用Claude Code。因为如果你不掌握基本的编程能力，无法说清楚的你需求，那么Claude Code做出来的东西会和你想的很不一样。

我推荐新人先从Cursor/AugmentCode开始学习，熟练编程基本功后，再逐渐引入Claude Code。

RPA 的末日：Claude Code 只需说出需求就能完成一切！

所有的RPA可以去死了！！只需要Claude Code，就能完成一切基于网页的自动化！不需要任何技能和门槛，只需要口喷！下面演示，只需一句话，Claude Code自动完成画图、编辑文案、发布小红书的全流程！一镜到底！全程零干预！
视频请看：https://mp.weixin.qq.com/s/Ad70QxBtCfLoyZFer0At5Q
暂时无法在飞书文档外展示此内容


对于草根的创业者们来说，至少可以包含这些..
1. 全自动内容发布系统
- 自动查找对标账号
- 自动根据对标账号发的新内容，编辑我们的内容
- 自动阅读新闻事件
- 自动生成内容并发布到多个平台（小红书、知乎、Twitter、微信公众号等）
- 自动适配每个平台的内容风格和格式要求
- 自动追踪发布效果并生成报告

2. 竞品监控与数据分析助手
-  自动爬取竞品网站的产品更新、价格变化、新功能发布
-  AI分析竞品策略并生成洞察报告
-  实时监控并发送通知提醒

3. 自动化测试
- 让Claude Code自己编写基于浏览器、可视化的、E2E测试用例
- 让Claude Code自动化测试自己写的代码，自己PUA自己，然后自己改进

4. 自动回复微信
- 授予Claude Code访问微信网页版的权限
- 让Claude Code对于消息进行分类，先自动回复低优先级且确定性高的内容。
- 回复可以基于模板
- 特别适合微商，因为微商们回复的大部分内容都在100个话术模板之内，回复之前可以让Claude Code根据每个客户的情况稍微修改。

5. 自动处理飞书上的工作
- 比微信网页版更加方便！飞书的网页版功能强大、稳定。
- 因此，Claude Code还可以在网页版飞书上，自动回复信息、处理文档、Push同事、处理多维表格等等……

6. 自动逛社区
- twitter? reddit? discord? 
- 太多有趣的社区了。具体怎么一个自动逛法，不便多说，请你发挥你的想象力。

……

💡怎么做到的？

一共只要4步
1. 订阅 Claude Code （我使用的是Max Plan, $200/月）
2.使用 Bypassing Permissions 打开Claude Code 注：如果你还不会，详见上一篇文章刘小排是如何使用Claude Code的？
3. 为Claude Code安装Playwright MCP
4. 开始口喷


💡下面我们看一些细节


Claude Code 完成任务后的截图
[图片]

如何在Claude Code里安装Playwright MCP?我是一个懒人。所以，我也不知道怎么安装。我是让Claude Code帮我自动安装的。
把原话告诉Claude Code即可
 帮我在我的Claude Code里安装一个叫Playwright MCP的东西，请先上网搜索如何安装
[图片]
执行完成后，可以在Claude Code里敲入 /mcp 命令，查看是否已经安装成功。如果有playwright和绿色的小勾勾，说明已经安装成功。
[图片]

布置任务时候的小技巧1. 如果需要打开多个不同的网页服务并且让它们协作，可以告诉Claude Code，使用新的tab打开新页面。
[图片]

如果需要账号，请你提前登录好。在本视频演示中，豆包和小红书，我都是提前登录好了。


【新增】如何使用K2驱动的Claude Code？

1.正常安装原版的Claude Code Cli客户端。
```Plain Text
npm install -g @anthropic-ai/claude-code```
如果已经安装过，请跳过。

2.如果你已经安装过、登录过正版的Claude Code，请在Claude Code里输入命令 /logout 退出登录。如果不退出登录，后面的流程走不通。

3. 访问Kimi平台，通过手机号注册账号。获取API Key。https://platform.moonshot.cn/console/account 

4.执行脚本
bash -c "$(curl -fsSL https://raw.githubusercontent.com/LLM-Red-Team/kimi-cc/refs/heads/main/install.sh)"

执行后，它会提示你，输入Kimi K2的API Key。粘贴后回车即可。你的Key不会在界面中被显示出来。
[图片]

5.关闭并重新启动Terminal。

6.在新打开的Terminal里输入claude，开始使用。如果出现的是下面的界面，说明已经成功了。
[图片]

7.随便问点啥，到Kimi后台看看是否有API消耗。
我问它是不是Kimi，它坚持认为自己是Claude-Opus-4，哈哈。
不过我们在Kimi后台可以确认，它肯定是Kimi K2，因为已经可以在计费明细里看到了
https://platform.moonshot.cn/console/fee-detail
[图片]
【新增】Gemini cli
Gemini cli的使用方法，与Claude code大相径庭，

同时由于gemini 2.5 pro模型的超长上下文能力，会让gemini cli在运行中，单次任务能结出更多信息，做更多的事
Gemini Cli的安装
  打开一个项目的Cursor终端： 输入指令    npm install -g @google/gemini-cli
[图片]
  
  接下来我们选择Google登录。
[图片]
  
  根据以上步骤我登陆成功，但是如果是第一次使用，需要要在新建google项目+为项目创建api权限+把项目id写到配置文件中，参考这个文档：
  
  https://github.com/google-gemini/gemini-cli/blob/main/docs/cli/authentication.md
  
  身份验证设置
  
  参考文档中的【新增】3.5.5 Supabase 配置 google 账号登录
  点击创建
[图片]
  选中刚刚创建的：
[图片]
  复制项目ID
[图片]
  打开api服务
打开api与服务界面
[图片]

搜索 Gemini for Google Cloud API
[图片]

  
启用该api服务
[图片]
点击凭据
[图片]
点击创建
[图片]
点击开始
[图片]
填写项目信息
[图片]
选择外部
[图片]
选择第二项
[图片]
选择web
[图片]
点击创建
[图片]
复制id
[图片]
  
  
  - 可以使用以下命令在当前 shell 会话中临时设置环境变量：
  - export GOOGLE_CLOUD_PROJECT=positive-karma-465404-e2
[图片]
  根据具体是mac还是window做调整：windows跑下面的命令可以跑通。
  
[图片]
  
  补充：如果遇到网络问题，Google登录会一直停留在Signing in的状态。这是因为Gemini CLi不会自动识别代理设置，
[图片]
  你需要自己根据梯子里面的端口配置一下，以下是我输入给终端的环境变量。
  
   $env:HTTP_PROXY="http://127.0.0.1:10808"
   $env:HTTPS_PROXY="http://127.0.0.1:10808"
  
  详解Gemini 登录的433错误， Gemini CLI老是连接不上，换什么节点都不行，
  
  Gemini不会读取我们的代理设置（魔法），而是会直接连接谷歌服务系统，从而导致连接超时失败，解决方法是为前端会话设置 http_proxy环境变量，这样就可以通过代理访问网络。
  
  Set https_proxy= http://127.0.0.1:xxx // xxx 选择你自己代理软件的端口，在魔法工具里查看。每次再次打开终端使用Cli的时候都要重新设置端口。
  
  如果你希望下次使用终端不需要再填写环境变量，就让cursor把Export https_proxy= http://127.0.0.1:xxx 加到 .env文件里。
  
  你设置了 http_proxy 环境变量，但 某些请求不是 HTTP 协议，而是 DNS、TLS 或 WebSocket。这些无法仅靠 http_proxy 代理，必须依靠系统层或 TUN 模式才能转发。
  
  💡 http_proxy 是什么？
  它只是告诉程序：
“如果你发的是 HTTP/HTTPS 请求，就请走这个地址（127.0.0.1:7890）代理出去。”
  它并不能强制拦截所有类型的流量。
  
  
  具体怎么找到你的端口，以V2rayGN为例：
  点击 “设置”：
[图片]
  再点击“参数设置”：
[图片]
  如下图所示10808就是我的端口：
[图片]
  我只需要在Cursor终端退出一下，把一下环境变量加上，即可。然后再输入gemini即可进去Gemini Cli的终端控制。
  
   $env:HTTP_PROXY="http://127.0.0.1:10808"
   $env:HTTPS_PROXY="http://127.0.0.1:10808"
[图片]
  并且打开TUN模式。
  
  ✅ 什么是 TUN 模式？
  - TUN（"network TUNnel"）是一种虚拟网卡驱动
  - 它让你的代理软件（如 Clash、V2rayN）“接管系统的所有网络请求”
  - 无论什么程序（浏览器、终端、CLI工具、游戏、Gemini CLI）发出的请求，都可以被代理抓到
  
  TUN 模式的基本功能是：
  - 将计算机的流量加密后通过隧道传输。
  - 允许你通过 VPN 隧道访问一个受限制的网络或隐藏你的真实 IP。
  
暂时无法在飞书文档外展示此内容
  
  
  我们来探索一下Cli的强大功能。
  
  1. 搜索并写成文档：
[图片]
  以下就是生成的报告
[图片]
  2. 查找并解读本地文档。
  
[图片]
  
  3. 视频图片的分析和处理功能
  
  下边的文件夹里有视频也有图片，也有logo，让他分析图片内容之后根据图片内容给图片重新命名，在训练图像模型或者 Lora 的时候需要对图像进行标注，大部分训练工具都是把标注放在一个跟图片命名一样的文本文件里，现在我们就可以让 Gemini CLI 来做这件事了。
[图片]
[图片]
  
  注意文件路径里面不要有中文或者特殊字符。
  4.  生成幻灯片
  
  
  这个依赖一个叫 Slidev 的项目，它可以用类似 Markdown 文档的格式将内容变成带有丰富样式的 PPT。
  你不需要知道这个项目的细节，直接用我下面的提示词生成文件之后，复制文件到这个页面（https://stackblitz.com/github/slidevjs/new?file=slides.md）预览就行。我们使用的是上面步骤生成的AI 发展报告。
  
  提示词是：把 AI_developement.md文件，用 Slidev 这个专门用来用 Markdown 格式生成幻灯片的工具语法写一个对应的 PPT，用 Slidev 的语法美化一下
  
[图片]
  
  
  
  
  5. 打开网页 &检测本地的文件
  
[图片]
  
  
  




[图片]

1.11 常见疑问

Q1：如何更改主题颜色？
A1：Ctrl+, 打开设置，搜索 "Color Theme" 进行更改

Q2：AI 功能需要付费吗？
A2：基础 AI 功能免费，高级功能、次数需要订阅

Q3：如何安装扩展？
A3：Cursor 目前不支持像 VS Code 那样的扩展系统，但内置了大多数常用功能

Q4：代码自动保存吗？
A4：默认不自动保存，建议养成 Ctrl+S 的习惯

Q5：提交代码时，网页端 GitHub 的验证码如何获取
A5：在 Cursor 弹出的提示中出现

[图片]

二、Terminal（终端）
终端是程序员最重要的工具之一，让我们系统地学习这个强大的界面。

Mac 打开方式
[图片]

windows 打开方式
快捷键：Win + R，输入 cmd 或 powershell，回车。  
搜索：按 Win + S，输入“cmd”或“终端”，选择打开。  
右键菜单：在文件夹中按住 Shift + 右键，选“在此处打开终端”。  

终端界面
[图片]

2.1 概念介绍
[图片]

基本指令
- 基本命令结构
命令 [选项] [参数]

- 选项：通常以 - 或 -- 开头，修改命令行为
- 参数：命令操作的对象

- 文件系统导航
pwd       # 显示当前目录(Print Working Directory)
ls        # 列出目录内容(List)
cd [目录]  # 切换目录(Change Directory)
mkdir     # 创建目录(Make Directory)
rmdir     # 删除空目录(Remove Directory)

- 文件操作
touch 文件名    # 创建空文件
cat 文件名      # 查看文件内容
cp 源 目标      # 复制文件(Copy)
mv 源 目标      # 移动/重命名文件(Move)
rm 文件名       # 删除文件(Remove)

- 实用命令
grep '模式' 文件  # 文本搜索
find 目录 -name "模式" # 文件查找
ps             # 显示进程(Process Status)
top            # 动态显示进程(类似任务管理器)
chmod          # 修改文件权限(Change Mode)

- 快捷键
  - Ctrl+C：终止当前命令
  - Ctrl+D：结束输入/退出会话
  - Ctrl+Z：暂停当前进程
  - Ctrl+R：反向搜索命令历史
  - Tab：自动补全
[图片]

2.2 实战项目

2.2.1 入门项目
1. 创建一个名为 basic_practice 的目录。
mkdir basic_practice

2. 查看当前文件结构
ls
发现文件已成功新增
[图片]
3. 进入 basic_practice 目录。
cd basic_practice

4. 查看当前文件结构
ls
当前文件为空
[图片]
5. 在 basic_practice 目录下创建一个子目录 sub_folder。
mkdir sub_folder

6. 查看当前文件结构
ls
新增的文件出现
[图片]
7. 回到上一级目录。
cd ..

8. 删除 basic_practice 目录及其子目录。
rm -r basic_practice

9. 查看当前文件结构
ls
文件已删除
[图片]

2.2.2 常见疑问
Q1：这些奇怪的符号是什么意思？
A1：
- #!/bin/bash：告诉系统这是 bash 脚本
- $HOME：你的用户主目录路径
- $(date +%Y%m%d)：获取当前日期，格式如 20230815
- $?：上一条命令是否成功（0 表示成功）

Q2：如何知道哪些命令可用？
A2：试试这些基础命令：
ls      # 查看文件夹内容
cd      # 切换目录
mkdir   # 创建文件夹
cp      # 复制文件
man 命令 # 查看命令帮助，如man ls

[图片]

三、HTML
作为完全的新手，我会用最简单的方式教你 HTML，就像我们之前学习终端一样，通过实际操作来学习。

3.1 概念介绍
[图片]

2. 基本结构
每个 HTML 文档都有这样的基本结构：
＜!DOCTYPE HTML＞
＜HTML＞
    ＜head＞
        ＜title＞我的第一个网页＜/title＞
    ＜/head＞
    ＜body＞
        ＜!-- 这里放网页内容 --＞
    ＜/body＞
＜/HTML＞

HTML 根据内容性质，将被分为两个部分，即＜head＞＜/head＞ 和 ＜body＞＜/body＞标签
1. ＜head＞＜/head＞：头部的内容不会显示在网页当中，主要是存放一些后台资料，像是文件的字符编码、关键字和程式脚本等
2. ＜body＞＜/body＞：身体的内容则显示在网页当中，即用户所看到的内容，包含网页文字、图片、按钮等

3. 常用标签

元素类型
标签
用法
示例
区块元素
Heading 
标题
共分为 6 个层级＜h1＞—＜h6＞
＜h1＞等级最高，通常用于网页的主题。其他层级等级依次顺延
[图片]
区块元素
＜p＞
正文
每一对＜p＞＜/p＞都代表一个独立的段落

[图片]
行内元素
＜strong＞
粗体
用法示例：＜p＞＜strong＞这里是需要加粗的文字哦＜/strong＞＜/p＞
[图片]
行内元素
＜em＞
斜体
用法示例：＜p＞＜em＞这里是变成斜体的文字哦＜/em＞＜/p＞
[图片]
行内元素
＜a＞
建立网页链接
使用时，加上 href 的属性，指定目标的网址或当前目录中的某个网页
（由于目前还没有建立其他的页面，所以这里暂时先输入一个#字号
＜a href="#"＞＜/a＞
或在这里随意增加一个网址，如我们当前的 codepen 页面。如图，就会出现“套娃”的情景：
＜a href="https://codepen.io/pianmaa/pen/LEYQYOr?editors=1010"＞＜/a＞
[图片]
[图片]

区块元素
清单
开头：
  ＜ol＞有序
  ＜ul＞无序
内容：
  ＜li＞
＜ol＞开头：（有序）/＜ul＞（无序）
＜li＞内容：每一组＜li＞在浏览器都会显示为清单中的一个项目
清单——常用做网站的导览列（做导览列的每个项目都会链接不同的网页，可以组合＜a＞使用）：
[图片]

区块元素
＜blockquote＞标注/引用
使用时，加上cite的属性，用来标示引用的来源网址
＜blockquote cite="https://codepen.io/pen"＞"引用一下" ＜/blockquote＞ 
[图片]

行内元素
＜br＞换行
是一个空元素，用于在 HTML 中插入换行。

[图片]

区块元素
＜img＞插入图片
＜img src="images/path.png" alt="一张图片"＞
1. src 标注图片的网址或路径 src="images/path.png"，
2. alt 以一段文字描述这张图片，该段文字在图片无法正常显示时出现
[图片]


4.构建内容展示结构的标签
[图片]
  ＜div＞:一个辅助标签，可用于划分或组织 HTML 的元素，例如：可以将原本的两个区块合并为一个，＜h2＞和＜p＞
[图片]
  ＜header＞：包含网站 LOGO 等页首的内容
  ＜nav＞：放置网站的导览列或菜单
  ＜main＞：包含网页的主要内容
  ＜section＞：组织页面内容，使其更具结构性。每个＜section＞都会围绕一个主题，并可以包含标题（如 ＜h1＞ 到 ＜h6＞）、段落、列表等。
对不同的＜section＞进行分组：可使用 class 属性随意取一个组别名称，例：＜section class="news"＞；然后在。css 样式表内对 class 属性进行定义即可。
class 可重复使用，不同的＜section＞也可以用同一个 class
[图片]
  ＜footer＞：用来标注网站的版权声明等内容

[图片]

3.2 实战项目

在实战学习中，你可以用这个网址工具进行快速预览尝试：https://codepen.io/pianmaa/pen/LEYQYOr

3.2.1 入门项目
[图片]
1. 打开终端，创建一个新文件：
touch my_first_page.HTML

2. 用 nano 编辑：
nano my_first_page.HTML

3. 粘贴以下代码：
＜!DOCTYPE HTML＞
＜HTML＞
＜head＞
    ＜title＞我的学习笔记＜/title＞
＜/head＞
＜body＞
    ＜h1＞欢迎来到我的网页！＜/h1＞
    ＜p＞这是我学习HTML的第一天。＜/p＞
    ＜p＞我喜欢：＜/p＞
    ＜ul＞
        ＜li＞编程＜/li＞
        ＜li＞音乐＜/li＞
        ＜li＞旅行＜/li＞
    ＜/ul＞
＜/body＞
＜/HTML＞

4. 保存并退出：
- 按 Ctrl+O → 回车
- 按 Ctrl+X

5. 在浏览器中打开：
- 在终端输入（Mac）：
open my_first_page.HTML
- 或直接双击文件
- 效果展示
[图片]
3.2.2 项目升级：个人简介页面

让我们创建一个更复杂的页面：

1. 创建新文件：
touch profile.HTML
nano profile.HTML

2. 使用这个模板：
  可复制版本：复制版本
＜!DOCTYPE HTML＞
＜HTML＞
＜head＞
    ＜title＞我的个人简介＜/title＞
    ＜style＞
        body { font-family: Arial; max-width: 800px; margin: 0 auto; }
        .header { background-color: #f0f0f0; padding: 20px; text-align: center; }
        .section { margin: 20px 0; border-bottom: 1px solid #ddd; padding-bottom: 20px; }
    ＜/style＞
＜/head＞
＜body＞
    ＜div class="header"＞
        ＜h1＞张三的个人主页＜/h1＞
        ＜img src="https://via.placeholder.com/150" alt="头像"＞
    ＜/div＞
    
    ＜div class="section"＞
        ＜h2＞关于我＜/h2＞
        ＜p＞我是一名编程初学者，正在学习HTML和Web开发。＜/p＞
    ＜/div＞
    
    ＜div class="section"＞
        ＜h2＞联系方式＜/h2＞
        ＜ul＞
            ＜li＞Email: me@example.com＜/li＞
            ＜li＞GitHub: ＜a href="https://github.com"＞我的GitHub＜/a＞＜/li＞
        ＜/ul＞
    ＜/div＞
＜/body＞
＜/HTML＞
3. 尝试修改：
- 替换名字和联系方式
- 更改颜色（修改 style 中的颜色代码）
- 添加新的章节
[图片]
4. 效果展示
[图片]
[图片]
[图片]

3.3 常见疑问
问题
答案
如何添加图片？
1. 把图片放在同一文件夹
2. 使用：
＜img src="你的图片.jpg" alt="描述"＞
如何改变文字颜色？
在＜style＞部分添加：
p { color: blue; }
/* 或者 */
.special { color: red; }
然后在 HTML 中使用：
＜p class="special"＞这段文字会变红＜/p＞
如何添加背景色？
＜body style="background-color: lightgray;"＞
为什么我的修改没显示？
1. 保存文件了吗？
2. 在浏览器中刷新页面（Command/Ctrl+R）
3. 检查是否有拼写错误


期待你的提问，可在此直接评论
 
[图片]

四、CSS
作为 HTML 的完美搭档，CSS 能让你的网页从"黑白电视"变成"彩色电影"。我会用最简单的方式教你 CSS，就像之前学习 HTML 一样

4.1 概念介绍
[图片]

1. 三种添加 CSS 的方式
序号
用法
局限/特点
例子
示例
1、
内联样式（直接写在 HTML 标签里）
如果在页面内插入第二个没有设定 css 的＜h2＞标题，对应的 red 不会应用，如图
＜h2 style="color: red"＞红色二级标题＜/h2＞

[图片]
[图片]
2、
内部样式表（放在＜style＞标签中）
只能对单独一个网页做外观样式处理
＜style＞
  h2{
    color: Red;
  }
  p{
    color: blue;
    font-size：36px;
  }
＜/style＞
[图片]

3、
外部样式表（最推荐的方式）
[图片]

1. 可以同时控制多个网页的外观
2. 可以同时控制每一组 class 的外观

可以同时控制多个网页的外观
- style.css:
h2{
    color: Red;
  }
p{
    color: blue;
    font-size:36px;
  }
- HTML 网页内：
＜head＞
＜link rel="stylesheet" href="style.css"＞
＜/head＞
可以同时控制每一组
- style.css:
.size{
    color:red;
    font-size:30px
   }
- HTML 网页内：
＜section class="news"
可以同时控制多个网页的外观
[图片]


可以同时控制每一组
[图片]
2.选择器类型
选择器
示例
说明
元素选择器
p { }
选择所有＜p＞标签
类选择器
.intro { }
选择class="intro"的元素
ID 选择器
#special { }
选择id="special"的元素
后代选择器
div p { }
选择＜div＞内的所有＜p＞ 
3. 常用 CSS 属性
类别
属性
示例
文字
color, font-size, font-family
color: red;
背景
background-color, background-image
background-color: #fff;
盒子模型
width, height, padding, margin, border
padding: 10px;
布局
display, flex-direction, justify-content
display: flex; 
1. CSS 的 3 个重要属性
A. border（边框）
B. padding（内边距）
C. margin（外边距）
[图片]
[图片]
- 他们负责控制不同网页元素之间的距离，距离书写规则：
[图片]

[图片]

4.2 实战项目

在实战学习中，你可以用这个网址工具进行快速预览尝试：https://www.w3schools.com/css/css_editor.asp
可复制代码版本：可复制代码版本

4.2.1 入门项目
[图片]
1. 创建 HTML 文件：
touch css_demo.HTML
nano css_demo.HTML

2. 添加基础 HTML：
＜!DOCTYPE HTML＞
＜HTML＞
＜head＞
    ＜title＞CSS学习＜/title＞
    ＜link rel="stylesheet" href="styles.css"＞
＜/head＞
＜body＞
    ＜h1＞欢迎学习CSS＜/h1＞
    ＜p class="intro"＞这是第一个段落＜/p＞
    ＜p id="special"＞这是特殊段落＜/p＞
    ＜div class="box"＞这是一个盒子＜/div＞
＜/body＞
＜/HTML＞

3. 创建 CSS 文件：
touch styles.css
nano styles.css

4. 添加 CSS 代码：
/* 改变整个页面的字体 */
body {
    font-family: Arial, sans-serif;
    background-color: #f5f5f5;
    margin: 0;
    padding: 20px;
}

/* 标题样式 */
h1 {
    color: #333;
    text-align: center;
}

/* 类选择器 */
.intro {
    color: blue;
    font-size: 18px;
}

/* ID选择器 */
#special {
    background-color: yellow;
    padding: 10px;
}

/* 盒子样式 */
.box {
    width: 200px;
    height: 200px;
    background-color: lightgreen;
    margin: 20px auto;
    border: 2px solid darkgreen;
    border-radius: 10px;
}

5. 在浏览器中查看效果：
open css_demo.HTML
[图片]
4.2.2 项目升级：制作个人名片

1. 创建新文件：
touch business_card.HTML
touch card_styles.css

2. HTML 代码 （business_card.HTML）：
＜!DOCTYPE HTML＞
＜HTML＞
＜head＞
    ＜title＞我的名片＜/title＞
    ＜link rel="stylesheet" href="card_styles.css"＞
＜/head＞
＜body＞
    ＜div class="card"＞
        ＜img src="https://via.placeholder.com/150" alt="头像"＞
        ＜h2＞张三＜/h2＞
        ＜p class="title"＞前端开发初学者＜/p＞
        ＜p class="contact"＞电话: 123-456-7890＜/p＞
        ＜p class="contact"＞邮箱: zhang@example.com＜/p＞
    ＜/div＞
＜/body＞
＜/HTML＞

3. CSS 代码 （card_styles.css）：
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-color: #f0f0f0;
    margin: 0;
}

.card {
    width: 300px;
    background: white;
    padding: 20px;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    text-align: center;
}

.card img {
    width: 150px;
    height: 150px;
    border-radius: 50%;
    object-fit: cover;
    margin-bottom: 15px;
}

.card h2 {
    margin: 0;
    color: #333;
}

.title {
    color: #666;
    font-style: italic;
    margin: 10px 0;
}

.contact {
    color: #444;
    margin: 5px 0;
}

4. 查看效果
[图片]
[图片]

[图片]

4.3 常见疑问
问题
答案
为什么我的 CSS 样式没有生效？

1. 可能原因及解决方案：
2. 选择器错误：
  - 检查 HTML 和 CSS 中的类名/ID 是否一致（注意大小写）
  - 示例：HTML 中是class="myClass"，CSS 应该是.myClass而不是.Myclass

2. 优先级问题：
  - 内联样式 ＞ ID 选择器 ＞ 类选择器 ＞ 元素选择器
  - 使用!important强制覆盖（但不推荐滥用）：
p { color: red !important; }
3. 文件路径错误：
  - 检查＜link＞的 href 路径是否正确
  - 推荐使用相对路径：
＜link rel="stylesheet" href="css/styles.css"＞
如何居中一个 div？
.container {
    display: flex;
    justify-content: center; /* 水平居中 */
    align-items: center;     /* 垂直居中 */
    height: 100vh;          /* 视口高度 */
}
如何实现两栏布局？

.container {
    display: flex;
}
.left-column {
    width: 30%;
}
.right-column {
    flex: 1; /* 占据剩余空间 */
}
如何让元素并排显示？
* 方法1：使用flexbox */
.container {
    display: flex;
}

/* 方法2：使用inline-block */
.item {
    display: inline-block;
    width: 30%;
}
如何去掉列表前的圆点？
ul {
    list-style-type: none;
    padding-left: 0; /* 同时去掉缩进 */
}
如何添加文字阴影？
h1 {
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    /* 水平偏移 垂直偏移 模糊度 颜色 */
}
如何制作圆形头像？
.avatar {
    width: 100px;
    height: 100px;
    border-radius: 50%;  /* 关键属性 */
    object-fit: cover;   /* 保持图片比例 */
}
如何查看元素实际应用的 CSS？
1. 右键点击元素 → "检查"（Chrome/Firefox）
2. 在开发者工具的"Styles"面板中：
  - 可以看到所有应用的样式
  - 被覆盖的样式会有删除线
  - 可以实时修改测试效果
为什么 margin-top 不生效？
可能原因：
- 父元素没有边框（border）或内边距（padding）
- 存在外边距折叠（margin collapse）

解决方案：
.parent {
    overflow: auto; /* 创建新的BFC */
    /* 或 */
    padding: 1px; /* 最小化影响 */
}

期待你的提问，可在此直接评论
 
[图片]

五、Javascript/TypeScript
TypeScript 是 JavaScript 的亲哥，比 JavaScript 更严格但更靠谱。
名称
JavaScript
TypeScript
特性
- 像是一个随意写作业的学生，写错了也能运行（比如把 数字 和 字符串 乱加在一起）。
- 灵活，但容易写出隐藏的 bug。

- 像是强迫症老师，要求你先声明类型才能写代码：
- let age: number = 25;  // 必须明确说这是数字
age = "25岁";          // ❌ 直接报错！（JavaScript 里却不会）
- 最终会变成 JavaScript（浏览器只认识 JS），但写代码时能提前发现错误。
[图片]

5.1 概念介绍

1. JavaScript 基础三要素

变量 - 数据的存储盒子
let message = "你好世界";  // 创建一个名为message的盒子，放入"你好世界"
const PI = 3.14;        // 创建一个锁定的盒子，放入3.14且不能再改
- let：普通盒子，可以随时换内容
- const：上锁的盒子，内容固定不变
- 建议优先使用 const，需要改变时才用 let

函数 - 可重复使用的工具包
function makeJuice(fruit) {  // 定义一个榨汁机
  return fruit + "汁";       // 返回加工结果
}
const myJuice = makeJuice("苹果"); // 使用榨汁机
- function：创建工具包的模具
- fruit：原料入口（参数）
- return：成品出口（返回值）

对象 - 属性收纳盒
const person = {       // 创建一个个人信息盒
  name: "小明",        // 名字抽屉
  age: 20,            // 年龄抽屉
  hobbies: ["编程", "音乐"] // 爱好抽屉（数组）
};
console.log(person.name); // 取出名字
- 用 {} 创建对象
- 属性名: 值 的形式存储数据
- 用 . 访问属性

2. TypeScript 类型安全

类型注解 - 给盒子贴标签
let username: string = "小明"; // 这个盒子只能放文字
let age: number = 20;         // 这个盒子只能放数字
let isStudent: boolean = true;// 这个盒子只能放true/false
- 在变量名后加 : 类型 来限制内容类型
- 错误示例：age = "20岁" 会报错（不能把文字放入数字盒子）

接口 - 对象属性检查表
interface Student {    // 定义学生表格模板
  name: string;       // 必须有名字栏（文字）
  age: number;        // 必须有年龄栏（数字）
  major?: string;     // 可选专业栏（可能有也可能没有）
}

const stu1: Student = { 
  name: "小红", 
  age: 19 
}; // 正确

const stu2: Student = { 
  name: "小刚" 
}; // 错误：缺少age

3. JavaScript (.JS)、JSX (.JSx)、TypeScript (.ts)、TSX (.tsx)

- .JS、.ts、.JSx、.tsx 是什么？怎么用？
1. JavaScript (.JS） —— 基础电路和自动化系统
就像房子里最基本的电路和自动化系统，JavaScript 提供了核心的运行功能，但缺少详细的说明书和严格的安全保障，容易出现接线不规范的问题。
[图片]
2. TypeScript (.ts） —— 升级版的电路系统
TypeScript 就像在原有电路系统基础上增加了详细蓝图和智能检测装置：每根线路、每个开关都有明确标识和安全规范，如果安装错误，系统会提前报警，让整个房子更安全、更易维护。
[图片]
- 学员果果补充：
  不知道怎么将 ts 转变为 JS，我问了 AI。
  
  在 macOS 系统上安装
  验证安装：
  bash  重击
  node -v
  npm -v
  显示版本号，则安装成功。
  
  然后我按照 AI 推荐的代码运行，终端一直显示安装中，用了挺长时间，最后让重新输入 cd 什么的，输入完就安装好了。
  分享给大家，仅做补充
[图片]
[图片]
[图片]
[图片]
3. JSX (.JSx） —— 图形化控制界面
JSX 类似于给电路系统加上了一个直观的显示屏和控制面板，虽然底层依然是电路（JavaScript），但通过友好的图形界面，你可以更直观地看到和控制每个设备（UI 组件）。
[图片]
  
举个例子，我们可以将 XML 文档比作一本书籍，每个部分都有特定的角色和规则：
- 文档声明： 就像书籍的封面，标明了书名、作者和版本信息。XML 的文档声明位于文件的开头，指定了 XML 的版本和编码方式，例如：＜?xml version="1.0" encoding="UTF-8"?＞。
- 元素和结束标签： 类似于书中的章节标题和内容，每个元素都有一个开始标签和一个结束标签，内容位于两者之间。例如：＜chapter＞内容＜/chapter＞。
  
4. TSX (.tsx） —— 安全电路系统+智能家居控制面板
TSX 就是在升级版电路系统（TypeScript）的基础上，再加上了智能化、直观的控制界面（JSX），既保证了系统的安全性和规范性，又能以直观的方式管理和展示系统状态，非常适合现代的 React 开发。
[图片]

- JS、JSx、ts、tsx 代码示例（让我们用做菜来理解这部分代码）
1. .JS：就像随手写下一段简单的做饭步骤：
// example.JS
function greet(name) {
  console.log("Hello, " + name + "!");
}

greet("Alice");
这里你直接告诉程序“当见到名字时，就打招呼”，不做任何类型检查。

2. .JSx:现在你需要写一个带有漂亮摆盘（用户界面）的菜谱：
// ExampleComponent.JSx
import React from 'react';

// 定义组件属性的类型
const ExampleComponent = ({ name }) =＞ {
  return ＜div＞Hello, {name}!＜/div＞;
};

export default ExampleComponent;
JSX 只是简单地假设你已经用对了食材，然后为你呈现漂亮的装盘。

3. .ts：在写菜谱时，你规定了每种食材的量（类型），确保出错前就被提醒：
// example.ts
function greet(name: string): void {
  console.log(`Hello, ${name}!`);
}

greet("Alice");

如果你错误地传入了数字，比如 greet(123)，编译器会报错，提醒你应该传字符串。这就是类型检查的作用。

4. .tsx：现在你需要写一个带有漂亮摆盘（用户界面）的智能菜谱（有类型检查）：
// ExampleComponent.tsx
import React from 'react';

// 定义组件属性的类型（就像明确菜谱里每种食材的用量）
interface Props {
  name: string;
}

// 这里写的是一个 React 组件，用 JSX 来描述界面
const ExampleComponent: React.FC＜Props＞ = ({ name }) =＞ {
  return ＜div＞Hello, {name}!＜/div＞;
};

export default ExampleComponent;

这段代码既有 TypeScript 的类型检查（确保 name 是字符串），又使用了 JSX 语法来写出类似 HTML 的界面代码。

[图片]

5.2 实战项目
在本实战环节中，推荐使用 Cursor 来完成任务

5.2.1 入门项目
[图片]
目标说明
- [+] 按钮：数字 +1
- [-] 按钮：数字 -1
- 显示当前数值

阅读代码，复制到 HTML 文件中
可复制版本：可复制版本
＜!-- HTML结构 - 可视化界面 --＞
＜div＞
  ＜button id="btn-minus"＞-＜/button＞  ＜!-- 减号按钮 --＞
  ＜span id="display"＞0＜/span＞        ＜!-- 显示数字的区域 --＞
  ＜button id="btn-plus"＞+＜/button＞   ＜!-- 加号按钮 --＞
＜/div＞

＜script＞
  // 1. 准备变量（记忆当前数值）
  let count = 0;
  
  // 2. 获取页面元素（找到操作对象）
  const display = document.getElementById("display");
  const plusBtn = document.getElementById("btn-plus");
  const minusBtn = document.getElementById("btn-minus");
  
  // 3. 给加号按钮添加"耳朵"
  plusBtn.addEventListener("click", () =＞ {
    count++;                // 数值+1
    display.textContent = count; // 更新显示
  });
  
  // 4. 给减号按钮添加"耳朵" 
  minusBtn.addEventListener("click", () =＞ {
    count--;                // 数值-1
    display.textContent = count; // 更新显示
  });
＜/script＞

详细讲解
- HTML 部分
＜div＞
  ＜button id="btn-minus"＞-＜/button＞  ＜!-- 减号按钮 --＞
  ＜span id="display"＞0＜/span＞        ＜!-- 显示数字的区域 --＞
  ＜button id="btn-plus"＞+＜/button＞   ＜!-- 加号按钮 --＞
＜/div＞
＜div＞：作为一个容器元素，用于将减号按钮、显示区域和加号按钮组合在一起。
＜button id="btn - minus"＞-＜/button＞：创建一个减号按钮，id 属性为 btn - minus，方便后续通过 JavaScript 来选中该按钮。
＜span id="display"＞0＜/span＞：创建一个用于显示数字的区域，初始显示数字为 0，id 属性为 display，便于后续更新显示内容。
＜button id="btn - plus"＞+＜/button＞：创建一个加号按钮，id 属性为 btn - plus，后续可通过 JavaScript 选中该按钮。
- JavaScript 部分
// 1. 准备变量（记忆当前数值）
let count = 0;

// 2. 获取页面元素（找到操作对象）
const display = document.getElementById("display");
const plusBtn = document.getElementById("btn-plus");
const minusBtn = document.getElementById("btn-minus");

// 3. 给加号按钮添加"耳朵"
plusBtn.addEventListener("click", () =＞ {
  count++;                // 数值+1
  display.textContent = count; // 更新显示
});

// 4. 给减号按钮添加"耳朵" 
minusBtn.addEventListener("click", () =＞ {
  count--;                // 数值-1
  display.textContent = count; // 更新显示
});
let count = 0;：声明一个变量 count 并初始化为 0，这个变量用于记录当前计数器的数值。
const display = document.getElementById("display");：使用 document.getElementById 方法获取 id 为 display 的 ＜span＞ 元素，后续会用它来更新显示的数字。
const plusBtn = document.getElementById("btn - plus");：获取 id 为 btn - plus 的加号按钮元素。
const minusBtn = document.getElementById("btn - minus");：获取 id 为 btn - minus 的减号按钮元素。
plusBtn.addEventListener("click", () =＞ { ... });：为加号按钮添加一个点击事件监听器。当用户点击加号按钮时，会执行箭头函数中的代码。在这个函数中，count++ 会让 count 变量的值加 1，然后 display.textContent = count 会将更新后的 count 值显示在 ＜span＞ 元素中。
minusBtn.addEventListener("click", () =＞ { ... });：为减号按钮添加一个点击事件监听器。当用户点击减号按钮时，会执行箭头函数中的代码。在这个函数中，count-- 会让 count 变量的值减 1，然后 display.textContent = count 会将更新后的 count 值显示在 ＜span＞ 元素中。
这段代码通过 HTML 创建了界面，再利用 JavaScript 实现了计数器的交互功能。 
[图片]
[图片]
[图片]
尝试按需进行代码更改
- 点击加号，数值 +1 变更为 +6
＜!DOCTYPE HTML＞
＜HTML lang="en"＞

＜head＞
    ＜meta charset="UTF-8"＞
    ＜meta name="viewport" content="width=device-width, initial-scale=1.0"＞
    ＜title＞Counter＜/title＞
    ＜script src="https://cdn.tailwindcss.com"＞＜/script＞
    ＜link href="https://cdnJS.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" rel="stylesheet"＞
＜/head＞

＜body class="flex justify-center items-center h-screen bg-gray-100"＞
    ＜div class="bg-white p-8 rounded shadow-md"＞
        ＜button id="btn-minus" class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"＞-＜/button＞
        ＜span id="display" class="px-4 py-2 text-xl font-bold"＞0＜/span＞
        ＜button id="btn-plus" class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"＞+＜/button＞
    ＜/div＞
    ＜script＞
        // 1. 准备变量（记忆当前数值）
        let count = 0;

        // 2. 获取页面元素（找到操作对象）
        const display = document.getElementById("display");
        const plusBtn = document.getElementById("btn-plus");
        const minusBtn = document.getElementById("btn-minus");

        // 3. 给加号按钮添加"耳朵"
        plusBtn.addEventListener("click", () =＞ {
            count += 6; // 数值加 6
            display.textContent = count; // 更新显示
        });

        // 4. 给减号按钮添加"耳朵" 
        minusBtn.addEventListener("click", () =＞ {
            count--; // 数值减 1
            display.textContent = count; // 更新显示
        });
    ＜/script＞
＜/body＞

＜/HTML＞
    
实际效果
[图片]
- 点击减号，数值 -1 变更为 -7
＜!DOCTYPE HTML＞
＜HTML lang="en"＞

＜head＞
    ＜meta charset="UTF-8"＞
    ＜meta name="viewport" content="width=device-width, initial-scale=1.0"＞
    ＜title＞Counter＜/title＞
    ＜script src="https://cdn.tailwindcss.com"＞＜/script＞
    ＜link href="https://cdnJS.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" rel="stylesheet"＞
＜/head＞

＜body class="flex justify-center items-center h-screen bg-gray-100"＞
    ＜div class="bg-white p-8 rounded shadow-md"＞
        ＜button id="btn-minus" class="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"＞-＜/button＞
        ＜span id="display" class="px-4 py-2 text-xl font-bold"＞0＜/span＞
        ＜button id="btn-plus" class="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"＞+＜/button＞
    ＜/div＞
    ＜script＞
        // 1. 准备变量（记忆当前数值）
        let count = 0;

        // 2. 获取页面元素（找到操作对象）
        const display = document.getElementById("display");
        const plusBtn = document.getElementById("btn-plus");
        const minusBtn = document.getElementById("btn-minus");

        // 3. 给加号按钮添加"耳朵"
        plusBtn.addEventListener("click", () =＞ {
            count ++; // 数值加 1
            display.textContent = count; // 更新显示
        });

        // 4. 给减号按钮添加"耳朵" 
        minusBtn.addEventListener("click", () =＞ {
            count -= 6; // 数值减 6
            display.textContent = count; // 更新显示
        });
    ＜/script＞
＜/body＞

＜/HTML＞
    
实际效果
[图片]
- 学员果果补充：
  后来试了下豆包，它甚至有专门的 coding 页面帮助学习
  https://www.doubao.com/chat/coding
  我把代码复制进去让它逐行讲解并针对每一个可变的量都举一反三。效果很好。

5.2.2 项目升级：待办事项清单

功能演示
- 输入文字 + 点击添加 → 新增待办项
- 点击项目 → 切换完成状态（划线效果）
- 实时显示未完成数量

阅读代码，复制到 HTML 文件中
可复制版本：可复制版本
＜!DOCTYPE HTML＞
＜HTML lang="zh-CN"＞
＜head＞
    ＜meta charset="UTF-8"＞
    ＜meta name="viewport" content="width=device-width, initial-scale=1.0"＞
    ＜title＞我的待办事项＜/title＞
    ＜style＞
        body {
            font-family: Arial, sans-serif;
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
        }
        #todo-input {
            width: 70%;
            padding: 8px;
            margin-right: 5px;
        }
        button {
            padding: 8px 15px;
        }
        #todo-list {
            list-style: none;
            padding: 0;
        }
        #todo-list li {
            padding: 8px;
            margin: 5px 0;
            background: #f5f5f5;
            Cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #todo-list li.done {
            text-decoration: line-through;
            color: #888;
        }
        #counter {
            margin-top: 10px;
            color: #666;
        }
        .delete-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            Cursor: pointer;
        }
    ＜/style＞
＜/head＞
＜body＞
    ＜h1＞待办事项清单＜/h1＞
    
    ＜div＞
        ＜input type="text" id="todo-input" placeholder="输入待办事项"＞
        ＜button onclick="addTodo()"＞添加＜/button＞
    ＜/div＞
    
    ＜ul id="todo-list"＞＜/ul＞
    
    ＜div id="counter"＞剩余：0项＜/div＞
    
    ＜script＞
        // 初始化数据
        let todos = [];  // 存放所有待办项
        let nextId = 1;  // 自动生成ID用

        // 添加新项目
        function addTodo() {
            const input = document.getElementById("todo-input");
            const text = input.value.trim();
            
            if (text === "") {
                alert("请输入内容");
                return;
            }
            
            const newTodo = {
                id: nextId++,
                text: text,
                done: false
            };
            
            todos.push(newTodo);
            input.value = "";
            updateList();
        }

        // 更新界面
        function updateList() {
            const listElement = document.getElementById("todo-list");
            const counterElement = document.getElementById("counter");
            
            // 生成列表HTML
            listElement.innerHTML = todos.map(todo =＞ `
                ＜li class="${todo.done ? 'done' : ''}" onclick="toggleTodo(${todo.id})"＞
                    ＜span＞${todo.text}＜/span＞
                    ＜button class="delete-btn" onclick="event.stopPropagation(); deleteTodo(${todo.id})"＞删除＜/button＞
                ＜/li＞
            `).join("");
            
            // 更新计数器
            const activeCount = todos.filter(t =＞ !t.done).length;
            counterElement.textContent = `剩余：${activeCount}项`;
        }

        // 切换完成状态
        function toggleTodo(id) {
            const todo = todos.find(t =＞ t.id === id);
            if (todo) {
                todo.done = !todo.done;
                updateList();
            }
        }

        // 删除待办项
        function deleteTodo(id) {
            todos = todos.filter(t =＞ t.id !== id);
            updateList();
        }

        // 添加回车键支持
        document.getElementById("todo-input").addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                addTodo();
            }
        });

        // 初始化显示
        updateList();
    ＜/script＞
＜/body＞
＜/HTML＞
代码讲解
HTML 部分
＜!DOCTYPE HTML＞
＜HTML lang="zh-CN"＞
＜head＞
    ＜meta charset="UTF-8"＞
    ＜meta name="viewport" content="width=device-width, initial-scale=1.0"＞
    ＜title＞我的待办事项＜/title＞
    ＜style＞
        body {
            font-family: Arial, sans-serif;
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
        }
        #todo-input {
            width: 70%;
            padding: 8px;
            margin-right: 5px;
        }
        button {
            padding: 8px 15px;
        }
        #todo-list {
            list-style: none;
            padding: 0;
        }
        #todo-list li {
            padding: 8px;
            margin: 5px 0;
            background: #f5f5f5;
            Cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #todo-list li.done {
            text-decoration: line-through;
            color: #888;
        }
        #counter {
            margin-top: 10px;
            color: #666;
        }
        .delete-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            Cursor: pointer;
        }
    ＜/style＞
＜/head＞
＜body＞
    ＜h1＞待办事项清单＜/h1＞
    
    ＜div＞
        ＜input type="text" id="todo-input" placeholder="输入待办事项"＞
        ＜button onclick="addTodo()"＞添加＜/button＞
    ＜/div＞
    
    ＜ul id="todo-list"＞＜/ul＞
    
    ＜div id="counter"＞剩余：0项＜/div＞
    
    ＜script＞
        // 初始化数据
        let todos = [];  // 存放所有待办项
        let nextId = 1;  // 自动生成ID用

        // 添加新项目
        function addTodo() {
            const input = document.getElementById("todo-input");
            const text = input.value.trim();
            
            if (text === "") {
                alert("请输入内容");
                return;
            }
            
            const newTodo = {
                id: nextId++,
                text: text,
                done: false
            };
            
            todos.push(newTodo);
            input.value = "";
            updateList();
        }

        // 更新界面
        function updateList() {
            const listElement = document.getElementById("todo-list");
            const counterElement = document.getElementById("counter");
            
            // 生成列表HTML
            listElement.innerHTML = todos.map(todo =＞ `
                ＜li class="${todo.done ? 'done' : ''}" onclick="toggleTodo(${todo.id})"＞
                    ＜span＞${todo.text}＜/span＞
                    ＜button class="delete-btn" onclick="event.stopPropagation(); deleteTodo(${todo.id})"＞删除＜/button＞
                ＜/li＞
            `).join("");
            
            // 更新计数器
            const activeCount = todos.filter(t =＞ !t.done).length;
            counterElement.textContent = `剩余：${activeCount}项`;
        }

        // 切换完成状态
        function toggleTodo(id) {
            const todo = todos.find(t =＞ t.id === id);
            if (todo) {
                todo.done = !todo.done;
                updateList();
            }
        }

        // 删除待办项
        function deleteTodo(id) {
            todos = todos.filter(t =＞ t.id !== id);
            updateList();
        }

        // 添加回车键支持
        document.getElementById("todo-input").addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                addTodo();
            }
        });

        // 初始化显示
        updateList();
    ＜/script＞
＜/body＞
＜/HTML＞
1. 文档声明与字符编码：
＜!DOCTYPE HTML＞
＜HTML lang="zh-CN"＞
＜head＞
    ＜meta charset="UTF-8"＞
    ＜meta name="viewport" content="width=device-width, initial-scale=1.0"＞
    ＜title＞我的待办事项＜/title＞
- ＜!DOCTYPE HTML＞：声明文档类型为 HTML5。
- ＜HTML lang="zh-CN"＞：设置文档语言为中文。
- ＜meta charset="UTF-8"＞：指定字符编码为 UTF - 8。
- ＜meta name="viewport" content="width=device-width, initial-scale=1.0"＞：确保页面在不同设备上正确显示。
- ＜title＞我的待办事项＜/title＞：设置网页标题。

2. CSS 样式部分：
body {
    font-family: Arial, sans-serif;
    max-width: 500px;
    margin: 0 auto;
    padding: 20px;
}
    - body：设置页面主体的字体、最大宽度、居中显示和内边距。

#todo-input {
    width: 70%;
    padding: 8px;
    margin-right: 5px;
}
    - #todo-input：设置输入框的宽度、内边距和右边距。

button {
    padding: 8px 15px;
}
    - button：设置按钮的内边距。

#todo-list {
    list-style: none;
    padding: 0;
}
    - #todo-list：去除列表的默认样式和内边距。

#todo-list li {
    padding: 8px;
    margin: 5px 0;
    background: #f5f5f5;
    Cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
    - #todo-list li：设置列表项的内边距、外边距、背景颜色、鼠标指针样式，并使用 Flexbox 布局。

#todo-list li.done {
    text-decoration: line-through;
    color: #888;
}
    - #todo-list li.done：设置已完成事项的样式，添加删除线和灰色文字。

#counter {
    margin-top: 10px;
    color: #666;
}
    - #counter：设置计数器的上边距和文字颜色。

.delete-btn {
    background: #ff4444;
    color: white;
    border: none;
    padding: 4px 8px;
    border-radius: 4px;
    Cursor: pointer;
}
    - .delete-btn：设置删除按钮的背景颜色、文字颜色、无边框、内边距、圆角和鼠标指针样式。

3. HTML 结构部分：
＜body＞
    ＜h1＞待办事项清单＜/h1＞
    
    ＜div＞
        ＜input type="text" id="todo-input" placeholder="输入待办事项"＞
        ＜button onclick="addTodo()"＞添加＜/button＞
    ＜/div＞
    
    ＜ul id="todo-list"＞＜/ul＞
    
    ＜div id="counter"＞剩余：0项＜/div＞
- ＜h1＞待办事项清单＜/h1＞：显示页面标题。
- ＜input type="text" id="todo-input" placeholder="输入待办事项"＞：输入待办事项的文本框。
- ＜button onclick="addTodo()"＞添加＜/button＞：点击按钮调用 addTodo 函数添加待办事项。
- ＜ul id="todo-list"＞＜/ul＞：用于显示待办事项列表。
- ＜div id="counter"＞剩余：0项＜/div＞：显示剩余未完成事项的数量。

JavaScript 部分
// 初始化数据
let todos = [];  // 存放所有待办项
let nextId = 1;  // 自动生成ID用
- todos：一个数组，用于存储所有待办事项。
- nextId：用于为每个待办事项生成唯一的 ID。

// 添加新项目
function addTodo() {
    const input = document.getElementById("todo-input");
    const text = input.value.trim();
    
    if (text === "") {
        alert("请输入内容");
        return;
    }
    
    const newTodo = {
        id: nextId++,
        text: text,
        done: false
    };
    
    todos.push(newTodo);
    input.value = "";
    updateList();
}
- addTodo 函数：
  1. 获取输入框的值并去除首尾空格。
  2. 如果输入为空，弹出提示框并返回。
  3. 创建一个新的待办事项对象，包含 id、text 和 done 属性。
  4. 将新的待办事项添加到 todos 数组中。
  5. 清空输入框。
  6. 调用 updateList 函数更新界面。

// 更新界面
function updateList() {
    const listElement = document.getElementById("todo-list");
    const counterElement = document.getElementById("counter");
    
    // 生成列表HTML
    listElement.innerHTML = todos.map(todo =＞ `
        ＜li class="${todo.done ? 'done' : ''}" onclick="toggleTodo(${todo.id})"＞
            ＜span＞${todo.text}＜/span＞
            ＜button class="delete-btn" onclick="event.stopPropagation(); deleteTodo(${todo.id})"＞删除＜/button＞
        ＜/li＞
    `).join("");
    
    // 更新计数器
    const activeCount = todos.filter(t =＞ !t.done).length;
    counterElement.textContent = `剩余：${activeCount}项`;
}
- updateList 函数：
  1. 获取待办事项列表和计数器元素。
  2. 使用 map 方法将 todos 数组中的每个待办事项转换为 HTML 列表项，并使用 join 方法将它们连接成一个字符串。
  3. 将生成的 HTML 字符串赋值给待办事项列表的 innerHTML 属性。
  4. 过滤出未完成的待办事项，计算其数量并更新计数器的文本内容。

// 切换完成状态
function toggleTodo(id) {
    const todo = todos.find(t =＞ t.id === id);
    if (todo) {
        todo.done = !todo.done;
        updateList();
    }
}
- toggleTodo 函数：
  1. 根据 id 查找待办事项。
  2. 如果找到，切换其 done 属性的值。
  3. 调用 updateList 函数更新界面。

// 删除待办项
function deleteTodo(id) {
    todos = todos.filter(t =＞ t.id !== id);
    updateList();
}
- deleteTodo 函数：
  1. 使用 filter 方法过滤掉指定 id 的待办事项。
  2. 调用 updateList 函数更新界面。

// 添加回车键支持
document.getElementById("todo-input").addEventListener("keypress", function(event) {
    if (event.key === "Enter") {
        addTodo();
    }
});
- 为输入框添加 keypress 事件监听器，当按下回车键时，调用 addTodo 函数。

// 初始化显示
updateList();
- 页面加载时调用 updateList 函数，初始化待办事项列表和计数器。

综上所述，这段代码通过 HTML 构建页面结构，CSS 设置样式，JavaScript 实现待办事项的添加、标记完成、删除和计数功能。

[图片]
[图片]
[图片]
5.3 常见疑问
问题
答案
JavaScript 和 TypeScript 该先学哪个？
- 建议路线：
  1. 先学 JavaScript 基础（2-3 周）
  2. 再过渡到 TypeScript 类型系统
- 原因：TS 需要 JS 基础，但早期引入类型概念能减少错误
为什么我的事件监听不工作？
- 检查清单：
  - ✅ 确保 script 标签放在 body 末尾或使用DOMContentLoaded
  - ✅ 检查选择器是否写错（getElementById要完全匹配 ID）
  - ✅ 用console.log测试元素是否成功获取
TypeScript 类型报错看不懂怎么办？
- 调试步骤：
  1. 把鼠标悬停在报错变量上（VSCode 会显示类型信息）
  2. 检查接口定义和实际数据的结构是否一致
  3. 临时用any类型绕过（不推荐长期使用）
如何看到代码运行效果？
- 浏览器调试技巧：
  1. 右键 → "检查" 打开开发者工具
  2. 切换到"Console"标签查看console.log输出
  3. 在"Sources"标签设置断点逐步执行
数组的 map/filter 有什么区别？
- 生活比喻：
  - map：流水线加工（1 个进去 1 个出来，数量不变）
const prices = [10, 20, 30];
const discounts = prices.map(price =＞ price * 0.9); // [9,18,27]
  - filter：筛子过滤（只保留符合条件的）
const numbers = [1, 5, 10, 15];
const bigNumbers = numbers.filter(n =＞ n ＞ 8); // [10,15]


期待你的提问，可在此直接评论
 
[图片]

六、Tailwind CSS
Tailwind CSS 是一个通过组合现成的工具类来快速构建定制化界面的 CSS 框架，让你不用写传统 CSS 就能实现专业设计，就像用乐高积木拼装页面一样简单高效

[图片]

6.1 核心概念
[图片]

1. 核心特点
原子类（Atomic CSS）是一种 CSS 设计思想，它的核心概念是：每个 CSS 类名只做一件事。
  - 在传统 CSS 里，你可能会写：
.button {
  background-color: blue;
  color: white;
  padding: 10px 20px;
  border-radius: 5px;
}
    然后在 HTML 里使用：
＜button class="button"＞点击我＜/button＞
  - 但在 Tailwind CSS 里，你不需要定义.button类，而是直接在 HTML 中用原子类拼装：
＜button class="bg-blue-500 text-white px-4 py-2 rounded"＞点击我＜/button＞
    - 上面的代码里，每个类都只负责一个属性，比如：
      - bg-blue-500 → 设置背景色
      - text-white → 设置文字颜色
      - px-4 → 水平方向的内边距（padding）
      - py-2 → 垂直方向的内边距
      - rounded → 圆角
    - 这种方式的优势是：
[图片]
2. 安装 Tailwind
在 HTML 文件中通过 CDN 引入（简单示例，生产环境建议其他安装方式）：
＜!DOCTYPE HTML＞
＜HTML＞
＜head＞
  ＜meta charset="UTF-8"＞
  ＜meta name="viewport" content="width=device-width, initial-scale=1.0"＞
  ＜script src="https://cdn.tailwindcss.com"＞＜/script＞
＜/head＞
＜body＞
  ＜!-- 你的内容 --＞
＜/body＞
＜/HTML＞

3. 基础工具类
文字样式
＜p class="text-lg text-red-600 font-bold"＞这是红色加粗的大文字＜/p＞
- text-lg：大号文字
- text-red-600：红色（色阶 600）
- font-bold：加粗字体

间距
＜div class="m-4 p-4"＞
  ＜p class="mb-2"＞下方有2单位的间距＜/p＞
  ＜p＞普通段落＜/p＞
＜/div＞
- m-4：外边距 4 单位（1 单位=0.25rem）
- p-4：内边距 4 单位
- mb-2：下边距 2 单位

颜色
＜button class="bg-blue-500 hover:bg-blue-700 text-white py-2 px-4 rounded"＞
  点击按钮
＜/button＞
- bg-blue-500：蓝色背景
- hover:bg-blue-700：悬停时深蓝色背景
- text-white：白色文字
- py-2：上下内边距
- px-4：左右内边距
- rounded：圆角

4.如何在用 ai 来使 Tailwind 的功能最大化
A. 任一选择一个你喜欢的应用界面截图给 ai ，让他学习该页面布局风格还原。
[图片]
B. 也可以将 Claude 生成的代码复制到 tailwind PLAY 上查看效果（https://play.tailwindcss.com/）
[图片]

[图片]

6.2 实战项目
- 打开 Tailwind Play 可在线练习

6.2.1 入门项目
可复制版本：可复制版本
＜div class="max-w-md mx-auto bg-gradient-to-br from-blue-50 to-purple-50 rounded-2xl shadow-lg overflow-hidden transition-all hover:shadow-xl"＞
  ＜div class="md:flex"＞
    ＜!-- 头像区域 --＞
    ＜div class="md:shrink-0 p-6 flex justify-center"＞
      ＜img class="h-32 w-32 rounded-full object-cover border-4 border-white shadow-md" 
           src="https://images.unsplash.com/photo-1534528741775-53994a69daeb?ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D&auto=format&fit=crop&w=300&q=80" 
           alt="Profile"＞
    ＜/div＞
    
    ＜!-- 内容区域 --＞
    ＜div class="p-8 md:p-6"＞
      ＜div class="uppercase tracking-widest text-xs font-bold text-purple-600 mb-1"＞UI/UX Designer＜/div＞
      ＜h3 class="text-2xl font-bold text-gray-800 mb-2"＞张美丽＜/h3＞
      ＜p class="text-gray-600 mb-4"＞专注创造美观且用户友好的数字体验＜/p＞
      
      ＜div class="flex space-x-3"＞
        ＜span class="bg-white px-3 py-1 rounded-full text-xs font-medium text-purple-600 shadow-sm"＞#Figma＜/span＞
        ＜span class="bg-white px-3 py-1 rounded-full text-xs font-medium text-blue-600 shadow-sm"＞#Tailwind＜/span＞
      ＜/div＞
    ＜/div＞
  ＜/div＞
＜/div＞
[图片]

6.2.2 项目升级：待办事项列表
可复制版本：可复制版本
＜div class="max-w-md mx-auto mt-10 bg-white rounded-xl shadow-md overflow-hidden"＞
  ＜!-- 头部 --＞
  ＜div class="bg-gradient-to-r from-purple-500 to-blue-500 p-4"＞
    ＜h1 class="text-2xl font-bold text-white"＞今日任务＜/h1＞
    ＜p class="text-blue-100 text-sm"＞剩余 ＜span class="font-bold"＞3＜/span＞ 项待完成＜/p＞
  ＜/div＞
  
  ＜!-- 输入区域 --＞
  ＜div class="p-4 border-b"＞
    ＜div class="flex shadow-sm"＞
      ＜input 
        type="text" 
        class="flex-1 rounded-l-lg border-0 py-3 px-4 text-gray-700 ring-1 ring-inset ring-gray-300 focus:ring-2 focus:ring-purple-500 outline-none" 
        placeholder="写下一个新任务..."＞
      ＜button class="bg-purple-500 hover:bg-purple-600 text-white px-4 rounded-r-lg transition-colors"＞
        ＜svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"＞
          ＜path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" /＞
        ＜/svg＞
      ＜/button＞
    ＜/div＞
  ＜/div＞
  
  ＜!-- 任务列表 --＞
  ＜ul class="divide-y divide-gray-100"＞
    ＜li class="p-4 hover:bg-gray-50 transition-colors group"＞
      ＜label class="flex items-center Cursor-pointer"＞
        ＜input type="checkbox" class="h-5 w-5 text-purple-500 rounded border-gray-300 focus:ring-purple-500 mr-3"＞
        ＜span class="text-gray-700 font-medium"＞完成Tailwind项目设计＜/span＞
        ＜span class="ml-auto bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full"＞工作＜/span＞
      ＜/label＞
    ＜/li＞
    ＜li class="p-4 hover:bg-gray-50 transition-colors group"＞
      ＜label class="flex items-center Cursor-pointer"＞
        ＜input type="checkbox" checked class="h-5 w-5 text-purple-500 rounded border-gray-300 focus:ring-purple-500 mr-3"＞
        ＜span class="text-gray-400 font-medium line-through"＞购买生日礼物＜/span＞
      ＜/label＞
    ＜/li＞
  ＜/ul＞
＜/div＞
[图片]
 
尝试着调整代码，加深学习印象，比如更改颜色、更改字号...

[图片]

6.3 常见疑问
问题
答案
Tailwind 会增大 HTML 文件大小吗？
- Tailwind 会通过 PurgeCSS 在生产环境中移除未使用的类
- 最终文件大小通常比传统 CSS 更小
如何自定义颜色或间距？

在 tailwind.config.JS 中配置：
module.exports = {
  theme: {
    extend: {
      colors: {
        'brand-blue': '#1992d4',
      },
      spacing: {
        '72': '18rem',
      }
    }
  }
}

Tailwind 适合大型项目吗？
- 非常适合，因为：
  - 保持样式一致性
  - 减少命名冲突
  - 便于团队协作
如何实现响应式设计？
使用前缀：
＜div class="w-full md:w-1/2 lg:w-1/3"＞
  ＜!-- 在手机上全宽，中等屏幕一半宽，大屏幕1/3宽 --＞
＜/div＞ 
[图片]

七、Next.JS（非常重要）

非常重要。

本章节只是你学习NextJS的指引，并不是NextJS的教程本身。

请你花足够多的时间，沿着指引，去系统性学习NextJS。
- NextJS官方教程 https://nextjs.org/learn/  (这也是学习NextJS最好的教程，可以快速入门，预计需要10小时）
- 视频教程 https://www.youtube.com/watch?v=b4ba60j_4o8&list=PLC3y8-rFHvwhIEc4I4YsRz5C7GOBnxSJY   （详细，预计需要20小时）

怎么才算学会？
- 你本人能够读懂每一行由AI工具生成的代码。
[图片]

7.1 核心概念
NodeJS、npm、NextJS 三者的关系？
[图片]
就像盖房子一样！
想象你要建一座房子，这三个东西就是这样的关系：

NodeJS：地基和框架
- 这就像房子的地基和主体框架
- 提供了坚实的基础，让一切能够运行
- 没有它，其他部分都无法存在

NPM：工具箱和建材商店
- 这就像你的工具箱和一家便利的建材商店
- 当你需要门窗、瓷砖或其他配件时，NPM 帮你找到并安装它们
- 它让你不用自己制造每一个零件，可以直接使用别人做好的部分

NextJS：预制的房屋设计
- 这就像是一个现成的房屋设计方案
- 已经帮你规划好了房间布局、门窗位置等
- 让你不必从零开始设计，省时又省力

它们如何一起工作？
1. 首先安装 NodeJS（打好地基）
2. NodeJS 自带 NPM（有了工具箱和建材商店）
3. 用 NPM 安装 NextJS（选用一个预制的房屋设计）
4. 然后开始建造你的网站，需要什么额外的功能，就用 NPM 去"购买"

7.1.1 小时入门 NextJS

7.1.1.1  环境准备

- 打开终端，输入npx create-next-app@latest，点击回车
[图片]
- 一直点击回车，都选默认项
[图片]
- 等待项目创建完成，记住项目的存储路径
[图片]
- 打开 Cursor，打开项目(Open project)
[图片]
- 选择刚刚创建的文件存储路径
[图片]
- 查看已经创建的Next.JS项目
[图片]

重点关注：
- APP文件夹
  - 解释：它是 Next.js 中路由的核心所在。在这个文件夹下，每个文件或文件夹都对应一个页面路由。例如，创建一个 home.js（或 home.tsx 等 ）文件在 app 文件夹下，就可以通过浏览器访问对应的首页；如果创建子文件夹，如 app/blog/[slug].js ，可以实现动态路由，用于展示博客详情等。
  - 比喻：相当于你家的 “房间分布图”，每个 “房间”（文件 / 文件夹）都是一个网页。
  - 举例：
    - 创建 app/home.js → 访问 http://localhost:3000 就能看到这个页面。
    - 创建 app/blog/[id].js → 访问 http://localhost:3000/blog/123 会根据 id 动态显示文章。
- public 文件夹
  - 解释：用于存放静态资源，如图像、字体、图标等。在页面中可以通过相对路径直接引用这些资源，例如在组件中使用 ＜img src="/logo.png" alt="公司 logo"＞ ，这里的 logo.png 就可以放在 public 文件夹下。
  - 比喻：像你家的 “公共储物间”，放图片、视频、PDF 等大家都能用的东西。
  - 举例：
    - 把 logo.png 放这里，代码里直接写 ＜img src="/logo.png" /＞ 就能用。
启动开发环境，查看当前界面，终端运行 npm run dev
运行 npm run dev
[图片]
打开http://localhost:3000/ ，查看当前项目页面
[图片]
启动开发环境后，你就可以正常访问 3000 端口网页了，3000 端口是开发中约定俗成的端口，我们会在 Cursor 启动一个终端窗口，来固定启动开发环境。
[图片]

当你的代码发生了更新，比如将主页做成学员欢迎页
让 Cursor 生成代码
[图片]
检查生成的代码
[图片]
无误后点击接受
[图片]
我们可以看到，本次修改的页面文件，在app 文件夹下的 page.tsx 文件，也就是主页
[图片]

让我们回到开发界面，查看当前的代码效果
[图片]

很好，界面已经成功完成了，在这一步，如果你的代码改动比较大，你需要重新启动开发环境
结合我们前面的知识，你需要在开发环境的终端窗口，先结束服务，再重新启动，快捷操作如下
鼠标来到开发环境的终端
[图片]

按住 Ctrl + c ，停止服务
(Windows电脑也是 Ctrl + c )
[图片]
按住方向按键的⬆️，出现上一条指令
[图片]
点击回车，此时开发环境就成功的重新启动了

7.1.1.2  项目结构 & 路由

口诀：文件=路由、文件夹=层级、layout 包壳 page。

├── app/                  # ➜*App Router 核心*
│   ├── layout.tsx        # 所有子路由的根布局
│   ├── page.tsx          # 访问 / 时渲染
│   └── globals.css
├── public/               # 静态资源
├── tsconfig.json
└── tailwind.config.ts


在 Next.JS 项目里，页面路由主要和 app 文件夹相关。打开项目目录，找到 app 文件夹，在里面新建一个文件，比如 about.tsx  。这就相当于创建了一个新的页面，用来展示 about 的内容。
Cursor 描述需求
[图片]
查看代码增加内容
[图片]
查看页面效果
[图片]
知识拆解
- 首先我们在 page 文件夹中，创建了一个 about 文件夹
[图片]

- 接着在 about 文件夹中，创建了 page 文件
[图片]

- 最后在 http://localhost:3000/ 后添加 /about，查看页面
[图片]
我们会使用这种方式，逐步增加网站的子页面。详细讲解下 Next.JS 的文件系统的路由机制

Next.js 会自动将 app 文件夹下的文件和文件夹结构映射为对应的 URL 路径
- 文件夹名对应 URL 路径中的路径段 。创建的 about 文件夹，就对应了 URL 中的 /about 路径部分。
- page 文件是可公开访问的页面组件载体 。当在 about 文件夹中创建 page 文件时，它所导出的 React 组件内容，会被渲染到与该文件夹对应的 URL 路径页面上。比如 about/page.tsx 中导出的组件，会在访问 /about 时展示给用户。page文件就像是一个 “页面内容提供者” ，告诉浏览器在对应的 URL 路径下要显示什么。

7.1.1.3 组件

NextJS 里有两种组件(Components)，分别是服务端组件和客户端组件。
NextJS默认 Server Components，仅在需要浏览器交互时才标注 "use client"。

服务端组件(Server Components)
特点：
- 运行在 Node 边缘 / Serverless。
- 可直接调用后端 SDK、数据库、文件系统。
- 生成纯 HTML，体积小，SEO 友好。
// app/users/page.tsx   (Server 组件)
import { fetchUsers } from "@/lib/api";

export default async function Users() {
  const users = await fetchUsers();        // 直接 await
  return (
    ＜ul＞
      {users.map(u =＞ ＜li key={u.id}＞{u.name}＜/li＞)}
    ＜/ul＞
  );
}

客户端组件 (Client Components)
"use client";

import { useState } from "react";

export default function Counter() {
  const [n, setN] = useState(0);
  return (
    ＜button
      className="rounded bg-blue-600 px-3 py-1 text-white"
      onClick={() =＞ setN(n + 1)}
    ＞
      点击 {n}
    ＜/button＞
  );
}

共享布局 layout.tsx
// app/layout.tsx
export const metadata = { title: "一小时 Next.js" };

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    ＜html lang="zh"＞
      ＜body className="prose mx-auto p-4"＞{children}＜/body＞
    ＜/html＞
  );
}

让我们先创建一个公共 component，点击后有页面的交互动效
Cursor 描述需求
[图片]

查看代码修改
[图片]
[图片]
查看界面效果
[图片]
[图片]


接下来我们将解析代码，首先看 Cursor 生成的这个公共组件
[图片]
我们可以看出，这个是签到按钮，具备了两种形态（签到/已签到）

查看 app 文件夹下的page，我们会发现，在最上方引入了创建的公共组件，并且添加了一个 div 用于展示
[图片]
[图片]

在 app/about 文件夹下的 page 文件同理
[图片]
因此，用这种方法，能够复用功能完好的组件，加速开发流程

7.1.1.4 数据获取

如果在Server Component里，可以直接使用fetch()函数获取数据、以及调用API。
// app/api-example/page.tsx
export default async function ApiExample() {
  const res = await fetch("https://jsonplaceholder.typicode.com/users", {
    // 缓存 60 秒，等同 ISR
    next: { revalidate: 60 }
  });
  const users: { id: number; name: string }[] = await res.json();

  return (
    ＜ul className="list-disc pl-5"＞
      {users.map(u =＞ (
        ＜li key={u.id}＞{u.name}＜/li＞
      ))}
    ＜/ul＞
  );
}

如果是在Client Component里，可以使用Ajax的方式获取数据。

要点
- "use client" —— 声明这是 Client Component。
- 用 useEffect 把网络请求放到浏览器执行，避免 SSR 时跑两遍。
- 本地维护 loading / error / data 三态即可；初学者先别上管理库。
- 与 Server 组件不同，这里无法使用 revalidate 等 Next.js 缓存指令，完全由浏览器缓存策略决定。
"use client";

import { useEffect, useState } from "react";

type User = { id: number; name: string };

export default function UsersClient() {
  const [users, setUsers]   = useState＜User[]＞([]);
  const [loading, setLoading] = useState(true);
  const [error, setError]     = useState＜Error | null＞(null);

  useEffect(() =＞ {
    fetch("https://jsonplaceholder.typicode.com/users")
      .then(r =＞ {
        if (!r.ok) throw new Error("请求失败");
        return r.json();
      })
      .then((data: User[]) =＞ setUsers(data))
      .catch(err =＞ setError(err))
      .finally(() =＞ setLoading(false));
  }, []);           // 只在首屏执行一次

  if (loading) return ＜p＞加载中…＜/p＞;
  if (error)   return ＜p className="text-red-600"＞出错：{error.message}＜/p＞;

  return (
    ＜ul className="list-disc pl-5"＞
      {users.map(u =＞ (
        ＜li key={u.id}＞{u.name}＜/li＞
      ))}
    ＜/ul＞
  );
}

7.1.1.5 public目录

在 Next.js 中，public 文件夹是一个特殊的目录，用于存放不需要经过 Webpack 等构建工具处理的静态资源。这些资源可以直接通过 URL 访问，是项目中存放公开静态文件的标准位置。

让我们在项目中，添加一个图片
Cursor 描述需求
[图片]
查看代码修改
[图片]
查看界面效果
[图片]
代码解析
首先在 public 中添加了一张 1 图片
[图片]
在 app 文件夹下的 page 实现导入
[图片]
[图片]
以上就是在做产品中，添加图片的方式，当你的产品逐渐功能开始完善，你将会在 public 中创建多层文件夹，来管理你的各项图片

7.1.1.6 内置优化 & 资源管理

NextJS 把性能优化做成了「默认开启」。只要用对官方组件，就能自动获得更小的包体、更快的首屏和更好的 SEO。下面列出初学者需要优先关注的4 个点——图片、链接、字体、元数据——每个都配一段可直接复制的代码。
＜Image＞—— 响应式图片 & 自动压缩
import Image from "next/image";

// pages 或 app 组件里
export default function Hero() {
  return (
    ＜Image
      src="/banner.jpg"        // 本地 /public 里的资源
      alt="首页横幅"
      width={1200} height={400}  // 固定基准尺寸
      sizes="100vw"              // 告诉浏览器在各断点占满宽度
      priority                  // 首屏优先加载
      placeholder="blur"        // 先用模糊占位
      className="rounded-xl"
    /＞
  );
}
- 自动格式转换：支持 AVIF/WebP，依据浏览器能力回落到 JPEG/PNG。
- 多尺寸裁切：只下载当前视口需要的尺寸，移动端节省流量。
- 远程图片：在 next.config.js 里 images.remotePatterns 白名单即可。

＜Link＞—— 预取 & 无刷新跳转
import Link from "next/link";

＜Link href="/pricing" prefetch＞价格计划＜/Link＞

prefetch 默认就开（视口内自动），当链接滚入可视范围时提前把目标页面 HTML + JS 都下载好；点击几乎 0 延迟。

next/font —— 零 FOIT/FOUC 的可变量字体
// app/layout.tsx
import { Inter } from "next/font/google";

const inter = Inter({
  subsets: ["latin"],
  variable: "--font-inter",
  display: "swap"           // 避免闪白
});

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    ＜html lang="zh" className={inter.variable}＞
      ＜body＞{children}＜/body＞
    ＜/html＞
  );
}
- 字体文件 按需子集化，只打包用到的字形。
- 自动加 preload/font-display，首屏不闪。
- 也支持本地字体：next/font/local({ src: "./AlibabaSans.woff2" })。

元数据 & SEO —— metadata / generateMetadata
// app/blog/[slug]/page.tsx
export const revalidate = 60;  // ISR

export async function generateMetadata({ params }) {
  const post = await fetchPost(params.slug);
  return {
    title: post.title,
    description: post.excerpt,
    openGraph: {
      images: post.cover
    }
  };
}
- Next .js 会把返回值注入 ＜head＞，同时输出到 /_next/data/*.json 供客户端水合。
- 动态页面也能静态化：结合 revalidate，既有 SEO 又可频繁更新。
- 支持 Twitter Card、robots、viewport… 一律类型安全。

7.1.2 二十小时精通 Next.JS

- 创建一个 Next.JS 文件
1.在 vscode/Cursor 打开想要新建 Next.JS 的文件
[图片]
2.并在该文件内新建一个终端并打开
[图片]
3.输入 npx create-next-app@latest
[图片]
4.按下图设定 yes/no（通过键盘左右键切换）
[图片]
5.即可在以下路径找到你的文件
[图片]

6.即可看到你创建的 nextJS 程序啦～
[图片]
- 运行 Next.JS
  1. cd 到项目文件夹，再输入npm run dev
[图片]
    - npm run dev 和 npm run build 区别总结：
命令
作用
适用环境
主要特点
npm run dev
运行本地开发服务器
 开发环境
热重载、实时编译、调试友好
npm run build
构建优化后的静态文件
生产环境
代码压缩、优化、打包成可部署版本
  2. 然后在浏览器中转到 http://localhost:3000/ ，您将可以看到 Next.JS 为您设置的样式
[图片]
- Page（页面）
比喻：房间
  - 每个页面就像房子里的一个房间，有特定的用途和内容
  - 你可以从一个房间走到另一个房间（导航）
[图片]
你可以在这里发现"app"等文件夹，其中 app 文件夹包含全局 CSS 文件中的所有页面和组件。
  - 如果仔细观察，就会发现有一个名为"page.tsx"的 JavaScript 文件。打开它时，您将看到我们最初启动 NextJS 应用时出现的样式页面代码。
[图片]
[图片]
[图片]
- API 路由
  - Next.JS 使用 app router（应用程序路由器），并用文件夹定义路由。即：Next.JS 的 API 路由本质上是一个基于文件系统的路由，每个文件都代表一个 API 端点。
- 比喻：传话员
  - 就像一个传话员，负责在前台（前端）和后厨（后端）之间传递信息
  - 顾客（用户）通过传话员点餐，厨师（服务器）通过传话员送出菜品
1. 例如 page.tsx 位于我们的 app 文件夹中，这使得我们的 page.tsx 成为主页，可通过 http://localhost:3000/ 访问。
[图片]

2. 此时，如果我们想去 localhost 3000/about
  - 只需要在 app 文件夹中创建一个新文件夹，并将其命名为"about"，再在"about"文件夹中创建一个名为"page.tsx"的新文件。这将是"about"路由对应的页面 http://localhost:3000/about
[图片]
  - 如果你想在"about"目录中添加更多嵌套路由，可以使用相同的逻辑。先在"about"文件夹内创建一个新的文件夹“projects”，再这个文件夹下创建一个名为"page.tsx"的新文件。

3. 如果您想创建部分 URL 是动态的路由，只需在文件夹中使用方括号。
- 如："localhost:3000/about/projects/[projectId]"
  1. 在"projects"文件夹中，创建一个为“[projectId]”的文件夹。这将允许您捕获 URL 的 [projectId] 动态部分作为参数。
  2. 这样，如果你导航到  localhost:3000/about/projects/  后跟任意数字或单词，例如 123（localhost:3000/about/projects/123），它将提供"projectId"文件夹内的 page.tsx 文件。
[图片]
  3. params（参数）：在页面内部，我们可以访问关键字"params（参数）"，"params"对象用于捕获 Next.JS 中的动态路由参数，特别是在处理动态路线时。
    1 在我们的示例中，代码引用了动态路由，localhost:3000/about/projects/[projectId],在这种情况下，"projectId"是 URL 的动态部分，并且 Next.JS 在访问路由时会自动用相应的值填充"params"对象，即 project Id: 123
const page = ({ params }) =＞ {
    return ＜div＞project Id: {params.projectId}＜/div＞;
    };
    export default page;
    2 假设您想根据"projectId"从 API 或数据库中获取项目详细信息。您可以使用"params"对象来访问项目 ID，然后调用接口以检索该特定项目的数据。
const ProjectPage = async ({ params }) =＞ {
//获取服务器上的项目数据
const response = await fetch(`/API/projects/${params.projectid}`);
const projectData = await response.JSon();
    - 动态路由非常适用于具有单个实体页面的应用，例如博客文章、产品或用户资料，这些页面数据经常变化但布局或设计保持一致。
    - 如果没有动态路由，您将需要为每个实体手动创建单独的页面，这导致大量静态页面，维护既耗时又难以扩展。

- 布局系统（Layouts 文件）
- 比喻：房子的框架结构
  - 就像房子的墙壁和走廊，决定了各个房间如何连接
  - 所有房间共享同样的屋顶和地基（页眉、页脚）
[图片]
  - 在 Next.JS 中，布局是一种在应用程序的不同页面之间共享一致 UI 的方式，只需将布局视为页面的模板（Templates）即可。
RootLayout（根布局）：在代码中，该布局的文件由 Next.JS 自动生成，它采用"children"参数。
[图片]
这意味着这个布局模板将适用于任何地方，无论是在"home"目录（http://localhost:3000/）还是"about"目录（http://localhost:3000/about）。
布局文件通常用于需要出现在每个页面上的元素，例如导航栏、页脚和侧边栏。这可以防止重复并确保 UI 保持一致。
[图片]
- 字体
  - 如果我们去检查我们的网站，我们可以看到字体、Geist Mono 和 sans 已经实现。
[图片]
  提供一个例子～：假设您不知道，它已经包含 Google 字体。您想导入"inter"作为您的字体，可以从"next/font/google 目录中获取它，然后创建一个常量，再在类名中应用它，就可以使用全局 CSS 来设置字体。
//从"next/font/google目录中获取inter
import { Inter }from "next/font/google";

//创建一个常量
const inter=Inter({
    subsets: ["latin"],  //只会加载拉丁字符，减少不必要的字体文件，提高性能。
    display: "swap",  //加载策略，先用系统字体，加载完成后替换为 Inter，避免空白问题。
});

//把 inter.className 应用到 ＜HTML＞ 标签,使整个页面都会继承 Inter 字体。
export default function RootLayout({ children}) {
  return (
  ＜HTML lang="en" className={inter.className}＞
  ＜body＞
  ＜Navbar/＞
  {children}
  ＜/body＞
  ＜/HTML＞
  );
}
  
- 元数据
  - 有助于向浏览器和搜索引擎描述、解释或提供有关网页的背景。这反过来又使页面 SEO 对搜索引擎更友好，使其能够索引你的页面，并在搜索结果中正确显示。
  A. 例如，在项目页面中，我们希望该页面具有适当的标题和描述以及元数据，要在"项目"页面中声明元数据，我们只需输入export const metadata={}；，该对象里面是标题和描述，您还可以列出与页面内容和作者相关的关键字列表。
[图片]
export const metadata ={
    title: "My Next.JS App",
    description: "This is a description of my Next.JS app.",
    keywords: ["Next.JS", "react", "seo"],
    author: "Your Name",
};
  
  B. 如果我们处理的是不同项目的动态数据（例如[projectld]文件夹中的数据），不能对每个元数据都进行硬编码，可以引入动态元数据。
  - 动态元数据：依赖于不断变化的信息，例如当前路径参数，外部数据，或者来自父段的元数据。可以通过导出一个返回元数据对象的 generateMetadata 函数来进行配置。
export async function generateMetadata({ params}, parent) {
    const { projectld } = params;
    const product = await fetch(`https://.../${projectid}`).then((res) =＞res.JSon())
    return {
    title: product.title,
    description: product.description,
    };
}
- 以上代码的作用为：
  - 这个 generateMetadata 函数的作用是根据当前页面的 URL 参数动态生成元数据，比如 title 和 description。
  - 它会从 API 获取数据，然后返回页面的元信息。
  - 适用于 SEO（搜索引擎优化），让不同的项目页面有不同的 title 和 description，提升网页的搜索引擎排名。

- 组件（Components）
小组件可以组成更大的组件（树状结构）
- Next.JS 的组件就像乐高积木，你可以用它们搭建整个网站
- 服务器组件和客户端组件：Next.JS 中的两个主要类型组件

NextJS 将服务器组件设置为默认组件。通过服务器和客户端组件的组合，Next，JS 可以创建高效的应用程序，有效的平衡速度和交互性。
1. 服务器组件会在服务器上呈现，并向客户端发送静态 HTML（例如直接从服务器获取的标题或数据。），通过减少 JavaScript 包的大小和数量，以缩短加载时间、更快地传递内容。
  - 服务器组件比喻：由工厂预先组装好的积木套装，顾客拿到手就可以直接使用，不需要自己组装（减少客户端 JavaScript）
2. 客户端组件可以处理用户交互，如按钮、表格或动画；或使用状态、效果和事件监听器，这意味着他们可以向用户提供即时反馈并更新 UI。
  - 客户端组件比喻：需要顾客自己组装的积木，但能实现更多互动功能（比如积木可以旋转、发光）

- 如何组合应用客户端组件和服务端组件：
  - 通过仅在必要时选择性地使用客户端组件，Next.JS 优化了应用程序的性能，同时仍提供了响应迅速、交互式的用户体验。
  - 服务器组件和客户端组件在 Next.JS 中协同工作时，服务器端渲染，加快初始加载时间，并将 SEO 优化与客户端交互相结合，实现动态丰富的用户体验。
  - 通过适当分离关注点，将繁重的任务转移到服务器上，并使用客户端进行交互，确保性能和用户体验都得到优化，从而实现速度更快、更具可扩展性的网络应用程序。

- 将服务器组件转换为客户端组件的方式：
  - 只需在文件的第一行添加带有双引号的使用客户端即可。
    - 注意：
      1. 机密数据不要放到客户端使用，避免数据泄露
      2. 服务器没有浏览器状态，部分组件只能运行在客户端（比如输入框的整个组件）
 "use client"

举个几个例子：

1. 简单的函数组件：
// components/Hello.tsx
import React from 'react';

// 定义一个简单的函数组件
const Hello = () =＞ {
  return ＜h1＞Hello, Next.JS!＜/h1＞;
};

export default Hello;
  -  解释：
    - import React from 'react';：引入 React，这是 Next.JS 中写组件的必要操作。
    - const Hello = () =＞ {}：这是一个函数组件，名字叫 Hello。
    - return ＜h1＞Hello, Next.JS!＜/h1＞;：它返回一个简单的 HTML 标题标签 ＜h1＞，并在页面上显示文字“Hello， Next.JS！”. 
    - export default Hello;：这行代码导出组件，方便在其他文件中引用。
  1. 如何使用这个组件：
// pages/index.tsx
import Hello from '@/components/Hello';

// 使用 Hello 组件
export default function Home() {
  return (
    ＜div＞
      ＜Hello /＞
    ＜/div＞
  );
}
    -  解释：
      - import Hello from '@/components/Hello';：引入我们刚刚创建的 Hello 组件。
      - ＜Hello /＞：像 HTML 标签一样使用组件，这是 React 的组件语法。
      - 页面上会显示：Hello， Next.JS！
2. 带 Props 的组件
// components/Greeting.tsx
import React from 'react';

// 定义 Props 类型
type GreetingProps = {
  name: string;
};

// 定义带有 Props 的组件
const Greeting: React.FC＜GreetingProps＞ = ({ name }) =＞ {
  return ＜h1＞Hello, {name}!＜/h1＞;
};

export default Greeting;
  - 解释：
    - Props：是组件的“属性”，类似于 HTML 标签的属性。通过 Props 可以向组件传递数据。
    - type GreetingProps = { name: string; };：定义了 Props 的类型，确保 name 只能是字符串。
    - { name }：在函数参数中解构出 name 属性。
    - ＜h1＞Hello, {name}!＜/h1＞：通过 {name} 动态显示传入的名字。
  1. 如何使用带 Props 的组件：
// pages/index.tsx
import Greeting from '@/components/Greeting';

// 使用 Greeting 组件，并传入不同的名字
export default function Home() {
  return (
    ＜div＞
      ＜Greeting name="Alice" /＞
      ＜Greeting name="Bob" /＞
    ＜/div＞
  );
}
    
    - 解释：
      - ＜Greeting name="Alice" /＞：给组件传递一个 name 属性，值是 "Alice"。
      - ＜Greeting name="Bob" /＞：再传递一个 name 属性，值是 "Bob"。
Hello, Alice!
Hello, Bob! 
3. 使用状态的组件
// components/Counter.tsx
import React, { useState } from 'react';

// 定义一个计数器组件
const Counter: React.FC = () =＞ {
  const [count, setCount] = useState(0);

  return (
    ＜div＞
      ＜p＞当前计数: {count}＜/p＞
      ＜button onClick={() =＞ setCount(count + 1)}＞增加＜/button＞
    ＜/div＞
  );
};

export default Counter;
  - 解释：
    - useState(0)：useState 是 React 的 Hook，用来创建一个状态变量。这里 count 的初始值是 0。
    - setCount(count + 1)：点击按钮时，setCount 会把 count 的值加 1，触发页面更新。
    - ＜p＞当前计数: {count}＜/p＞：通过 {count} 动态展示当前的计数。
    - ＜button＞：点击按钮后执行 onClick 事件，更新 count。
  1. 如何使用这个组件：
// pages/index.tsx
import Counter from '@/components/Counter';

export default function Home() {
  return (
    ＜div＞
      ＜Counter /＞
    ＜/div＞
  );
}
    
    - 解释：
      - 页面加载时，count 的初始值是 0。
      - 每点击一次按钮，数字就会加 1。
      - 页面显示类似：
当前计数: 0
[增加]
4. 页面组件和路由
// pages/about.tsx
export default function About() {
  return ＜h1＞关于我们＜/h1＞;
}
- 解释：
  - 在 Next.JS 中，pages 文件夹中的每个 .tsx 文件都会自动变成一个页面。
  - export default function About()：这是一个页面组件，表示 /about 路由。
  - ＜h1＞关于我们＜/h1＞：这是页面上的内容。
- 如何访问：
  - 启动你的 Next.JS 项目后，访问 http://localhost:3000/about。
  - 页面会显示：关于我们
  
5. 组件组合：布局组件
// components/Layout.tsx
import React from 'react';

type LayoutProps = {
  children: React.ReactNode; // 接收子组件
};

// 创建一个布局组件
const Layout: React.FC＜LayoutProps＞ = ({ children }) =＞ {
  return (
    ＜div＞
      ＜header＞网站头部＜/header＞
      ＜main＞{children}＜/main＞
      ＜footer＞网站底部＜/footer＞
    ＜/div＞
  );
};

export default Layout;
- 解释：
  - LayoutProps：定义 Props 的类型，children 是 React 内置的属性，用于嵌套其他组件。
  - {children}：表示组件中嵌套的内容。
  - ＜header＞ 和 ＜footer＞：布局的固定部分，类似网页的导航栏和页脚。
  
6. 如何使用布局组件：
// pages/index.tsx
import Layout from '@/components/Layout';

export default function Home() {
  return (
    ＜Layout＞
      ＜h1＞欢迎来到我的网站！＜/h1＞
    ＜/Layout＞
  );
}
  
  - 解释：
    - ＜Layout＞：使用布局组件，将内容包裹在它的 children 中。
    - ＜h1＞欢迎来到我的网站！＜/h1＞：这个内容会显示在 ＜main＞ 标签内。
    - 页面显示：
网站头部
欢迎来到我的网站！
网站底部
    
- 中间件（Middleware）
- 比喻：门卫/安检
  - 在访客进入建筑前进行身份检查、引导方向
  - 可以决定是放行、拒绝还是引导到其他地方
  - 中间件是在页面或 API 路由被访问之前执行的代码。可以用来处理认证、重定向、日志记录等。
  - 中间件在服务器端执行，在页面或 API 路由被处理前拦截请求，可以修改响应或执行其他操作。
// middleware.JS (放在项目根目录)
export function middleware(request) {
  const currentUrl = new URL(request.url)
  
  // 检查用户是否已登录，否则重定向到登录页
  if (currentUrl.pathname.startsWith('/dashboard') && !isAuthenticated()) {
    return NextResponse.redirect(new URL('/login', request.url))
  }
  
  // 为请求添加自定义头部
  const response = NextResponse.next()
  response.headers.set('x-custom-header', 'my-value')
  return response
}

// 配置中间件应用的路径
export const config = {
  matcher: ['/dashboard/:path*', '/API/:path*'],
}
  
- 环境变量
- 比喻：私密保险箱
  - 保存各种敏感信息的保险箱，里面存放钥匙、密码等
  - 根据不同场合（开发、生产环境）使用不同的保险箱
  - 环境变量用于存储配置信息，如 API 密钥、数据库连接字符串等。
# .env.local 文件
DATABASE_URL=postgres://user:password@localhost:5432/mydb
API_KEY=my-secret-API-key

# .env.development 文件 (开发环境变量)
NEXT_PUBLIC_API_URL=http://localhost:3000/API

# .env.production 文件 (生产环境变量)
NEXT_PUBLIC_API_URL=https://myapp.com/API

在代码中使用环境变量：
// 服务器端可以访问所有环境变量
console.log(process.env.DATABASE_URL)
console.log(process.env.API_KEY)

// 客户端只能访问NEXT_PUBLIC_开头的环境变量
console.log(process.env.NEXT_PUBLIC_API_URL)

- 边缘运行时（Edge Runtime）
- 比喻：本地快递站点
  - 不是从总部发货，而是从离客户最近的分站发货，送达更快
  - 适合处理简单但需要快速响应的任务
  - 边缘运行时是一个轻量级的 JavaScript 环境，在离用户最近的服务器上运行，提供更快的响应时间。
  - 边缘运行时适合用于不需要完整 Node.JS 功能的简单 API，如地理位置检测、简单身份验证等。
// app/API/edge/route.JS
export const runtime = 'edge' // 声明使用边缘运行时

export async function GET() {
  return new Response(JSON.stringify({ message: '这是边缘API' }), {
    headers: { 'content-type': 'application/JSon' },
  })
}
- 数据获取方法
- 比喻：不同的采购方式
  - 直接使用 fetch：亲自去市场采购新鲜食材
  - 缓存策略：有些食材可以批量购买并储存一段时间，有些则需要每天新鲜采购
  - SSG 和 SSR：有些菜可以提前做好（SSG），有些需要客人来了才现做（SSR）
  - Next.JS 提供了多种数据获取方式：
1. Server Components 中的数据获取：
// app/users/page.JS
async function getUsers() {
  const res = await fetch('https://API.example.com/users')
  return res.JSon()
}

export default async function UsersPage() {
  const users = await getUsers()
  
  return (
    ＜div＞
      ＜h1＞用户列表＜/h1＞
      ＜ul＞
        {users.map(user =＞ (
          ＜li key={user.id}＞{user.name}＜/li＞
        ))}
      ＜/ul＞
    ＜/div＞
  )
}
2. 客户端数据获取 （SWR 或 React Query）
'use client'

import { useState, useEffect } from 'react'
import useSWR from 'swr'

const fetcher = (...args) =＞ fetch(...args).then(res =＞ res.JSon())

export default function ProfilePage() {
  const { data, error, isLoading } = useSWR('/API/profile', fetcher)
  
  if (isLoading) return ＜div＞加载中...＜/div＞
  if (error) return ＜div＞加载失败＜/div＞
  
  return (
    ＜div＞
      ＜h1＞{data.name}的个人资料＜/h1＞
      ＜p＞邮箱: {data.email}＜/p＞
    ＜/div＞
  )
}

- 渲染策略
- 比喻：餐厅供餐方式
  - 静态生成：自助餐，提前做好所有菜品，客人来了直接取用（最快）
  - 服务器端渲染：点菜后厨房现做，端上来就能吃（平衡新鲜和速度）
  - 客户端渲染：送来食材和菜谱，客人自己在桌上烹饪（最灵活但初始加载慢）
  - 增量静态再生成：自助餐定时更换新鲜菜品，保持食物新鲜但不用每位客人都等待
  - Next.JS 支持多种渲染策略：
[图片]
1. 静态生成 （Static Generation）
  页面在构建时生成，适合内容不经常变化的页面。
// app/blog/[slug]/page.JS
export async function generateStaticParams() {
  const posts = await getPosts()
  
  return posts.map((post) =＞ ({
    slug: post.slug,
  }))
}

export default async function BlogPost({ params }) {
  const post = await getPostBySlug(params.slug)
  
  return (
    ＜article＞
      ＜h1＞{post.title}＜/h1＞
      ＜div＞{post.content}＜/div＞
    ＜/article＞
  )
}
2. 服务器端渲染 （Server-Side Rendering）
  每次请求时在服务器上渲染页面。
// app/dashboard/page.JS
export const dynamic = 'force-dynamic' // 强制SSR

export default async function Dashboard() {
  const data = await fetch('https://API.example.com/dashboard', 
    { cache: 'no-store' }) // 不缓存
  const dashboardData = await data.JSon()
  
  return (
    ＜div＞
      ＜h1＞仪表盘＜/h1＞
      ＜p＞当前时间: {new Date().toLocaleTimeString()}＜/p＞
      {/* 显示实时数据 */}
    ＜/div＞
  )
}
3. 增量静态再生成 （ISR）
  静态页面可以在后台重新生成，兼顾性能和新鲜度。
 // app/products/[id]/page.JS
export default async function Product({ params }) {
  const product = await fetch(`https://API.example.com/products/${params.id}`,
    { next: { revalidate: 3600 } }) // 1小时后重新验证
  const data = await product.JSon()
  
  return (
    ＜div＞
      ＜h1＞{data.name}＜/h1＞
      ＜p＞价格: ${data.price}＜/p＞
    ＜/div＞
  )
}

- Streaming 与 Suspense
比喻：餐厅分批上菜
  - 不用等所有菜都做好才开始吃，先上好的先吃
  - 等慢菜时有临时的小吃垫垫肚子（加载状态）
[图片]
  - Streaming 允许服务器组件逐步发送 UI 片段，而不是等待所有数据加载完成。结合 Suspense 可以实现更好的加载体验。
  - Streaming 和 Suspense 的主要优点是可以提高首次内容绘制（FCP）的速度，优先加载关键内容，同时为其他部分显示加载状态。
// app/dashboard/page.JS
import { Suspense } from 'react'
import UserProfile from './user-profile'
import RecentActivity from './recent-activity'
import RecommendedPosts from './recommended-posts'

export default function Dashboard() {
  return (
    ＜div＞
      ＜h1＞控制面板＜/h1＞
      
      {/* 用户资料会立即加载 */}
      ＜UserProfile /＞
      
      {/* 活动记录会展示加载状态，然后在数据准备好时显示 */}
      ＜Suspense fallback={＜div＞加载活动记录中...＜/div＞}＞
        ＜RecentActivity /＞
      ＜/Suspense＞
      
      {/* 推荐文章会在最后加载，但不会阻塞页面其他部分 */}
      ＜Suspense fallback={＜div＞加载推荐中...＜/div＞}＞
        ＜RecommendedPosts /＞
      ＜/Suspense＞
    ＜/div＞
  )
}
- 动态导入（Dynamic Imports）
- 比喻：按需购买家具
  - 搬进新家时，不是一次买齐所有家具，而是住进去后根据需要逐渐添置
  - 减轻初始负担，提高启动速度
  - 动态导入允许代码分割，只在需要时加载特定组件，提高应用性能。
  - 动态导入的好处：
    - 减小初始包体积
    - 按需加载组件
    - 可以结合 Suspense 实现更好的加载体验
// app/page.JS
import { Suspense } from 'react'
import dynamic from 'next/dynamic'

// 动态导入重量级组件
const HeavyChart = dynamic(() =＞ import('../components/heavy-chart'), {
  loading: () =＞ ＜p＞加载图表中...＜/p＞,
  ssr: false // 仅客户端渲染，不在服务器端渲染
})

// 动态导入普通组件
const Comments = dynamic(() =＞ import('../components/comments'))

export default function HomePage() {
  return (
    ＜div＞
      ＜h1＞首页＜/h1＞
      ＜p＞这部分内容会立即加载＜/p＞
      
      ＜Suspense fallback={＜div＞加载评论中...＜/div＞}＞
        ＜Comments /＞
      ＜/Suspense＞
      
      ＜Suspense fallback={＜div＞加载图表中...＜/div＞}＞
        ＜HeavyChart /＞
      ＜/Suspense＞
    ＜/div＞
  )
} 
- Next.JS 概念之间的关系
[图片]
- 数据流动关系
[图片]
- 性能优化关系（快递比喻）
[图片]
Next.JS 核心思想总结
[图片]
所有这些概念就像齿轮一样彼此啮合，共同驱动一个快速、灵活且开发友好的 web 应用。无论你是构建简单博客还是复杂电商网站，这些概念都以不同方式组合，解决各种实际问题。

（附）学习资源
- Next.JS 官方文档
- Next.JS 学习课程
- Vercel 示例库

7.2 实战项目

7.2.1 入门项目
尝试基于本课程进阶篇中的的 starter 框架，开发一个自己的产品

7.2.2 项目升级：结业产品
在整体学习完课程后，可将课程的知识（产品 idea、如何做成功的网站等）融入，开发一个成熟的结业产品


[图片]

八、shadcn/ui

shadcn/ui 不是传统意义上的 NPM 组件库，而是一套“把源码复制进你项目”的 Open Code 组件模板集合

8.1 核心概念

在 React 生态里，我们常见的组件库（MUI、Ant Design 等）把组件代码封装在包里，你只能通过 props 做有限定制。

而 Shadcn UI 把组件源码直接复制进你的项目，你对每个 className、每个 JSX 结构都拥有 100 % 的掌控权。

这种“开放源码-即拿即改”的模式被作者称为 Open Code。

更改样式或逻辑时，你只是在维护自己的代码，不存在“升级冲突”或“魔改难合并”的尴尬。
它不是一个组件库
shadcn/ui 是一组可复用的组件集合 
传统组件库如 Material UI, Ant Design, Chakra UI 等，你通常通过 npm install a-component-library 来安装，然后在你的代码里 import { Button } from 'a-component-library'

传统组件的代码通常在 node_modules 里，你无法直接修改它们（除非 fork）
它的工作方式是：你通过一个 CLI (命令行工具) 将组件的源代码直接复制到你的项目中。这些组件文件 (比如 button.tsx, dialog.tsx) 会真实地存在于你的项目目录中 (通常在 components/ui/ 下)

你拥有这些代码，可以随意修改、定制，就像你自己写的一样
shadcn/ui 有三个底层依赖
- Tailwind CSS：用原子类快速定制 UI。我们在前面的课程已经介绍过了。
- Radix Primitives：保证可访问性（ARIA、键盘交互）
- Lucide-react：一致风格的 SVG 图标。

8.1.1 初始化

你可以新建一个NextJS项目
npx create-next-app@latest shadcn-demo --typescript --app
cd shadcn-demo
[图片]

为了方便查看和学习，我们可以用Cursor打开刚刚新建的项目。可以看到这是一个标准的NextJS项目。
[图片]

然后进入到项目工作目录中，执行以下指令，初始化shadcn/ui
过程中，会提示一些个性化话的选择。如果不想选，可以全部点击回车。
npx shadcn@latest init
[图片]

执行初始化命令后，项目目录中会自动生成生成一些文件。如下图所示，包括utils.ts、components.json 等等。
[图片]

然后回到NextJS项目，执行
npm run dev

你可以尝试打其中的globals.css，把 background 颜色改成 #007aff。 在浏览器访问 http://localhost:3000 ，应该网页背景会马上热更新为蓝色。
[图片]

8.1.2 添加组件

在初始化 shadcn/ui 后，我们就可以在项目中，添加 shadcn/ui 的组件了！

我们可以到 这里 进行挑选，选自己需要的组件！
https://ui.shadcn.com/docs/components/accordion
红框部分都是组件的名字
[图片]

假如我们选好的是下图所示的“card”
https://ui.shadcn.com/docs/components/card
我们只需要在命令行中，执行安装命令（图中红框标识），就可以了
[图片]

当我执行完命令后，注意我的项目结构：已经在 components/ui 下增加了 card.tsx
这就是我们刚刚安装的 shadcn/ui 组件
[图片]

我们可以在任何页面（比如主页），引用它。

引用方法，你可以查看文档里的Example Code  。 
哪个文档？就是刚才，你找到的控件的那个文档。一般来说，控件文档，都会写上Example  Code。https://ui.shadcn.com/docs/components/card

我们直接复制到页面中就可以。 如果遇到ES Linter报错，可以让Cursor直接修改报错。

如下图所示
[图片]

[图片]

8.1.3 日间模式、夜间模式

这一个过程对于新手来说，流程稍多。
你可以先看完下面的指引，有一个初步的理解。然后，直接让Curosr帮你添加夜间模式功能。（实测是可以的）
完成后，你再本着学习的态度，依次去理解Cursor帮你写的代码。

首先，我们需要安装next-thems
还是在刚才的项目中，执行下面的命令
npm install next-themes

我们需要创建theme-provider
components/theme-provider.tsx
"use client"

import * as React from "react"
import { ThemeProvider as NextThemesProvider } from "next-themes"

export function ThemeProvider({
  children,
  ...props
}: React.ComponentProps＜typeof NextThemesProvider＞) {
  return ＜NextThemesProvider {...props}＞{children}＜/NextThemesProvider＞
}
第三步
在app/layout.tsx中，把ThemeProvider用于包裹其他的所有组件
import { ThemeProvider } from "@/components/theme-provider"

export default function RootLayout({ children }: RootLayoutProps) {
  return (
    ＜＞
      ＜html lang="en" suppressHydrationWarning＞
        ＜head /＞
        ＜body＞
          ＜ThemeProvider
            attribute="class"
            defaultTheme="system"
            enableSystem
            disableTransitionOnChange
          ＞
            {children}
          ＜/ThemeProvider＞
        ＜/body＞
      ＜/html＞
    ＜/＞
  )
}
最后，找一个地方，添加模式切换的按钮。
这是我们的components/ThemeToggle.tsx
"use client";

import { useTheme } from "./ThemeProvider";
import { Sun, Moon, Computer } from "lucide-react";

export function ThemeToggle() {
  const { theme, setTheme } = useTheme();

  return (
    ＜div className="flex bg-secondary rounded-lg p-1"＞
      ＜button
        type="button"
        onClick={() =＞ setTheme("light")}
        className={`flex items-center justify-center w-8 h-8 rounded-md transition-colors ${
          theme === "light" ? "bg-primary text-primary-foreground" : "text-secondary-foreground hover:bg-secondary/80"
        }`}
        aria-label="浅色模式"
      ＞
        ＜Sun size={18} /＞
      ＜/button＞
      
      ＜button
        type="button"
        onClick={() =＞ setTheme("dark")}
        className={`flex items-center justify-center w-8 h-8 rounded-md transition-colors ${
          theme === "dark" ? "bg-primary text-primary-foreground" : "text-secondary-foreground hover:bg-secondary/80"
        }`}
        aria-label="深色模式"
      ＞
        ＜Moon size={18} /＞
      ＜/button＞
      
      ＜button
        type="button"
        onClick={() =＞ setTheme("system")}
        className={`flex items-center justify-center w-8 h-8 rounded-md transition-colors ${
          theme === "system" ? "bg-primary text-primary-foreground" : "text-secondary-foreground hover:bg-secondary/80"
        }`}
        aria-label="跟随系统"
      ＞
        ＜Computer size={18} /＞
      ＜/button＞
    ＜/div＞
  );
} 
就可以得到这个效果哦。
[图片]
[图片]
PS：如果你想用Cursor，简单描述就可以了。
但是，请一定要亲自去学习Cursor帮你写的代码哦！
[图片]

8.1.4 切换主题

shadcn/ui有很强的主题生态。

关于shadcn/ui的主题详细说明，你可以到这里官方说明查看，此处不再赘述
https://ui.shadcn.com/docs/theming

当你根据官方文档添加主题功能后，我们可以关注换主题功能。
你可以到 https://tweakcn.com/editor/theme 或者 https://ui.shadcn.com/themes
选择你喜欢的主题，然后复制代码，去修改替换globals.css 中对应的位置。

这个过程，我们在基础篇-第七课里，已经讲过了，这里稍微复习一遍。

不知道怎么替换？也可以借助Cursor。

例如，我们选择了这个红色主题。
（这里需要注意，  你最初安装NextJS的时候，用的是Tailwind v4还是v3版？格式是不一样的。 在我这个示例项目中，我用的是v3）
[图片]

8.2 入门项目

请你为任意一个 Next.JS 项目，添加日间/夜间模式切换功能。

[图片]

九、数据库
此部分为数据库知识讲解，实操部分在【Supabase】章节

一般来说我们使用 PostgreSQL 比较多

9.1 核心概念
数据库是什么

最形象的比喻
- Excel 表格的超级进化版：能存储百万倍的数据，并且多人同时安全使用
- 图书馆管理系统：
  - 书库 = 数据库
  - 图书分类 = 表（用户表/商品表）
  - 图书信息卡 = 表中的记录
  - 管理员 = SQL 查询语言

- 为什么需要数据库？
场景
无数据库
有数据库
存储数据
用 txt 文件记录
专业存储系统
查找信息
全文件扫描
毫秒级检索
多人使用
容易冲突
并发控制
数据安全
易丢失
自动备份
数据库核心概念拆解 

- 表结构详解（以"学生信息表"为例）
| 学号(主键) | 姓名   | 年龄 | 班级      | 入学日期   |
|------------|--------|------|-----------|------------|
| 2023001    | 张三   | 18   | 高一(3)班 | 2023-09-01 |
| 2023002    | 李四   | 17   | 高一(1)班 | 2023-09-01 |

- 字段类型：
  - 整数：年龄
  - 字符串：姓名
  - 日期：入学日期
- 主键：学号（唯一不重复）

- SQL 语言基础语法
-- 增：添加新学生
INSERT INTO 学生表 VALUES (2023003, '王五', 16, '高一(2)班', '2023-09-01');

-- 删：退学学生删除
DELETE FROM 学生表 WHERE 学号=2023002;

-- 改：调换班级
UPDATE 学生表 SET 班级='高一(4)班' WHERE 姓名='张三';

-- 查：找所有17岁以下学生
SELECT * FROM 学生表 WHERE 年龄＜17;

数据库在真实项目中的应用 

- 用户注册流程
sequenceDiagram
    用户-＞＞前端: 填写注册表单
    前端-＞＞后端: 发送注册请求
    后端-＞＞数据库: INSERT INTO users...
    数据库--＞＞后端: 操作结果
    后端--＞＞前端: 返回成功/失败
    前端-＞＞用户: 显示注册结果bb

- 电商网站数据关系
[用户表] -- 1:n --＞ [订单表]
[商品表] -- m:n --＞ [订单表] 通过[订单明细表] B 

[图片]

9.2 实战项目
入门项目
此部分实战，可根据【Supabase】章节中的实操环节。

项目升级：学习 PostgreSQL 数据库FFF
如有余力，可尝试学习 PostgreSQL

[图片]
9.3 常见疑问
问题
答案
主键为什么不能重复？
就像学生的学号/身份证号，重复会导致系统无法区分不同记录
SQL 语句总是写错怎么办？
使用开发工具提示（如 VS Code 的 SQL 插件），记住核心结构：
SELECT [字段] FROM [表] WHERE [条件] ORDER BY [排序] LIMIT [数量]
如何防止数据丢失？
- 定期备份：.dump 命令导出数据
- 事务处理：
BEGIN TRANSACTION;
-- 你的操作...
COMMIT; -- 或 ROLLBACK 回滚
[图片]

十、Supabase

10.1 核心概念
我见过太多技术小白被后端开发这座大山给劝退了，辛辛苦苦学了一堆前端，结果卡在数据库、API、用户系统这些"拦路虎"上。

别急，我要告诉你一个秘密武器——Supabase！这玩意儿简直就是独立开发者的大救星！ 我自己用了三年！
[图片]

为啥我坚定推荐 Supabase？就一个字，爽！
- 起步门槛低到离谱：你敢信？3 分钟就能创建一个生产级数据库！我第一次接触时简直惊呆了，比买个淘宝账号还简单，用户少的时候，还不要钱！
- 全家桶服务：数据库、身份验证（包括登录、注册、社交媒体登录）、存储、实时功能、邮件功能，全都有！别问，问就是"一把梭"，省心！
- 不付钱也能白嫖很久：初期用户少，完全够用。等产品赚钱了，再用它的付费套餐，也不贵；等用户特别多了，还可以考虑自己租用服务器来部署 Supabase 的开源版本，无缝迁移。

核心界面介绍
- 登录后界面：进入组织界面
[图片]
- 进入组织后，查看该组织下的全部项目
[图片]
usage 界面，查看当前用量
[图片]
setting 界面，查看基础设置
[图片]

- 进入项目界面
[图片]
查看数据库表
[图片]
[图片]

创建数据库表
[图片]
[图片]

配置用户登陆
[图片]
[图片]
[图片]

获取数据库配置信息
[图片]
[图片]

推荐一些官方教程
- Supabase 官方入门指南（NextJS 版）
  - https://supabase.com/docs

- Supabase 官方示例代码和教程（NextJS 版）
  - https://supabase.com/docs/guides/getting-started
[图片]
  - 请大家跟着这个链接，一步一步做完。

10.2 实战项目
由于本章节代码量大，环节较多，可直接使用代码复制版本

supabase实战项目-可复制代码版本

入门项目
33
此处为Supabase官方示例代码和教程(NextJS版)
- https://supabase.com/docs/guides/getting-started/tutorials/with-nextjs

助教的代码仓库：https://github.com/dylan-zzm/supabase-nextjs

- 目标描述
This tutorial demonstrates how to build a basic user management app. The app authenticates and identifies the user, stores their profile information in the database, and allows the user to log in, update their profile details, and upload a profile photo. The app uses:
本教程演示了如何构建一个基本的用户管理应用。该应用可以验证和识别用户，将用户资料信息存储在数据库中，并允许用户登录、更新个人资料详情和上传个人照片。该应用使用：
暂时无法在飞书文档外展示此内容

- Project setup  项目设置
  - Create a project#  创建项目#
1. Create a new project in the Supabase Dashboard.
在 Supabase 仪表板中创建一个新项目。
2. Enter your project details.
输入您的项目详细信息。
3. Wait for the new database to launch.
等待新数据库启动。
[图片]
  
  - Set up the database schema# 设置数据库模式
1. Go to the SQL Editor page in the Dashboard.
前往仪表板中的 SQL 编辑器页面。
2. Click User Management Starter.
点击用户管理入门
3. Click Run.  点击运行

[图片]

  SQL代码  -  代码的目的是创建 profiles 表（用于存储用户的公开资料）
  
  代码中的RLS 是 Postgres（也就是 Supabase 底层数据库）提供的安全机制。
  启用后，数据的访问受策略控制，未定义策略前，默认所有数据不可访问。
```sql
-- Create a table for public profiles
create table profiles (
  id uuid references auth.users not null primary key,
  updated_at timestamp with time zone,
  username text unique,
  full_name text,
  avatar_url text,
  website text,

  constraint username_length check (char_length(username) >= 3)
);
-- Set up Row Level Security (RLS)
-- See https://supabase.com/docs/guides/database/postgres/row-level-security for more details.
alter table profiles
  enable row level security;

create policy "Public profiles are viewable by everyone." on profiles
  for select using (true);

create policy "Users can insert their own profile." on profiles
  for insert with check ((select auth.uid()) = id);

create policy "Users can update own profile." on profiles
  for update using ((select auth.uid()) = id);

-- This trigger automatically creates a profile entry when a new user signs up via Supabase Auth.
-- See https://supabase.com/docs/guides/auth/managing-user-data#using-triggers for more details.
create function public.handle_new_user()
returns trigger
set search_path = ''
as $$
begin
  insert into public.profiles (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Set up Storage!
insert into storage.buckets (id, name)
  values ('avatars', 'avatars');

-- Set up access controls for storage.
-- See https://supabase.com/docs/guides/storage/security/access-control#policy-examples for more details.
create policy "Avatar images are publicly accessible." on storage.objects
  for select using (bucket_id = 'avatars');

create policy "Anyone can upload an avatar." on storage.objects
  for insert with check (bucket_id = 'avatars');

create policy "Anyone can update their own avatar." on storage.objects
  for update using ((select auth.uid()) = owner) with check (bucket_id = 'avatars');```

  - Get the API keys#  获取 API 密钥#  - 这一步的目的是让cursor和你和supabase数据库相连接
1. Go to the API Settings page in the Dashboard.
前往仪表板中的 API 设置页面。
2. Find your Project URL, anon, and service_role keys on this page.
在此页面上找到您的项目 URL ， anon 和 service_role 键。
[图片]

- Building the app#  构建应用#
  - Initialize a Next.js app# 初始化一个 Next.js 应用#
初始化next.js项目
```Plain Text
npx create-next-app@latest --use-npm supabase-nextjs```
进入目录
```Plain Text
cd supabase-nextjs```
安装supabase客户端
```Plain Text
npm install @supabase/supabase-js```
创建env.local保存变量
```Plain Text
NEXT_PUBLIC_SUPABASE_URL=YOUR_SUPABASE_URL
NEXT_PUBLIC_SUPABASE_ANON_KEY=YOUR_SUPABASE_ANON_KEY```
成功安装
[图片]
保存变量
[图片]


  - Supabase Server-Side Auth# Supabase 服务器端身份验证
为了更好地与框架集成，我们创建了 @supabase/ssr 包用于服务器端认证。它包含所有快速配置您的 Supabase 项目使用 cookies 存储用户会话的功能。
Install the package for Next.js.安装 Next.js 的包
```Plain Text
npm install @supabase/ssr```
成功安装
[图片]


- 修改nextjs文件的两个配置
[图片]

[图片]

在使用 Cursor 编辑器，基于官方 Next.js 模板和 Supabase 快速搭建项目时，很多同学发现，项目虽然初始化成功，但：
- 路径别名不起作用，import 报错
- 浏览器打开后控制台出现“水合不匹配（hydration mismatch）”警告
这是因为Next.js 自带模板中的默认配置并不适合我们自定义的目录结构，也没考虑到开发过程中浏览器插件的干扰。
接下来一步步修改，保证你的项目正常运行。


---
第一步：修复路径别名问题
1. 背景
项目 tsconfig.json 配置了路径别名：
```JSON
"paths": {
  "@/*": ["./src/*"]
}```
这样只对 src 目录下的模块有效，根目录的模块无法用 @/ 导入，比如：
```TypeScript
import { client } from "@/utils/supabase/client" // 报路径错误```
2. 正确写法
```JSON
"paths": {
  "@/*": ["./src/*", "./*"]
}```
3. 修改步骤
- 打开 tsconfig.json
- 定位 "paths" 配置
- 改为上面格式，保存
4. 效果
✅ src 目录和项目根目录下的模块都能用 @/ 导入
 ✅ 代码风格统一，避免路径混乱

---
第二步：解决水合不匹配（Hydration Mismatch）
5. 背景
开发时浏览器插件可能偷偷往 <html> 标签加属性：
```HTML
<html lang="en" data-xxx="xxx">```
导致 Next.js 前后端 HTML 不一致，出现 Hydration Mismatch 警告。
6. 正确写法
在layout文件的 <html> 标签添加：
```TypeScript
<html lang="en" suppressHydrationWarning={true}>```
7. 修改步骤
- 打开 layout.tsx 或 app/layout.tsx
- 找到 <html> 标签
- 补充 suppressHydrationWarning={true}
8. 效果
✅ 页面正常加载，控制台不再有警告
 ✅ 不影响功能，兼容插件引起的差异

---

  - Supabase utilities#  Supabase 工具集#
Supabase 中有两种不同类型的客户端：
1. client.js
客户端组件 - 从运行在浏览器中的客户端组件访问 Supabase。
```javascript
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  // Create a supabase client on the browser with project's credentials
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  )
}```
2. server.js
服务器组件 - 从运行在服务器上的服务器组件、服务器操作和路由处理程序访问 Supabase。
```javascript
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()

  // Create a server's supabase client with newly configured cookie,
  // which could be used to maintain user's session
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  )
}```
创建以下必要的工具文件以创建客户端，并将它们组织在项目根目录的 utils/supabase 中
在根目录下创建utils/supabase文件夹
[图片]

创建两个文件，并复制代码·
[图片]


  - Next.js middleware#  Next.js 中间件#
创建一个位于项目根目录的 middleware.js 文件，
```javascript
import { updateSession } from '@/utils/supabase/middleware'

export async function middleware(request) {
  // update user's auth session
  return await updateSession(request)
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * Feel free to modify this pattern to include more paths.
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}```
并在 utils/supabase 文件夹内再创建一个。
```javascript
import { createServerClient } from '@supabase/ssr'
import { NextResponse } from 'next/server'

export async function updateSession(request) {
  let supabaseResponse = NextResponse.next({
    request,
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => request.cookies.set(name, value))
          supabaseResponse = NextResponse.next({
            request,
          })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  // refreshing the auth token
  await supabase.auth.getUser()

  return supabaseResponse
}```
 utils/supabase 文件包含更新会话的逻辑。这个文件被 middleware.js 文件使用，这是 Next.js 的一个约定。

[图片]

[图片]


- Set up a login page# 设置登录页面#
  - Login and signup form#  登录和注册表单
在app文件夹中，创建一个名为 login 的新文件夹，其中包含一个 page.jsx 文件，用于登录/注册表单。
```javascript
import { login, signup } from './actions'

export default function LoginPage() {
  return (
    <form>
      <label htmlFor="email">Email:</label>
      <input id="email" name="email" type="email" required />
      <label htmlFor="password">Password:</label>
      <input id="password" name="password" type="password" required />
      <button formAction={login}>Log in</button>
      <button formAction={signup}>Sign up</button>
    </form>
  )
}```
在 login 的新文件夹，创建actions.jsx
```javascript
'use server'

import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'

import { createClient } from '@/utils/supabase/server'

export async function login(formData) {
  const supabase = await createClient()

  // type-casting here for convenience
  // in practice, you should validate your inputs
  const data = {
    email: formData.get('email'),
    password: formData.get('password'),
  }

  const { error } = await supabase.auth.signInWithPassword(data)

  if (error) {
    redirect('/error')
  }

  revalidatePath('/', 'layout')
  redirect('/account')
}

export async function signup(formData) {
  const supabase = await createClient()

  const data = {
    email: formData.get('email'),
    password: formData.get('password'),
  }

  const { error } = await supabase.auth.signUp(data)

  if (error) {
    redirect('/error')
  }

  revalidatePath('/', 'layout')
  redirect('/account')
}```
在app文件中，创建error文件夹，在error文件夹中创建page.jsx文件
```javascript
export default function ErrorPage() {
  return <p>Sorry, something went wrong</p>
}```
[图片]

[图片]

运行开发环境
进入3000/login
[图片]

当您输入您的电子邮件和密码时，您将收到一封标题为“确认您的注册”的电子邮件。恭喜 🎉！！！
[图片]


  - Email template#  邮件模板#
将电子邮件模板修改为支持发送令牌哈希：
- Go to the Auth templates page in your dashboard.
前往仪表板中的身份验证模板页面。
- 选择 Confirm signup 模板。
- 将 {{ .ConfirmationURL }} 改为 {{ .SiteURL }}/auth/confirm?token_hash={{ .TokenHash }}&type=email 
[图片]


  - Confirmation endpoint#  确认端点#
- 获取 Supabase Auth 服务器返回的代码，使用 token_hash 查询参数。
- 用此代码交换会话，我们将其存储在我们选择的存储机制中（在这种情况下，为 cookie）。
- 最后，我们将用户重定向到 account 页面。
- 在app中，创建auth/confirm文件夹，创建route.js文件
```typescript
import { NextResponse } from 'next/server'

import { createClient } from '@/utils/supabase/server'

// Creating a handler to a GET request to route /auth/confirm
export async function GET(request) {
  const { searchParams } = new URL(request.url)
  const token_hash = searchParams.get('token_hash')
  const type = searchParams.get('type')
  const next = '/account'

  // Create redirect link without the secret token
  const redirectTo = request.nextUrl.clone()
  redirectTo.pathname = next
  redirectTo.searchParams.delete('token_hash')
  redirectTo.searchParams.delete('type')

  if (token_hash && type) {
    const supabase = await createClient()

    const { error } = await supabase.auth.verifyOtp({
      type,
      token_hash,
    })
    if (!error) {
      redirectTo.searchParams.delete('next')
      return NextResponse.redirect(redirectTo)
    }
  }

  // return the user to an error page with some instructions
  redirectTo.pathname = '/error'
  return NextResponse.redirect(redirectTo)
}```
[图片]


  - Account page#  账户页面#
用户登录后，我们可以允许他们编辑个人资料详情和管理账户。
在 app/account 文件夹中创建一个新组件，命名为 AccountForm.jsx 
```javascript
'use client'
import { useCallback, useEffect, useState } from 'react'
import { createClient } from '@/utils/supabase/client'

export default function AccountForm({ user }) {
  const supabase = createClient()
  const [loading, setLoading] = useState(true)
  const [fullname, setFullname] = useState(null)
  const [username, setUsername] = useState(null)
  const [website, setWebsite] = useState(null)
  const [avatar_url, setAvatarUrl] = useState(null)

  const getProfile = useCallback(async () => {
    try {
      setLoading(true)

      const { data, error, status } = await supabase
        .from('profiles')
        .select(`full_name, username, website, avatar_url`)
        .eq('id', user?.id)
        .single()

      if (error && status !== 406) {
        throw error
      }

      if (data) {
        setFullname(data.full_name)
        setUsername(data.username)
        setWebsite(data.website)
        setAvatarUrl(data.avatar_url)
      }
    } catch (error) {
      alert('Error loading user data!')
    } finally {
      setLoading(false)
    }
  }, [user, supabase])

  useEffect(() => {
    getProfile()
  }, [user, getProfile])

  async function updateProfile({ username, website, avatar_url }) {
    try {
      setLoading(true)

      const { error } = await supabase.from('profiles').upsert({
        id: user?.id,
        full_name: fullname,
        username,
        website,
        avatar_url,
        updated_at: new Date().toISOString(),
      })
      if (error) throw error
      alert('Profile updated!')
    } catch (error) {
      alert('Error updating the data!')
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="form-widget">
      <div>
        <label htmlFor="email">Email</label>
        <input id="email" type="text" value={user?.email} disabled />
      </div>
      <div>
        <label htmlFor="fullName">Full Name</label>
        <input
          id="fullName"
          type="text"
          value={fullname || ''}
          onChange={(e) => setFullname(e.target.value)}
        />
      </div>
      <div>
        <label htmlFor="username">Username</label>
        <input
          id="username"
          type="text"
          value={username || ''}
          onChange={(e) => setUsername(e.target.value)}
        />
      </div>
      <div>
        <label htmlFor="website">Website</label>
        <input
          id="website"
          type="url"
          value={website || ''}
          onChange={(e) => setWebsite(e.target.value)}
        />
      </div>

      <div>
        <button
          className="button primary block"
          onClick={() => updateProfile({ fullname, username, website, avatar_url })}
          disabled={loading}
        >
          {loading ? 'Loading ...' : 'Update'}
        </button>
      </div>

      <div>
        <form action="/auth/signout" method="post">
          <button className="button block" type="submit">
            Sign out
          </button>
        </form>
      </div>
    </div>
  )
}```
创建app/account/page.jsx
```javascript
import AccountForm from './AccountForm'
import { createClient } from '@/utils/supabase/server'

export default async function Account() {
  const supabase = await createClient()

  const {
    data: { user },
  } = await supabase.auth.getUser()

  return <AccountForm user={user} />
}```
[图片]

[图片]


  - Sign out#  登出#
让我们创建一个路由处理程序来处理从服务器端的注销。确保首先检查用户是否已登录！
创建app/auth/signout/route.js
```javascript
import { createClient } from '@/utils/supabase/server'
import { revalidatePath } from 'next/cache'
import { NextResponse } from 'next/server'

export async function POST(req) {
  const supabase = await createClient()

  // Check if a user's logged in
  const {
    data: { user },
  } = await supabase.auth.getUser()

  if (user) {
    await supabase.auth.signOut()
  }

  revalidatePath('/', 'layout')
  return NextResponse.redirect(new URL('/login', req.url), {
    status: 302,
  })
}```
[图片]

此时在terminal里面 npm run dev就来到了这个界面
[图片]


- Bonus: Profile photos#  奖励：个人照片#
  - Create an upload widget#  创建上传组件#
让我们创建一个用户头像小部件，以便用户可以上传个人照片。我们可以从创建一个新的组件开始：
创建app/account/avatar.jsx
```javascript
'use client'
import React, { useEffect, useState } from 'react'
import { createClient } from '@/utils/supabase/client'
import Image from 'next/image'

export default function Avatar({ uid, url, size, onUpload }) {
  const supabase = createClient()
  const [avatarUrl, setAvatarUrl] = useState(url)
  const [uploading, setUploading] = useState(false)

  useEffect(() => {
    async function downloadImage(path) {
      try {
        const { data, error } = await supabase.storage.from('avatars').download(path)
        if (error) {
          throw error
        }

        const url = URL.createObjectURL(data)
        setAvatarUrl(url)
      } catch (error) {
        console.log('Error downloading image: ', error)
      }
    }

    if (url) downloadImage(url)
  }, [url, supabase])

  const uploadAvatar = async (event) => {
    try {
      setUploading(true)

      if (!event.target.files || event.target.files.length === 0) {
        throw new Error('You must select an image to upload.')
      }

      const file = event.target.files[0]
      const fileExt = file.name.split('.').pop()
      const filePath = `${uid}-${Math.random()}.${fileExt}`

      const { error: uploadError } = await supabase.storage.from('avatars').upload(filePath, file)

      if (uploadError) {
        throw uploadError
      }

      onUpload(filePath)
    } catch (error) {
      alert('Error uploading avatar!')
    } finally {
      setUploading(false)
    }
  }

  return (
    <div>
      {avatarUrl ? (
        <Image
          width={size}
          height={size}
          src={avatarUrl}
          alt="Avatar"
          className="avatar image"
          style={{ height: size, width: size }}
        />
      ) : (
        <div className="avatar no-image" style={{ height: size, width: size }} />
      )}
      <div style={{ width: size }}>
        <label className="button primary block" htmlFor="single">
          {uploading ? 'Uploading ...' : 'Upload'}
        </label>
        <input
          style={{
            visibility: 'hidden',
            position: 'absolute',
          }}
          type="file"
          id="single"
          accept="image/*"
          onChange={uploadAvatar}
          disabled={uploading}
        />
      </div>
    </div>
  )
}```
然后我们可以将小部件添加到 AccountForm 组件中：
```javascript
// Import the new component
import Avatar from './avatar'

// ...

return (
  <div className="form-widget">
    {/* Add to the body */}
    <Avatar
      uid={user?.id}
      url={avatar_url}
      size={150}
      onUpload={(url) => {
        setAvatarUrl(url)
        updateProfile({ fullname, username, website, avatar_url: url })
      }}
    />
    {/* ... */}
  </div>
)```
[图片]

[图片]

[图片]


  - 更新主页，查看效果
更新app/page.jsx代码
```javascript
import Link from 'next/link'

export default function Home() {
  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h1 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            Welcome to Our App
          </h1>
          <p className="mt-2 text-center text-sm text-gray-600">
            Please sign in to continue
          </p>
        </div>
        <div className="mt-8 space-y-6">
          <Link
            href="/login"
            className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
            Sign in
          </Link>
        </div>
      </div>
    </div>
  )
}```
让cursor优化下页面布局

- 特别注意：
   当你在邮箱接到了验证邮件，点击可能跳转失败是因为，当localhost:3000/account 页面跳转失败的时候要保证你写的是http而不是http。 因为本地开发环境的 localhost 默认没有配置 SSL证书，所以不支持 https，只能使用 http。

[图片]

[图片]


十一、内功篇小测验
HTML
1、关于 HTML 文档的基本结构，下列哪一项描述是正确的？
A) ＜head＞ 标签用于显示网页的主要内容
B) ＜body＞ 标签用于存放后台资料
C) ＜head＞ 标签存放如字符编码、关键字等后台资料
D) ＜body＞ 标签不会显示在网页中
2、下列哪个标签用于插入图片，并且需要设置图片路径和替代文本？
A) ＜img＞
B) ＜blockquote＞
C) ＜ol＞
D) ＜div＞
3、关于 HTML 标题标签（Heading），下列说法正确的是？
A) 只有 ＜h1＞ 标签可用
B) 共分为 6 个层级，从 ＜h1＞ 到 ＜h6＞
C) ＜h6＞ 是最高级别标题
D) ＜h1＞ 标签只能用于 LOGO
4、下列哪个标签属于“区块元素”，常用于组织页面内容，使其更具结构性，可以包含标题、段落、列表等？
A) ＜section＞
B) ＜strong＞
C) ＜em＞
D) ＜br＞
5、关于 ＜a＞ 标签的用法，下列哪项说法正确？
A) ＜a＞ 标签只能用于页面内跳转
B) ＜a＞ 标签必须配合 href 属性指定目标网址
C) ＜a＞ 标签不能和列表标签一起用
D) ＜a＞ 标签只能放在 ＜head＞ 里
CSS
1、关于 CSS 的三种添加方式，下列哪种方式可以同时控制多个网页的外观？
A) 内联样式
B) 内部样式表
C) 外部样式表
D) 行内脚本
2、下列哪种写法是“类选择器”的正确用法？
A) p { color: red; }
B) #intro { color: red; }
C) .intro { color: red; }
D) div p { color: red; }
3、关于 CSS 的盒子模型，下列哪个属性用于设置元素的“外边距”？
A) border
B) padding
C) margin
D) width
4、如果要让所有 ＜p＞ 标签的文字变成蓝色，应该使用哪种选择器？
A) .p { color: blue; }
B) #p { color: blue; }
C) p { color: blue; }
D) div p { color: blue; }
5、下列哪个 CSS 属性可以用来设置网页元素的背景颜色？
A) color
B) background-color
C) font-family
D) border
TypeScript / JavaScript
1、关于 TypeScript 和 JavaScript 的关系，下列哪项说法符合文档内容？
A) TypeScript 比 JavaScript 更宽松
B) TypeScript 是 JavaScript 的“亲哥”，更严格
C) JavaScript 只能运行在浏览器，TypeScript 不能
D) TypeScript 不需要类型声明
2、下列哪种写法能在 TypeScript 中声明一个只能存放数字的变量？
A) let age = “25岁”;
B) let age: number = 25;
C) let age: string = 25;
D) let age = true;
3、关于 const 和 let 的区别，文档中是如何比喻的？
A) const 是普通盒子，let 是上锁的盒子
B) let 是普通盒子，可以随时换内容，const 是上锁的盒子，内容固定不变
C) let 只能存数字，const 只能存字符串
D) 没有区别
4、下列哪种写法可以在 TypeScript 中定义一个有可选属性的接口？
A) interface Student { name: string; age: number; major?: string; }
B) interface Student { name: string; age: number; major: string; }
C) interface Student { name: string; age: string; }
D) interface Student { name?: string; age?: number; }
5、关于 .js、.ts、.jsx、.tsx 文件的区别，下列哪项说法符合文档内容？
A) .js 只能写类型安全的代码
B) .ts 文件有类型检查，.js 没有
C) .jsx 文件不能写界面
D) .tsx 文件没有类型检查
Next.JS
1、下列哪项比喻最能体现 NodeJS、NPM 和 NextJS 的关系？
A) 车、轮胎、方向盘
B) 地基和框架、工具箱和建材商店、预制的房屋设计
C) CPU、内存、硬盘
D) 画笔、颜料、画布
2、在 NextJS 项目中，哪个文件夹用于存放静态资源（如图片、字体等）？
A) app
B) public
C) src
D) assets
3、NextJS 的 app 文件夹的主要作用是什么？
A) 存放静态资源
B) 管理全局配置
C) 路由的核心，每个文件/文件夹对应一个页面路由
D) 存放数据库文件
4、在 NextJS 中，如何实现动态路由？
A) 在 app 文件夹下创建以 [参数名] 命名的文件夹
B) 在 public 文件夹下新建文件
C) 修改 tsconfig.json
D) 只能通过配置文件实现
5、下列关于 NextJS 的 Server Components 说法正确的是？
A) 只能在客户端运行
B) 运行在 Node 边缘/Serverless，可直接调用后端 SDK、数据库等
C) 只能处理静态页面
D) 不能访问数据库
6、如果你需要在 NextJS 页面中实现用户交互（如按钮点击），应该使用哪种组件？
A) Server Component
B) Client Component
C) Static Component
D) Layout Component
7、在 NextJS 中，声明一个组件为客户端组件需要做什么？
A) 在文件顶部添加 “use client”
B) 在文件顶部添加 “use server”
C) 在 package.json 配置
D) 不需要任何声明
8、public 文件夹中的资源如何在页面中引用？
A) 通过绝对路径
B) 通过相对路径（如 /logo.png）
C) 只能通过 import
D) 只能放在 app 文件夹下
9、NextJS 的 layout.tsx 文件的作用是什么？
A) 存放静态资源
B) 提供所有子路由的根布局，实现页面间的 UI 共享
C) 管理 API 路由
D) 存放环境变量
10、在 NextJS 中，如何启动本地开发环境？
A) npm start
B) npm run dev
C) npm build
D) node index.js
11、下列关于 NextJS 路由机制的说法正确的是？
A) 文件=路由，文件夹=层级，layout 包壳 page
B) 只能通过配置文件定义路由
C) 路由只能写在 public 文件夹
D) 路由和页面无关
12、NextJS 的 API 路由本质上是什么？
A) 基于文件系统的路由，每个文件代表一个 API 端点
B) 只能通过代码注册
C) 只能在 public 文件夹下
D) 需要手动配置
13、在 NextJS 中，如何为页面设置元数据（如标题、描述等）？
A) 在页面组件中导出 metadata 对象
B) 只能在 public 文件夹设置
C) 只能通过 HTML 写死
D) 只能在 layout.tsx 设置
14、下列关于 NextJS 图片优化组件    ＜Image＞ 的说法正确的是？
A) 只能显示 PNG 格式
B) 支持响应式图片和自动压缩
C) 不能设置占位符
D) 只能在 public 文件夹使用
15、NextJS 支持哪几种主要的渲染策略？
A) 只有静态生成
B) 静态生成、服务器端渲染、增量静态再生成
C) 只有客户端渲染
D) 只有 SSR
16、在 NextJS 中，动态路由参数如何在页面组件中获取？
A) 通过 props.params
B) 通过 window.location
C) 通过全局变量
D) 通过 import
17、下列关于 NextJS 的中间件（Middleware）说法正确的是？
A) 只能在客户端运行
B) 在页面或 API 路由被访问前执行，可做认证、重定向等
C) 只能处理图片
D) 只能在 public 文件夹下
18、在 NextJS 中，环境变量的作用是什么？
A) 存储配置信息，如 API 密钥、数据库连接字符串等
B) 存放静态资源
C) 管理页面路由
D) 优化图片
19、下列关于 NextJS 的动态导入（dynamic import）说法正确的是？
A) 只能在服务器端使用
B) 允许代码分割，只在需要时加载特定组件
C) 不能和 Suspense 一起用
D) 只能导入 CSS
20、NextJS 的 Streaming 与 Suspense 主要用于什么场景？
A) 提高首次内容绘制速度，分批加载 UI 片段
B) 优化图片加载
C) 管理环境变量
D) 静态资源管理
[图片]

HTML：
1-5：C A B A B

CSS：
1-5：C C C C B

TypeScript / JavaScript：
1-5：B B B A B

Next.JS：
1-5：B B C A B
6-10：B A B B B
11-15：A A A B B
16-20：A B A B A

[图片]
进阶篇 

注意：前三章都是科普，实操引导从3.5开始

这部分内容，对于完全没有编程经验的小白来说，会有很大挑战。
请您在开始学习本篇之前，一定要先花足够多的时间，完成「内功篇」的学习，尤其是 NextJS 部分。

进阶篇建议使用Cursor + Claude Code的组合完成。如果只靠Cursor，在缺乏编程基础的前提下，会遇到很多坑。

一、如何让用户登录？

我推荐大家从使用 Supabase 方案开始。

我推荐新手从 Supabase 方案开始，它可以省去我们很多麻烦。

它的上限也足够高，在生财有术的优秀独立开发者当中，有朋友已经月入超 10 万美元了，仍然还在使用 Supabase。

除了 Supabase 以外，此处我也顺便介绍一些我用过的其他方案，各有优劣，供学有余力的同学们参考。

1.1 新手推荐方案：Supabase
网址：
1. 创建项目
[图片]
2. 打开 GitHub 登录或 Google 登录（或其他你想要集成的社交登录）

一般我只打开 Google 账号登录和 GitHub 登录。可以在 Supabase 里启用开关，如下图。

我们先以“GitHub 账号登录为示例”。请在 Supabase 后台打开 GitHub 登录，然后参考这个文档，
https://supabase.com/docs/guides/auth/social-login/auth-GitHub

其他的社交登录方式同理。（超过 90%的 SaaS 都会打开 Google 账号登录功能，你可以后面自行研究它）

- 登陆 Supabase 官网 Supabase.com
- 选择【Authentication】目录中的【Sign In/Up】
- 进行 Google 与 GitHub 的登录配置

[图片]
- 首先获取谷歌 Client IDs
进入 Google 开发者控制台，点击 “新建项目”
[图片]
【凭据】-【创建凭据】-点击【OAuth 客户端 ID】
[图片]
点击创建，即可获得 ID
[图片]

- 填写 OAuth 客户端 ID 及密钥，完成 Google 登陆配置
- 复制【Callback URL （for OAuth）】中的链接
- 打开【GitHub】，点击右上角头像-选择【setting】-点击【Developer Settings】-选择【OAuth Apps】
- 新建项目，即可到达截图页面
[图片]
- GitHub 完成配置后，将 Client ID 填入 Supabase 中

[图片]
让 Cursor 在现有项目里添加 Supabase 登录，基本上可以一气呵成。（如果你的 Cursor 没有一气呵成，也别着急，把报错信息反馈给它，让它修改）。
注意：建议跟 Cursor 说，“Supabase 官方推荐使用 @Supabase/ssr 包进行服务器端认证，请不要写成了客户端认证”。（我截图里没体现这一点，但是，建议你补充这一句。) 

这里，我们演示让 Cursor 先帮我们做“使用 GitHub 账号登录”功能。

不过，你需要认真阅读 Cursor 给你的反馈，有一些关键配置，是需要咱们自己动手的。 
[图片]
Cursor 让我自己动手干这些配置，我一个一个干完它们 
[图片]

[图片]
[图片]

配置完成后，使用 npm run dev 运行项目，发现已经做好了
[图片]
[图片]

用户登录成功后，会跳转到 dashboard （刚才 Cursor 已经告诉我们了）
[图片]

当用户用他的 GitHub 账号登录后，我们就可以在 Supabase 后台的数据库里，看到这个用户的记录了
[图片]

连贯的录屏是这样的，下面是视频
暂时无法在飞书文档外展示此内容

同样的方法，再打开 Google 登录
[图片]

[图片]
[图片]

同时加上 Google 登录和 GitHub 登录后，连贯的效果大约是这样，下面是视频。（网速有点慢，所以点击登录后卡了 5 秒。上线到海外的服务器后，不会卡）
暂时无法在飞书文档外展示此内容

3. 关于邮箱登录？

邮箱登录在 Supabase 里是默认打开的。
[图片]

我推荐：刚开始的 SaaS，不要启用邮箱注册登录。有两个原因
- 如果打开邮箱登录，就要额外做用户注册、忘记密码、修改密码、修改用户资料、发送激活邮件等等一大堆页面和功能，太麻烦。初期连用户都很少，没必要，只要有 Google 登录，绝大部分海外用户都已经可以登录了。
- 如果打开邮箱登录，我们提供的免费限额容易被刷。因为有很多提供临时邮箱的服务。如果我们要提供“新用户免费 xxx credits”，会被人使用无限邮箱地址进行薅羊毛。

我一般会确定某个产品赚钱后，再去补邮箱登录的功能。

你可以这么想：如果提供了邮箱登录，你的产品会增加 10%的收益；但是对于初期来说，这 10%收益对应的工作量是比较大的，如果初期把这部分工作投入放到更重要的事情上，不止增收 10%

如果你要做邮箱登录的话，操作方式和刚才差不多。不过，邮箱登录涉及的功能和页面比较多，Cursor 比较难“一气呵成”，往往需要你和 Cursor 多切磋几轮，并且调整一些页面样式。

[图片]

1.2 新手可选方案：Clerk

Clerk 是一个专为现代 Web 应用程序设计的完整身份验证和用户管理解决方案，与 Next.JS 框架的集成，非常好用。

Clerk 官网是：https://clerk.com/

主要特点
- 完整的身份验证系统（登录、注册、密码重置等）
- 社交登录（Google、GitHub、Twitter 等）
- 用户管理和配置文件
- 多因素认证
- 组织和角色管理
- 开箱即用的 UI 组件

这是 Clerk 官方提供的 demo，你可以进去点一下 Sign In，自己试试看
https://clerk-nextJS-app-router.vercel.app/
[图片]
如果只是从“登录”功能讲，我认为 Clerk 比 Supabase 更好用。为什么我更加推荐 Supabse 呢？
因为 Supabase 不仅仅有登录，还有其他一整套开发者需要的后端服务，而 Clerk 几乎只有登录相关的功能。

你可以跟着 Clerk 官方文档，做一遍，就学会了
https://clerk.com/docs/quickstarts/nextJS

[图片]

1.3 其他成熟方案：BetterAuth、NextAuth 等等

NextAuth.JS（现在也被称为 Auth.JS），相信你从名字也能看出来，NextAuth.JS 是 Next.JS 应用程序中最受欢迎的身份验证解决方案之一。它提供了一个简单但功能强大的身份验证系统，支持多种身份验证方式。

官方网站：https://next-auth.JS.org/ 
[图片]
主要特点
- 对 NextJS 特别友好
- 支持多种身份验证提供商（OAuth、邮箱/密码、魔法链接等）
- 会话管理
- JWT 或数据库会话
- 支持多种数据库适配器
- 开源且社区活跃

BetterAuth 是后起之秀，我是在最近（2025 年 1 月后）才刚刚开始使用它。

官方网站在这里 https://www.better-auth.com/

主要特点：
- 框架无关性：兼容多种框架。
- 设计优雅。
- 多租户支持：提供成员、组织、团队和邀请功能，支持多租户环境下的访问控制，满足复杂业务需求。
- 插件生态系统：拥有丰富的官方插件和社区创建的插件，增强应用功能，提升开发体验。

虽然 Better-Auth 比较新，但是开发者对 Better Auth 给予了高度评价，称其为“最好的认证体验”，并赞扬其全类型安全和简单的 API 设计。

最后顺便一提，Raphael AI （ https://raphael.app ） 是 2025 年 1 月后才做的网站，当时我为了尝鲜，使用的是 Better-Auth 登录。

[图片]

二、如何让用户订阅支付？

2.1 基础概念

在深入技术细节之前，让我们先了解一些基本概念：
支付网关：这是连接你的网站和银行/支付处理商的"桥梁"。就像一个虚拟的收银台，它安全地处理客户的支付信息，并确保资金能从客户账户转移到你的账户。

支付流程：一个典型的网上支付流程包括以下步骤：
1. 用户选择商品/服务并点击"购买"
2. 用户输入支付信息（信用卡、银行账户等）
3. 支付网关验证信息并处理交易
4. 支付网关通知你的网站交易结果
5. 你的网站响应结果（如显示成功页面或失败消息）

常见术语解释：
- API：应用程序接口（Application Programming Interface）。简单来说，这是一种让不同软件系统相互"对话"的方式。在支付集成中，你将使用支付网关提供的 API 让你的网站能与支付网关通信。
- Payment Intent（支付意向）：表示一次支付尝试，包含支付金额、货币和状态等信息。
- Webhook（网络钩子）：一种自动通知机制，当特定事件发生时（如支付成功），支付网关会向你的服务器发送通知。
- PCI DSS：支付卡行业数据安全标准，是处理信用卡信息时必须遵守的安全标准
2.2 Stripe 为什么最火？

Stripe 之所以受到众多开发者青睐，主要因为它简单易用且功能强大。对于个人开发者和初创公司来说，Stripe 提供了完善的文档和 SDK，集成过程非常顺畅。此外，Stripe 在全球支持 46 个国家/地区，接受超过 135 种货币支付，并内置了高级的防欺诈系统 Radar，为商户和客户提供额外的安全保障 。总的来说，Stripe 提供了开发者友好的体验和高度可定制的功能，适合大多数需要在线收款的项目。

Stripe 的核心功能包括但不限于：
- 支付处理：支持一次性付款、预授权、分期付款等多种场景。通过 Stripe，开发者可以轻松接受信用卡、借记卡以及各种数字钱包支付，并且可以根据需要构建自定义的付款流程 。例如，你可以使用 Stripe API 创建支付意向（Payment Intent）来处理单次支付，或者直接使用 Checkout 等预构建组件快速接入支付。
- 订阅管理：Stripe 提供订阅计费功能（Stripe Billing），方便地管理按周期收费的服务。你可以使用 Stripe 创建和管理订阅计划，实现按月或按年自动扣款等逻辑，而无需自行编写复杂的定时扣款代码 。Stripe 针对订阅类业务提供了丰富的支持，包括升级/降级订阅、试用期、优惠券以及处理订阅生命周期中的事件通知等，使得构建 SaaS 类的定期收费系统更加简单高效 。
- 退款：处理退款在 Stripe 中也非常简单。无论是全额退款还是部分退款，Stripe 都允许商户方便地将款项退还给客户。你可以通过 Stripe 管理后台一键发起退款，也可以使用 Stripe 提供的 API 接口在代码中执行退款操作 。例如，通过调用 Stripe 的退款 API，可以对一笔 Charge 或 PaymentIntent 发起退款请求。Stripe 还会跟踪退款状态，确保资金按原路径退回到客户账户。

除上述功能外，Stripe 还提供对账单开具、支付邮件通知、财务报表导出等一系列周边功能，几乎涵盖了在线收款所需的方方面面。这也是为什么 Stripe 被认为“开箱即用”却又足够灵活，能满足从简单博客打赏到大型电商平台的各种支付需求。

Stripe 的问题
1. 不支持中国个人身份、不支持中国公司身份。如果你是中国人，你可以注册外国公司，以外国公司实体的身份去使用 Stripe。（有一些灰色的办法，让你伪装成香港人、到香港区以个人身份注册，但是不太稳定，不推荐）
2. 风控严格，容易莫名其妙封号。不仅中国人会遇到，老外也会遇到。

2.3 最适合中国人的 3 个支付网关

Paddle、Creem、Stripe

请记住这 3 个。

会有人告诉你：“还有很多更出名的啊，比如 Paypal、Adyen、Worldpay、Lemon Squeezy”，暂时不用理会他们。

我建议新手从 Creem 和 Paddle 开始，因为它们支持中国人用中文身份注册、审核不算特别严格。 

等你有经验了，你可以注册一个海外公司，以海外公司的身份使用 Stripe。

Paddle

Paddle 可以视作 Stripe 的替代方案之一，特别适合销售数字产品的个人和小团队。它采用 Merchant of Record （商家记录） 模式，意思是 Paddle 官方充当卖家替你处理支付事务和税务合规 。开发者使用 Paddle 时，只需在 Paddle 平台上创建产品和定价，接着将 Paddle 提供的结算页链接或嵌入式控件集成到自己的网站即可。

相比 Stripe 需要自行处理税率和开票等事务，Paddle 会自动帮你处理各国增值税、开票以及订阅管理等繁琐环节 。这一切使 Paddle 非常适合数字内容或 SaaS 订阅的销售。例如，你可以使用 Paddle 提供的 JavaScript SDK，在用户点击购买时弹出 Paddle 的结算弹窗，让用户完成支付和账单信息填写。由于 Paddle 把支付处理、订阅管理、税务合规和欺诈防护集成在同一平台，开发者无需额外配置太多工具即可开展全球销售 。

Paddle 的手续费相对固定且略高于 Stripe（官方费率约为成交额的 5%+0.5 美元起），但考虑到其代替商家承担税务和合规工作的便利，这对许多独立开发者而言是可以接受的权衡 。

一个小坑，请注意：Paddle 不欢迎 AI 换脸、AI 克隆声音、DeepFake、等可能被用于灰色地带的 AI 产品。

Creem

https://creem.io

Creem 是近年来兴起的支付集成平台，主要面向 SaaS 订阅业务，同时对接本地支付方式的需求。

对于希望快速开始订阅收费的开发者，Creem 提供了开箱即用的解决方案：只需在 Creem 后台配置好产品和订阅计划，然后将 Creem 的订阅组件嵌入你的 Next.JS 前端或者引导用户访问 Creem 托管的定价页面，即可开始收取订阅款项 。

Creem 的一大优势在于其本地化支持，尤其对中国开发者非常友好——无需注册海外公司或银行账户，只要用个人身份证和支付宝就能开通收款 。客户的付款将直接结算到你的支付宝等本地账户，解决了跨境收款难题。

另外，Creem 也具备 Paddle 类似的功能，例如税务处理和全球合规支持 。

2.4 支付接入的基本流程

以 Stripe 为例
[图片]

无论你选择哪个支付网关，接入过程都遵循类似的步骤：

1. 安装和配置
  - 安装相关的 SDK（软件开发工具包）或库
  - 设置 API 密钥和其他配置信息
  - 配置 Webhook 以接收支付事件通知
2. 创建支付界面
  - 设计结账页面和支付表单
  - 集成支付网关提供的表单组件（如 Stripe Elements）
  - 确保界面响应式且用户友好
3. 实现支付逻辑
  - 创建后端 API 端点来处理支付请求
  - 与支付网关 API 通信以创建支付会话或意向
  - 处理支付结果和相应的业务逻辑（如更新订单状态、发送确认邮件等）
4. 处理回调和通知
  - 实现 Webhook 接收端点处理异步通知
  - 验证 Webhook 签名以确保安全
  - 根据支付状态更新更新你的系统

2.5 如何快速接入支付？

在学习完「内功篇」的前提下，接入支付并不难，我提供两个方法供你参考。
注：如果你还没学习完「内功篇」，接下来你会看不懂、无从下手。如果出现这种情况，建议先回去学习 NextJS 基础。

方法一：跟着教程走。

Paddle
- Paddle 具体教程

Stripe
- 具体教程 
- 配套 demo

方法二：直接套用官方的示例代码！ 

Stripe 和 Paddle，都官方提供了基于 NextJS 框架的 demo，并且登录系统正好都是上一节介绍的 Supabase！

Paddle  
- 推荐！ 它的代码写得相当漂亮，功能也齐全
- 官方 Demo
- 开源代码

Stripe
- 不是特别推荐。代码已经没维护了。好在 Stripe 的接入很简单，看看教程，很快也能学会。
- 官方 Demo
- 开源代码


【新增】方法三：把教程文档发给 Cursor，让 Cursor 阅读教程后再做。
- 注意：这个方法并不能帮你绕过「你自己需要懂 NextJS」这个门槛。因为支付相对流程比较复杂，Cursor 不容易一次搞对，多多少少会出问题，需要你和 Cursor 一起协作解决。

Creem接入支付 官方教程
- Vpn打开TUN模式。并在终端配置环境
[图片]
https://docs.creem.io/sdk/nextjs-template
这里我选的是 pnpm install
下面跟着步骤走

[图片]


- 安装步骤输入终端命名
[图片]

界面展示
[图片]
- 登陆
[图片]


- 点击cd，进入目标页面
[图片]

[图片]



首先进入官网 https://www.creem.io/点击登录按钮。
[图片]


选择一个要接入测试项目的商店，也可以新建一个。
填写店名，点击 Create
[图片]


[图片]


填写产品信息：
[图片]

在这里可以选择上传产品的照片
[图片]


[图片]



往下拉，就看到了API以及我们要选择的产品，
[图片]

我们回到本地环境，输入Y 

[图片]


在这里我们去设置 one one-time payment product

[图片]

我们现在得到了我们的两个产品：
[图片]



我们来到了下一步的提示页

[图片]

下一页中填写，付款类型。
[图片]

比如，我在这里上传了一个泰迪小熊。
[图片]


[图片]



我们首先要把Api key粘贴到 .env的文件里
[图片]

接着我们被自动转到另一个提示页面，由于我们刚只设置了subscription，现在我们去设置 one one-time payment product
[图片]


还是刚才的步骤，滑到下面点击创建。

[图片]

再回到本地环境。输入Y
[图片]


点击图中的网址
https://ngrok.com/docs/getting-started/


- Ngrok 配置
首先我们来配置 一个ngrok账户和令牌，分别点击蓝字

[图片]

我直接点击了下载，得到一个zip文件。
[图片]


[图片]



[图片]


接下来 我们把  ngrok http 3000 输入到终端（划红线的地方是你的账户），像下面这样就是成功了。

[图片]

输入Y
[图片]

回到creem网站，点击 Developers
[图片]

如果你之前没有Webhooks就点击创建，如果已经有过，点击添加：

[图片]

会得到：
[图片]

我们得到了以下的产品示例：
[图片]

选择你的登录方式，这里我选的是google登录

[图片]
下载之后点击 ngrok，终端会自动弹出。

[图片]

回到ngrok官网，复制指令粘贴到终端。
[图片]

运行成功会出现 Authtoken saved to configuration file的字样。
[图片]
 

creem 服务的公网地址就是Forwarding后面的一串：


[图片]

现在来到了最后一步的提示：
[图片]

点击 Webhooks
[图片]


把我们刚才在ngrok获得的公网地址填在网址的位置。
比如我的是这样的：https://95af05310d34.ngrok-free.app 
[图片]
 
输入Y：
[图片]


*注意: 如果报错的话，首先检测，cursor中的 .env文件有没有被保存。往往我们修改了Creem_api_key后会忘记 Ctrl+S 进行保存。






[图片]

三、如何进一步加快开发过程？

相信你已经发现，SaaS 项目启动阶段，往往伴随大量重复而复杂的基础架构搭建。比如用户身份认证、订阅支付系统、数据库管理、权限和角色控制、后台管理等功能。

这些虽然不属于产品的核心差异化价值，但却需要花费大量的时间精力进行开发，容易拖慢整体开发进度。

怎么办呢？ 解决方案是：大胆使用 Starter Kit

3.1 什么是  Starter Kit？

 Starter Kit 是预配置的应用开发模板或工具包，提供了 SaaS 产品开发中通用的基础架构和功能组件。

虽然市场上有许多种类的 Starter Kit，但考虑到我们的学员当前正在学习和使用 Next.JS，因此我们重点推荐了基于 Next.JS 的套件。

3.2 为什么要用 Starter Kit？

见过前面的课程，相信很容易发现，大部分 SaaS/MicroSaaS 的“基建工作”都差不多。

就好比，你正在规划修一座桥，如果你能拿到同一条河上以前修过的桥的图纸，你是不是会快很多？

常见的 SaaS Starter Kit，已经内置了如下功能：
- 漂亮的 Landing Page
- 用户体系，包括用户注册、登录、社交账号登录等。
- 支付体系，包括订阅支付、细节体系等等。
- 邮件体系
- 管理员使用的用户管理系统

更强大的 Starter Kit，往往可能还有以下功能：
- 多语言
- 简易博客系统
- 端到端测试
- 多租户
- 分销体系
- News Letter
- Waiting list
- 手机 App 骨架代码 

【新增】Rapheal starter kit用户购买流程交互逻辑的整理
感谢YS圈友对小排老师starter kit的用户购买流程交互逻辑的整理。
[图片]

3.3 几款强大的 Starter Kit 推荐

以下三款 Starter Kit，是我使用最多的 ，在这里推荐给大家。
注意：他们都是收费的！价格多在$299 美元（2000 人民币）左右。

对于新手，推荐排序： MkSaaS ＞ ShipAny ＞ MakerKit ＞ Supastarter ＞ Shipfast

1. MkSaaS

官网地址是
https://mksaas.com/
[图片]
这是一个后起之秀，刚刚发布不久，也是中国的开发者做的。

填入 coupon 优惠码 SCAI，可以获取$20 优惠。这是作者给咱们课程特殊的 coupon，请勿外传！仅限学员使用。
[图片]

MkSaaS 优势
1. 代码架构优秀，而且简单
2. 功能相对完整。
3. 长在了我的代码审美上！同时使用了 Next-Intel、Resend、Drizzle、Shadcn、MagicUI、Better-auth、Zustand 的 starter，全世界就这一个！我以前用其他的 starter，总是先手动修改、引入上述技术栈的。Mksaas 是如此符合我的习惯，是唯一一个让我啥也不用改，直接用起来就很舒服的。
4. 性价比最高。

MkSaaS 劣势
1. 不支持 Stripe 以外的其他支付平台。不过也还好，比较好改。
2. 比较新。

2. ShipAny

ShipAny 的开发者是 idoubi，他也是咱们生财有术的圈友。
[图片]

价格不便宜，不过，如果你打算买超大杯版本（高级版），你可以从 https://shipany.ai/i/SCAI 进入，输入专属的优惠码 SCAI-LIUXIAOPAI  获得 50%优惠。
[图片]
[图片]

ShipAny 的优势
1. 界面美观，审美在线。
2. 对于简单应用来说，开发特别快

ShipAny 的劣势
1. 缺失高级功能。（如果和 Supastarter 相比的话）。idoubi 会逐渐增加更多功能。
2. 暂时没有邮箱登录功能，只能让用户通过 Gmail 账号和 GitHub 账号登录
3. 对订阅支付的支持暂时还不够好。
4. 不支持 Stripe 以外的其他支付平台

一般而言，对于 MVP 阶段的应用，我会优先选择用 ShipAny，因为它真的可以节省开发 MVP 的时间成本。一旦我的应用有点流量进来了，我会换成 Supastarter 或者其他的架构。

3. MakerKit

MakerKit 是一套功能强大的 SaaS 启动模板，包含用户认证、支付订阅、后台仪表盘、邮件发送等常见功能。其突出特点是易于扩展和良好的文档支持，非常适合想要迅速构建稳定产品基础的初创团队。

它是功能最全的 Starter Kit 。

还有两个特点值得推荐：
- 它的数据库和后端功能使用的是 Supabase，对新手非常友好。
- 赠送一套 App 的 starter，如果我们想要同时做 app，它可以进一步帮我们省时间

[图片]

4. SupaStarter

SupaStarter 借助 Supabase 提供的实时数据库、即时 API、用户认证及文件存储服务，最大化降低后端开发门槛，帮助开发者快速集成现代化的后端基础设施，非常适合那些希望降低技术门槛的初学者。

它是代码最健壮的 Starter Kit。如果你的项目未来会做得很大，可以考虑从迁移使用优秀的架构。

SupaStarter 我从三年前就开始使用了，最初的版本它也使用了 Supabase 做后端，后来新版本给去掉了。

这个框架一个可能会让人难受的地方：
- 它的代码架构很牛。这是一个双刃剑。对于大公司、对于复杂项目是好事，但对于新手并不友好。

[图片]

5. Shipfast

Shipfast 强调极速开发和部署，涵盖了营销页面、用户订阅管理、身份验证、Stripe 支付集成等功能。尤其适合想要极快验证市场需求，推出产品最小可行版本（MVP）的开发团队。

它是最适合初学者的 Starter Kit，一边使用，一边学习 

一个可能比较难受的地方：
- 数据库设计偏薄弱。尤其是，它的主版本数据库使用的是 mongodb，在 SaaS 领域相对比较小众。
[图片]

6. SassyKit
https://saasykit.com/  这是我最喜欢的 starter 之一，功能完整、代码健壮。不过，它使用的是 Laravel 框架（PHP语言），不是 NextJS，因此在本课程里，我们不重点推荐它。
[图片]


3.4【重点】本课程专属 Starter Kit - Raphael Starter

为了配合本次课程，我决定做一适合本课程学员专属的 Starter Kit。你可以用这套 starter 快速上手。

注意，这个 starter 非常简单，功能完整性上无法和上面推荐的其他成熟 starter 相比。但是它完全契合本课程，而且足够简单，最大的好处是可以帮助搞清理里面的原理、学明白每一行代码。

在线 Demo 地址：https://starterkit-chi.vercel.app/

登录：可使用 Google 账号登录
支付：可使用测试账号支付，测试订阅支付和积分购买功能
信用卡号：4242 4242 4242 4242， 其他信息随便填。
[图片]
[图片]
[图片]
特色
- 极简！只有新手必须的功能！
- 自带 Cursor Rule！ Cursor 可以完全理解项目架构
- 和课程深度结合。
- 包含 SaaS 的基建功能：
  - 漂亮的 landing page
  - 用户认证体系（注册、登录、Google 账号登录）
  - 订阅支付体系
  - 积分购买体系
  - Cursor Rule 

技术框架选择
- NextJS 
- ShadcnUI
- TailwindCSS
- Creem.io -  因为这个支付网关，允许中国大陆居民使用个人身份注册订阅支付。
- Supabase - 因为这是对新手最友好的一站式服务端方案。

这是一个基于 Next.JS、Supabase 和 Creem.io 构建的现代化、生产就绪的启动套件。非常适合快速构建具有身份验证、订阅和积分系统的 SaaS 应用程序，让您的 MVP 开发速度提升 10 倍。
从此，你只需要专注于核心功能和搞流量 就可以了

项目结构
├── app/                   # Next.JS 应用目录
│   ├── (auth-pages)/     # 身份验证页面
│   ├── dashboard/        # 仪表板页面
│   ├── API/             # API 路由
│   └── layout.tsx       # 根布局
├── components/           # React 组件
│   ├── ui/             # Shadcn/ui 组件
│   ├── dashboard/      # 仪表板组件
│   └── home/          # 登陆页面组件
│   └── layout/        # 页面布局组件
├── hooks/               # 自定义 React 钩子
├── lib/                # 工具库
├── public/             # 静态资源
├── styles/             # 全局样式
├── types/              # TypeScript 类型
└── utils/              # 工具函数


效果展示
- 首页
  - Header
  - Hero
  - Features
  - Stats
  - Pricing
  - FAQ
  - Contact

[图片]
- 仪表盘页
[图片]
- 支持光暗模式切换
[图片]

[图片]

- 支持账号注册
[图片]

[图片]

- 支持账密登录
[图片]

[图片]

- 支持 google 登陆
[图片]

[图片]

- 支持订阅
[图片]

[图片]

- 支持购买积分
[图片]

[图片]


注意：这套 starter 非常简单，适合新手学习和快速做出 MVP 和跑通闭环；
如果你已经不再是新手，建议你使用更强大的 starter、或者积累自己的 starter。

3.5 演示：基于 Raphael Starter 和 Cursor 的快速开发流程
工作步骤：
[图片]

第一步：拉取代码安装依赖
- 拉取代码
 GitHub 地址 https://github.com/Idea-To-Business/raphael-starterkit-v1
1.打开 GitHub，在 desktop 中打开
[图片]

2.在 desktop 中完成克隆
[图片]
3.在 Cursor 中打开
[图片]
4.完成代码拉取
[图片]
- 安装依赖
打开 Cursor，终端运行 npm i，即完成依赖安装
[图片]

第二步：浏览代码
本项目依托 Next.JS 框架，首先回顾下基本结构
文件夹：
1. .next：Next.JS 构建过程中生成的静态文件、服务器代码等相关产物会存放在这里。
2. app：通常是存放应用主要代码的地方，像页面组件、路由相关逻辑等，页面文件会放在这里。
3. components：用于存放可复用的 React 组件，比如按钮组件、卡片组件。
4. config：存放项目的各种配置文件，例如数据库连接配置、环境相关配置。
5. hooks：用于抽离可复用的状态逻辑和副作用逻辑，让组件逻辑更简洁、可维护。
6. lib：一般放置项目中通用的工具函数库，像是数据处理函数、网络请求封装等代码可以放在这里。
7. node_modules：保存项目依赖的第三方包和模块，使用 npm 或 yarn 等包管理器安装的包会存放在此目录。
8. public：用于存放静态资源，如图片、字体文件、图标等。
9. readme_image：是存放与项目 README 文件中的图片资源，用于为说明添加图片。
10. Supabase：存放与 Supabase 的建表 sql。
11. types：用于集中管理 TypeScript 类型定义文件，定义接口、类型别名等。
12. utils：存放通用的工具函数，比如日期格式化函数、字符串处理函数
文件：
1. .env、.env.example、.env.local：环境变量配置文件。.env.example 是示例文件，展示有哪些环境变量可供设置；.env 用于存储项目的环境变量，不过通常不建议直接提交到版本控制；.env.local 用于本地开发时设置环境变量，优先级高于。env ，且默认会被。gitignore 忽略，防止敏感信息泄露。
2. .gitignore：指定在使用 Git 进行版本控制时，哪些文件或文件夹不需要被跟踪和提交到代码仓库，比如 node_modules 目录、.  env.local。
3. components.JSon：用于描述组件相关信息的文件
4. Cursor.Cursorrules：存放该项目的 Cursor 规则。
5. middleware.ts：用于在请求到达页面之前进行一些预处理操作，如身份验证、请求头修改等。
6. next-env.d.ts：TypeScript 类型声明文件，用于声明 Next.JS 相关的环境变量类型
7. next.config.JS、next.config.mJS、next.config.ts：配置自定义 Webpack 配置、设置服务器端口、配置环境变量。
8. package-lock.JSon：npm 包管理器生成的文件，记录项目依赖的具体版本信息。
9. package.JSon：项目的元数据文件，记录项目名称、版本、描述、依赖项、脚本命令等信息。
10. postcss.config.JS：用于转换 CSS 的工具。
11. README.md：项目的说明文档。
12. tailwind.config.ts：Tailwind CSS 的配置文件。
13. tsconfig.JSon：TypeScript 的配置文件。
在我们的 starter 中，你需要重点关注以下 3 个文件，这将是你主要做更改的地方
[图片]
如果这个时候，你运行 dev 环境，那么会是一个报错的界面，因为你还没有在.env.local中配置 Supabase
[图片]
别急，跟着我们一步步完成


第三步：修改 env 文件配置
- 首先，创建一个 env.local 文件，将 env.example 内容复制
点击创建文件
[图片]
命名为 .env.local
[图片]
将 .env.example 全部复制
[图片]
粘贴到 .env.local 文件中·
[图片]
- 接着，让我们一项项的获取 env 所需要的 key、链接，这里需要耐心，第一次需要 1-2h 的时间预留

3.5.1 获取 Supabase 配置信息
Supabase 在内功篇中，作为了一个完整章节来讲解。如果没有完成学习，建议先按顺序学完 Supabase，再来跟次步骤操作
- 进入 Supabase 界面
1.打开 local.env 文件，在浏览器中打开链接
[图片]
2.点击链接后，先完成登录，之后会来到该界面
[图片]
3.点击左上角图标
[图片]
4.点击创建项目
[图片]
5.填写相关信息
[图片]
当你来到以下界面，恭喜你，你已经成功在 Supabase 中创建了你的专属项目
[图片]

现在让我们去查看 Supabase 的连接信息
1.点击 project setting
[图片]
2.点击 data API
[图片]

3.复制 URL
[图片]

4.粘贴到 NEXT_PUBLIC_Supabase_URL
[图片]
5.复制 anon-public-key
[图片]
6.粘贴到 NEXT_PUBLIC_Supabase_ANON_KEY
[图片]
7.复制 service_role
[图片]

8.粘贴到 Supabase_SERVICE_ROLE_KEY 保存
[图片]

粘贴信息后，需要按 command/control+S，进行保

至此，恭喜你，你的 env 配置，完成进度 3/6
更新 env 后，终端运行 npm run dev，启动开发环境，就可以正常看到界面啦
[图片]
注意：

1.课程在更新，持续优化该 starter 框架，所以界面可能会有所不同
2.请务必保证，你的开发环境只运行在 3000 一个端口上

3.5.2 Supabase 配置数据库 （细节看内功篇10.2）

由于现在的数据库是空的，让我们先来创建数据表，首先在 Cursor 中复制 sql 代码
1.打开 Cursor，复制 sql 代码
[图片]

2.打开 SQL Editor
[图片]
3.将代码粘贴，点击运行
[图片]

4.点击 table editor
[图片]
当你点击 table editor 后，发现这里出现了 3 个表的名称，那么恭喜你，已经成功建表了
[图片]

3.5.3 配置开发环境、正式环境域名
由于在后续的配置中，我们必须需要用一个正规的域名，如果这个时候你还没有购买一个域名，你需要返回基础课，跟着视频一步步购买一个专属域名
在这里我们将用 https://www.cloudflare.com/zh-cn/ 进行处理

开发环境：我们需要，将本地的开发网址 http://localhost:3000/ ，暴露在公网中，以完成后续的登录支付环节
1.进入  https://www.cloudflare.com/zh-cn/ 点击使用
[图片]
（补充：第一次需要登录）
[图片]
2.来到了主页面
[图片]

3.点击 zero trust
[图片]
（补充：第一次可能会进入创建 team 界面，取消即可）
[图片]
4.点击 network，再点击 tunnels
[图片]

知识点补充：点击 Cloudflare Zero Trust 的目的，是为了配置和管理一整套安全访问控制方案，主要用于：
核心目的：
✅ 保护私有资源：通过 Zero Trust，可以控制谁可以访问你内部的应用、API、开发环境、本地项目、甚至 SSH、RDP 等资源。
✅ 避免公网暴露：即使你的项目在本地、VPS 或服务器上，没有直接开放公网 IP，借助 Zero Trust（尤其是 Tunnel 功能），依然可以安全暴露给需要访问的人。

首次场景补充：
补充 1 如果你首次进入，则根据官方引导安装依赖
[图片]
补充 2  选择电脑对应的系统创建一个 tunnel
[图片]

补充 3 创建 tunnel，填写命名
[图片]

补充 4 选择你的操作系统
[图片]
window 系统
[图片]
1. 选择 Windows 和 64-bit
页面上已经默认选中 Windows 和 64-bit（如果你的电脑是 32 位，选择 32-bit）。
2. 下载安装 Cloudflared
  - 点击页面上的下载链接（通常会跳转到 GitHub），下载 cloudflared.exe 文件。
  - 下载完成后，把 cloudflared.exe 放到你喜欢的文件夹（比如 C:\cloudflared）。
3. 以管理员身份打开命令提示符
  - 在 Windows 搜索栏输入“cmd”，右键“命令提示符”，选择“以管理员身份运行”。
4. 安装 Cloudflared 服务
  - 在命令行中输入页面给出的命令
[图片]
5. 完成后，页面会自动检测到连接器
  - 安装成功后，页面下方会显示已安装的 connector，然后你可以点击“Next”继续后续配置。
 Mac 系统
[图片]
1. 选择 Mac 系统
在“Configure”页面，点击操作系统选项中的“Mac”，页面会自动切换并显示适用于 Mac 的安装命令。
2. 打开终端（Terminal）
在你的 Mac 上，按下 `Command + 空格`，输入“Terminal”，回车打开终端。
3. 复制页面上的安装命令
页面会显示类似下面的命令（以实际页面为准）：
[图片]
或者如果没有 Homebrew，可以复制左侧的代码执行
[图片]
4. 页面会自动检测
当你正确安装并运行 cloudflared 后，页面下方会显示已安装的 connector，然后你可以点击“Next”继续后续配置。

5.点击名称
[图片]
6.点击 edit 按钮
[图片]
7.点击 public hostname
[图片]
8.点击 Add a public hostname
[图片]
9.参照截图填写需要的信息
url:127.0.0.1:3000
[图片]
10.点击保存
[图片]


补充讲解：关于https和http的区别： SSL（Secure Sockets Layer）
 中文叫：安全套接字层协议。
简单来说：
它是一种让网站和用户之间的通信变得加密、保密、防篡改的技术。

---
✅ 举个简单例子
你访问网站：
没有 SSL：http://hahah.com
 → 数据是明文传输，黑客可以中途窃听、篡改。
开启 SSL：https://hahah.com
 → 数据全程加密，黑客就算拦截，也是乱码，安全。

正式环境：填写你购买的域名

3.5.4 Supabase 配置用户邮箱注册
为了能让你的用户实现正常的注册、登录，首先我们需要配置，用户通过他的邮箱能够实现自由注册
1.点击 Authentication
[图片]
2.点击 sign in/up
[图片]
3.点击 email
[图片]

4.完成功能的开关配置
[图片]
5.点击 save
[图片]

【新增】3.5.5 Supabase 配置 google 账号登录
由于海外账号通常使用 Google 账号进行登录，所以我们进行 Google 账号的配置教学
在这里会用到一个新的平台：Google 开发者平台 console.cloud.google.com
跟着我们的步骤，一步步来完成
首先在 Google 开发者平台 console.cloud.google.com 中，完成相关配置
1.打开 console.cloud.google.com，新建项目
[图片]
2.点击导航菜单
[图片]

3.点击【API 和服务】-【凭据】
[图片]
4.点击创建凭据
[图片]
5.选择 OAuth 客户端 id
[图片]
6.填写信息
[图片]
如果界面不一样，就是因为出入进入需要进行认证，不要慌，认证即可
1.打开 supabase.com，点击 Authentication
[图片]
2.点击【signin/up】-【Google】
[图片]

3.复制 callback url
[图片]

4.返回 Google 开发平台，粘贴网址
[图片]
5.填写【开发环境地址】+【/auth/callback】
[图片]
6.填写【正式环境地址】+【/auth/callback】
[图片]
7.点击创建
[图片]
8.弹出项目信息弹窗
[图片]
当你完成到这里，恭喜你，Google 开发平台上的任务已经完成啦，接下来需要将信息填写到 Supabase 中
1.复制客户端 ID
[图片]
2.打开 Supabase，粘贴
[图片]
3.复制客户端密钥
[图片]
4.打开 Supabase，粘贴，接着打开开关，最后点击 save
[图片]

接下来，我们需要在 Supabase 中配置 url
1.点击 Authentication
[图片]
2.点击 URL Configuration
[图片]
3.点击 add url
填写【正式环境地址】+【/auth/callback】
[图片]
4.填写【开发环境地址】+【/auth/callback】
注意：此处填写的两个 url，必须与你在 Google 开发中填写的两个 url，完全一致
[图片]
5.替换正式地址，点击保存
[图片]
6.进行复查
[图片]
恭喜你！这个时候你的网站已经可以正常登录，注册了
[图片]
[图片]
[图片]
[图片]


3.5.6 Creem.io 测试环境支付配置
creem 是比较适合新手的支付系统，在本环节中，你将在测试模式下，用测试卡进行充值，来测试你的网站
登录或注册 Creem.io - https://www.creem.io/ 
1.点击登录
[图片]
2.打开测试模式
[图片]
3.进入开发者模式
[图片]
4.复制 API
[图片]
5.粘贴到。env.local 中
[图片]
6.点击 webook，再点击创建
[图片]

https://starterkit-chi.vercel.app/api/webhooks/creem
7.创建开发环境 webhook
【上一步获得的开发环境】+【/api/webhooks/creem】
[图片]
8.创建正式环境 webhook
【正式环境】+【/api/webhooks/creem】
[图片]

9.点击开发环境 webhook
[图片]

 10.复制密钥
[图片]

11.粘贴到。env.local 中，记住，填写后一定要保存
[图片]
12.在 creem 中创建产品
[图片]

13.填写信息
[图片]
14.点击创建
[图片]
15.复制产品 id
[图片]
16.粘贴到代码中（可以让 Cursor 配），记住保存
[图片]

env 更新后，终止开发环境运行（快捷键 control+c），再次运行 npm run dev
祝贺你！现在你的网站，用户可以支付啦
点击支付
[图片]
测试卡号：4242 4242 4242 4242
[图片]
支付完成
[图片]
权益变化
[图片]

3.5.7 主体功能开发
拉取代码，打开一个新项目
1.Cursor 打开项目，运行 npm i
[图片]
2.让 AI 了解项目结构
[图片]
3.描述新增功能需求
[图片]
4.查看效果
[图片]

### 任务目标
1.我想要调用deepseek的API，做一个AI功能：重生之老板是我小秘，用户输入“老板的姓名”“爽文的内容题目”，AI帮用户进行生成；
2.为了保持代码的一致性，我想要在components文件夹下，增加一个product 文件夹，新增功能的components文件尽量存放在这里；
3.新增的功能，放在components/logo.tsx下方；
4.deekseep的key，不要直接暴露在代码中，帮我写到env.local中

### 任务背景
1.整个框架的代码是没有问题的，注意不要改动其他功能
2.新增功能的样式风格与原有风格一致，参考截图

### 可能用到的信息
deepseek API文档：@https://API-docs.deepseek.com/zh-cn/API/deepseek-API @https://API-docs.deepseek.com/zh-cn/API/create-chat-completion @https://API-docs.deepseek.com/zh-cn/API/create-completion 
2.deepseek 的 key：sk-3742ae0732a64

3.5.8 效果优化
在我们做 AI 产品优化中，从大到小进行优化
页面风格 ➡️ 组件类型 ➡️ 单一组件优化 ➡️ 配色 ➡️ 按钮 ➡️ 细节逻辑
1.修改页面整体的风格
描述需求
[图片]

功能查看
[图片]

2.深化功能
很显然，以当前的产品功能，是玩具阶段，并不能成为一个有赚钱机会的产品，所以，我们来把功能做深
创作能力升级
预设多种爽文场景（豪门、总裁、甜宠、玄幻……），一句话快速切换。
角色自定义与养成
支持用户编辑角色属性（性格、身份、背景故事），AI 根据属性“塑造”人物台词与行为。
引入角色成长曲线，随着用户创作次数，角色会自动“升级”出现更多强化剧情。
[图片]
[图片]
当前生成的内容，文字不够长，且格式不好看，进行优化
[图片]
[图片]

以此类推，按照本课程的知识，逐步完善你的产品...

3.5.9 Creem.io 正式环境支付配置
确定产品付费权益
[图片]
配置 creem 正式付费
1.新建一个商店
[图片]
2.命名新的商店
[图片]
 3.创建付款产品，获取 id
[图片]

4.代码更新
[图片]
5.配置 webhook
[图片]
6.获取 webhook 配置信息
[图片]
7.获取 API 的 key
[图片]

8.在 env 文件中更新
[图片]
- 线上部署
https://wish-ashy-phi.vercel.app/

- Creem.io被拒思考与应对流程
一、拒绝原因自我排查思路
在你收到Creem.io拒绝后，第一步是冷静、系统地自查以下关键问题：
暂时无法在飞书文档外展示此内容
[图片]




---
二、收到拒绝后的冷静应对流程
✅ 不要第一时间情绪化回复官方邮件，避免拉黑风险
 ✅ 系统性整改产品，重新打造符合平台要求的版本
 ✅ 以下为具体整改步骤：
文档与政策整改
撰写完整的《隐私政策》《服务条款》
明确声明禁止色情、暴力、侵犯肖像权内容
公布生成内容用途限制（仅限个人、非商用）
示例参考：
  “本平台严禁上传或生成任何色情、暴力、侵犯他人合法权益的内容。”
  “生成内容仅供个人娱乐或学习使用，禁止用于商业用途。”
产品功能整改
上传功能需增加限制提示：“请勿上传裸露、暴力、侵犯版权内容”
Prompt输入框旁边提示合法合规信息
隐藏或彻底去除NSFW功能，至少不公开展示
限制输出内容尺寸、时长，避免被误解为盗版、色情平台
在网站底部标明AI模型来源与授权情况
网站页面整改
删除“无限制生成”“任何内容生成”等夸大用语
替换为：
  “基于提示词智能生成图像，每日限量”
  “生成个性化短视频，适合社交分享”
产品介绍页面风格偏中性、工具型，避免娱乐、情色倾向
申请资料准备
公司注册信息、负责人身份信息
产品功能介绍视频（重点展示合规部分）
完整的隐私政策、服务条款页面截图
AI模型使用授权证明（如开源协议截图）

---
三、重新申请流程
彻底整改产品，至少外观与核心功能焕然一新
用不同的域名、邮箱注册，避免因历史记录被识别
产品上线前，提前准备好合规文档与资料
申请时备注强调：
  已经严格整改产品
  明确限制NSFW、暴力、违法内容
  有完整的内容合规政策与技术机制
  模型来源合法，用途限定个人使用

---
四、常见错误与避免建议
暂时无法在飞书文档外展示此内容

---
五、总结建议
✅ 拒绝不可怕，思路混乱、产品不改才最致命
 ✅ 按照“自查→整改→重新申请”标准流程操作
 ✅ 站在支付平台立场思考——他们最怕色情、暴力、盗版、欺诈，你的产品要让他们放心
 ✅ 如不确定，找o3代写《合规使用声明》《隐私政策模板》或模拟审核预检


[图片]

四、如何利用低代码平台

【新增】4.1 扣子coze（可选）

扣子coze是国内友好的低代码配置平台，在本章节，重点掌握搭建思路，实际生产推荐n8n

在接下来的实操中，你需要用自己的key，教程中的扣子项目信息，仅为演示不会永久生效

以ai问数产品为例，用户询问：“我今天赚了多少钱”，产品给出：“你今天赚了 1 个w，同比去年的今天增长 10%，相比过去 7 天最高点上周三少了 20%”

扣子搭建思路
暂时无法在飞书文档外展示此内容

真实服务链路
暂时无法在飞书文档外展示此内容

实战一：快速开发工作流套壳

文章转播客

打开 
https://www.coze.cn/template

找到
[图片]

注意：为了简单起见，课程只演示“工作流”类型。请只关注列表里带“工作流”标识的内容
[图片]


亲自试用，发现效果挺好的
[图片]

点击复制
[图片]
[图片]


查看并学习它的流程，点击试运行
[图片]
输入内容
https://mp.weixin.qq.com/s/KFz1qZffe5vPctofIb6Q-Q

输出结果：
{
  "audio": "https://lf-bot-studio-plugin-resource.coze.cn/obj/bot-studio-platform-plugin-tos/0722f4fb-fb1a-4bf1-878b-2af2d0b79bdf.mp3",
  "cover_url": "https://p9-bot-workflow-sign.byteimg.com/tos-cn-i-mdko3gqilj/f9bba2e7d28a4d66b0e760ffa422fbf0.png~tplv-mdko3gqilj-image.png?rk3s=c8fe7ad5&x-expires=1781542585&x-signature=OiZghTBcEhWgptnEr5HGlekbzYU%3D"
}

点击发布
[图片]

获得调用API需要的信息

调用所有API都一样，需要凑齐以下要素。

只要凑齐以下要素，无论是人类程序员还是AI程序员，都可以一次性调试API成功。 

反之，如果API调用不成功，往往是这四个要求的一个或多个有问题。

1. API KEY （有些平台叫令牌、有些叫API Secret）
2. API调用的示例代码
3. API调用的示例输入
4. API调用的示例输出

coze平台的API要素获取，相对其他成熟的API平台，更难一些。这是coze平台的问题。

但是反过来想，如果你在coze平台都搞定了API，那其他平台的API，就更不在话下了。

接下来我们手把手演示如何获取coze平台的API要素

- 找到访问令牌

打开coze API，设置个人访问令牌

https://www.coze.cn/open/oauth/pats
为了方便，我全选。 （学习的时候可以图方便，正式发布要遵循最小授权原则，不能“全选”）
[图片]
[图片]

复制令牌，找个安全的地方存下来。



- 找到Workflow ID

找到我们发布的工作流
路径：个人空间-发布管理-工作流
[图片]

把Workflow ID复制，存下来

它做地址栏的最后面。比如，我的地址是 https://www.coze.cn/space/7336791143255949364/publish/workflow/751278980907026xxxx
Workflow ID 是751278980907026xxxx
[图片]


- 获得“示例输入”

点击你之前试运行时候的日志

路径：个人空间-发布管理-工作流-刚才发布的工作流-日志

随便点击一个之前已经成功运行的
[图片]
[图片]

“输入”区域复制，保存下来，作为API的“示例输入”。后面会用到。

我复制的示例输入是
```Plain Text
{
  "article_url": "https://mp.weixin.qq.com/s/mpxCeIdArsUgbaV4sEGJtQ"
}```

- 获得“示例输出”

打开
https://www.coze.cn/open/playground/workflow_run

填入我们的Workflow ID、 访问令牌、输入参数。

在Playground中点击「运行」，看看是否成功返回。可能需要等待一定时间，才会出现“返回结果”。等待的时间，每个API不一样。  对于我们演示的“文章转博客”来说，大概需要等待3分钟。

如果下图「返回结果」的右上角显示绿色的200，说明是API成功调用了。
成功调用API，不一定意味着“已经成功运行”。请仔细看看「返回结果」里的内容，如果包含了你需要的“正确结果”，才能说明是成功运行。

请手动检查，确保输出内容包含正确的内容。
例如，里面是否包含一个mp3音频地址？如果不包含，说明调用失败了。
再例如，里面的mp3音频地址，你点击听一听，是否是正确的？如果不正确，也说明调用失败了

[图片]

我复制的“返回结果”（也就是“示例输出”）是

```JSON
{"code":0,"cost":"0","data":"{\"audio\":\"https://lf-bot-studio-plugin-resource.coze.cn/obj/bot-studio-platform-plugin-tos/d6ae15a3-4f06-4da8-8569-bb5876ac7648.mp3\",\"cover_url\":\"https://p3-bot-workflow-sign.byteimg.com/tos-cn-i-mdko3gqilj/340c38c6cdb64f8cae4739969c06f2ae.png~tplv-mdko3gqilj-image.png?rk3s=c8fe7ad5&x-expires=1780325862&x-signature=coJdOvaIFk8kCIsa8v3ypKdqqJo%3D\"}","debug_url":"https://www.coze.cn/work_flow?execute_id=7512850590272094244&space_id=7336791143255949364&workflow_id=7512789809070260224&execute_mode=2","msg":"Success","token":5039}```

- 获得“示例代码”

当你确定“返回结果”是正常的，需要你再复制“示例代码”

[图片]

我的“示例代码”如下

```JSON
curl -X POST 'https://api.coze.cn/v1/workflow/run' \
-H "Authorization: Bearer pat_JM3eU8LnaptiPdQAUlWwSL98lNtuR774hkobS45nE8AgCFrp1vwMtd3wMftj6Xtd" \
-H "Content-Type: application/json" \
-d '{
  "parameters": {
    "article_url": "https://mp.weixin.qq.com/s/mpxCeIdArsUgbaV4sEGJtQ"
  },
  "workflow_id": "7512789809070260224"
}'```


我们写一个简单的需求，附带上文的关键API信息，到ai编程中实现。

所谓的关键信息，那就是上文所说的：
- “示例代码”
-  “示例输入”
- “示例输出”
- “API KEY” （在本案例里，API KEY已经被保护在了“示例代码”中），也就是下文标黄的部分

可选：为了方便排查，我们可以要求V0/Cursor在编码API过程中，添加更多的日志
##特别提醒
- 调用API的时候，请你添加尽可能多的日志，方便我们排查问题
- 再次强调，API的超时时间设置为300秒

完成的Prompt，我是这样写的，供你参考（替换为你自己的项目信息）

##需求

我要制作一个“文章转播客”工具。

用户输入：一篇文章的URL，点击按钮进行
用户将会看到的输出：程序调用API，返回音频文件、头图。

每次处理需要大概3分钟的时间，请增加足够好的loading动效和进度条，缓解用户焦虑。
并且做一个很好的交互，提示用户不要走开，大约需要3～5分钟。

请设置好合理的超时时间，网络请求你可以设置为5分钟超时。


##技术栈
NextJS(App Router)
TailwindCSS
shadcn/ui

##设计需求
1.界面精美、简洁。


##API示例调用代码

curl -X POST 'https://api.coze.cn/v1/workflow/run' \
-H "Authorization: Bearer pat_JM3eU8LnaptiPdQAUlWwSL98lNtuR774hkobS45nE8AgCFrp1vwMtd3wMftj6Xtd" \
-H "Content-Type: application/json" \
-d '{
  "parameters": {
    "article_url": "https://mp.weixin.qq.com/s/mpxCeIdArsUgbaV4sEGJtQ"
  },
  "workflow_id": "7512789809070260224",
  "is_async": false
}'

##API示例输入

{ "article_url": "https://mp.weixin.qq.com/s/mpxCeIdArsUgbaV4sEGJtQ" }

##API示例输出

{"code":0,"cost":"0","data":"{\"audio\":\"https://lf-bot-studio-plugin-resource.coze.cn/obj/bot-studio-platform-plugin-tos/d6ae15a3-4f06-4da8-8569-bb5876ac7648.mp3\",\"cover_url\":\"https://p3-bot-workflow-sign.byteimg.com/tos-cn-i-mdko3gqilj/340c38c6cdb64f8cae4739969c06f2ae.png~tplv-mdko3gqilj-image.png?rk3s=c8fe7ad5&x-expires=1780325862&x-signature=coJdOvaIFk8kCIsa8v3ypKdqqJo%3D\"}","debug_url":"https://www.coze.cn/work_flow?execute_id=7512850590272094244&space_id=7336791143255949364&workflow_id=7512789809070260224&execute_mode=2","msg":"Success","token":5039}


基本上可以一次通过

[图片]


实战二：快速开发Agent套壳

比如热点追踪助手https://www.coze.cn/template/agent/7434020892310700086?
将模板内容复制
[图片]
进行测试和调整
[图片]

点击发布
[图片]
勾选api
[图片]

等待发布完成
选择api
[图片]

点击运行
[图片]

确认结果正确后，复制输入示例
[图片]

注意
改模板中的任务流，代码处理需要增加一个兜底逻辑
进入工作流编排
[图片]
增加兜底逻辑
[图片]
```Python
async def main(args: Args) -> Output:
    params = args.params              # ← Coze 固定写法
    news = params.get("news") or []   # ⚠️ None 时回退为空列表

    if not news:                      # 也可以直接提前返回或抛自定义异常
        return {
            "markdown_str": "⚠️ 暂未获取到任何新闻，请稍后重试。",
            "count": 0,
        }

    markdown_str = ""
    for item in news:
        media_name = item.get("media_name", "")
        time       = item.get("time", "")
        summary    = item.get("summary", "")
        title      = item.get("title", "")
        url        = item.get("url", "")

        markdown_str += (
            f"### {title}\n\n"
            f"**来源媒体**：{media_name}\n\n"
            f"**发布时间**：{time}\n\n"
            f"**摘要**：{summary}\n\n"
            f"[点击这里查看详情]({url})\n\n\n"
        )

    return {"markdown_str": markdown_str, "count": len(news)}
```

拼接 prompt
##需求
我要制作一个“热点ai搜集”网站工具。

用户输入：热点事件
用户将会看到的输出：程序调用API，返回的热点文字信息、图。

每次处理需要大概1分钟的时间，请增加足够好的loading动效和进度条，缓解用户焦虑。
并且做一个很好的交互，提示用户不要走开，大约需要1分钟。

请设置好合理的超时时间，网络请求你可以设置为5分钟（300秒）超时。

##技术栈
NextJS(App Router)
TailwindCSS
shadcn/ui

##设计需求
1.界面精美、简洁。

##API示例调用代码
curl -X POST 'https://api.coze.cn/v3/chat?' \
-H "Authorization: Bearer pat_J7xKGzO4mhWTZudBtJejlzoV9fLK6kN15ca4RKoAcN1EYCWsKEemOhdCPMhizXDp" \
-H "Content-Type: application/json" \
-d '{
  "bot_id": "7518334976321388556",
  "workflow_id": "7518339855773564940",
  "user_id": "123456789",
  "stream": true,
  "additional_messages": [
    {
      "content": "hello",
      "content_type": "text",
      "role": "user",
      "type": "question"
    }
  ],
  "parameters": {}
}'


##API示例输入

[
  {
    "content_type": "text",
    "content": {
      "text": "华为",
      "image_url": null,
      "file_url": null
    }
  }
]

##特别提醒
- 调用API的时候，请你添加尽可能多的日志，方便我们排查问题
- 再次强调，API的超时时间设置为300秒
- Coze API返回的是一个异步任务状态，而不是直接的流式结果
- api调用的说明文档 https://www.coze.cn/open/docs/developer_guides/chat_v3

[图片]

[图片]

实战三：自己构思Agent（难）
- 案例 ：每日新闻摘要
基于Coze（扣子）平台搭建一个基于工作流的每日新闻摘要 AI 智能体。智能体会根据用户提供的行业或关键词主题，自动检索相关新闻并生成摘要和关键词，结果每天定时写入飞书多维表格

步骤 1：创建智能体
进行创建
[图片]
选择模型
[图片]

添加人设
```Plain Text
# 角色
你是一位智能新闻助手，擅长迅速、准确地收集和整理每日新闻摘要。

# 职责
- 用户提供一个行业或主题关键词后，你会自动检索该领域当日最新新闻。
- 你将使用联网插件获取新闻内容，并利用大模型提取关键词、生成摘要和简单趋势分析。
- 你会将整理后的结果保存到飞书多维表格（包含日期、标题、摘要、关键词、来源链接字段）。```

添加插件
[图片]

[图片]

[图片]

也可以根据提示词，自动加入一些可能合适的插件
[图片]

步骤 2：创建飞书多维表格

飞书开放平台 App ID
1. 进入 飞书开放平台 (https://open.feishu.cn) 并登录开发者账号。
2. 在左侧导航点击 「应用」→ 找到或创建你的 企业自建应用。
3. 进入应用详情页后，左侧点击 「凭证与基础信息」。
4. 在页面顶部即可看到 App ID / App Secret，点击右侧 复制 按钮即可拿到 App ID。(open.feishu.cn)
⚠️ 如果你还没有应用，需要先「创建应用」→「企业自建应用」，填完名称后再进入上述页面。
创建应用
[图片]
获取id  cli_a8d824cfc6fe101c
[图片]
5. 发布应用
[图片]

多维表格文件夹 token（folder_token）
多维表格（Bitable）实际上存放在「云空间」的文件夹下，所以要取文件夹 token：
创建文件夹
[图片]

获得url
[图片]

1. 在飞书客户端或浏览器打开 「云空间」，进入你希望存放多维表格的那个文件夹。
2. 在地址栏（或「复制链接」得到的 URL）里找到类似
```Plain Text
https://sistine-tech.feishu.cn/drive/folder/IyNufUsLUlwZ9LdprAncfyaCnEc```
1. /folder/ 之后、? 之前的那一段就是 folder_token，通常以 FLD 或 fld 开头。
2. 只需复制这串字符（不要包含斜杠或问号之后的参数）即可。(open.feishu.cn)

我的数据为：IyNufUsLUlwZ9LdprAncfyaCnEc


---
常见坑 & 提示
暂时无法在飞书文档外展示此内容








五、如何将应用部署到自己的服务器？

5.1 什么是 Dokploy
dokploy 作为一款新兴的开源自托管 PaaS（平台即服务）解决方案，可以在自己的服务器上部署项目发版。

注意：新手建议使用Vercel，避免引入其他麻烦。
直到你发现有一天用户太多、Vercel不够用了，再过来折腾Dokploy。

Dokploy 还可以监控你服务器的状态、备份数据库、管理证书、管理多个服务器等等

5.2 安装 Dokploy

5.2.1 服务器租赁
服务器的操作系统建议选择 Ubuntu 22.04，环境配置确保已安装 Docker。
在任意的服务器租赁平台，租赁服务器即可，或者也可以选用自己的服务器。一般我使用腾讯云海外的服务器。

5.2.2 安装
在终端中，运行以下代码
curl -sSL https://dokploy.com/install.sh | sh

如果显示权限不够
- 先运行
su root

- 再运行
curl -sSL https://dokploy.com/install.sh | sh

官网参考文档：https://docs.dokploy.com/docs/core/installation

等待一段时间，运行成功后，会看到返回的 3000 端口链接
[图片]

5.3 配置 Dokploy

5.3.1 配置防火墙
为便于开发，在服务器租赁平台的防火墙中配置，允许 3000 端口可被外部访问

5.3.2 访问管理员平台
复制地址
[图片]
前往注册界面
[图片]
进入管理平台
[图片]

5.3.3 配置域名
在域名的 DNS 解析中添加一条记录，类型是 A，将配置的域名指向服务器的 IP 地址。
[图片]

DNS 解析配置后，我们就可以通过 https+域名的方式来访问服务器上的 Dokploy

配置 GitHub
点击左侧菜单 Git，选择 GitHub，依次操作，完成 GitHub 应用的创建和配置，完成之后你可以在 https://github.com/settings/apps 中查看这个 GitHub 应用。
点击 git-点击 GitHub
[图片]

点击创建
[图片]

创建到 GitHub 中
[图片]

接着进行 GitHub 的授权
点击图标
[图片]
确定授权
[图片]


部署 NextJS 应用
在 Dokploy 的 Projects 中，新建 Project，再新建 Application，配置 Provider 为 GitHub，选择项目仓库和分支
新建项目
[图片]

新建 Application
[图片]

选择项目配置
[图片]

构建类型选择 Dockerfile，并设置 Dockerfile 文件的路径。配置好之后，点击 Deploy 触发构建。
选择 Nixpacks 类型
[图片]



绑定域名
构建成功之后，我们就可以绑定域名，然后通过域名访问这个应用。在 Application 的 Domain 中，点击 Add Domain，如果你有自己的域名，那么输入一个域名，如果没有域名可以点击右侧的骰子，它会自动生成一个 xxx.traefik.me 的域名。
在域名购买平台，配置域名 DNS，IP 填写租赁的服务器的
[图片]
增加 domain
[图片]

填写域名
[图片]


等待一段时间之后，就可以访问这个 NextJS 应用。
[图片]

利用 GitHub Actions 构建镜像
前面的流程是直接在服务器上构建并部署，这样的操作一般情况下没啥问题，但在服务器高负载时，网站性能可能受到影响，所以我们可以考虑利用 GitHub Actions 来构建镜像，镜像托管在 GitHub 镜像注册中心，服务器上的 Dokploy 只负责从 GitHub 容器镜像中心拉取最新镜像，然后部署上线就行。

创建 GitHub Token
首先要创建一个 GitHub Token，这个 Token 需要有权限拉取你上传到 GitHub 镜像注册中心的镜像，你可以在这里创建一个 Token。
选择权限
[图片]

复制创建后的 token



配置 Registry
在 Dokploy 的 Docker Registry 配置中，新建一个外部 Registry，Username 是你的 GitHub 账号名，Password 是上面创建的 Token，URL 是 https://ghcr.io。
增加 Registry
[图片]
填写信息
[图片]
创建成功
[图片]

重新配置部署方式
为了演示，这里我新建一个 Application，这次我们换成 Docker 的部署方式。首先在应用的高级设置中，设置 Registry 是我们刚才创建的 Registry。
回到项目
[图片]
创建 Application
[图片]

选择刚刚创建的，点击 save
[图片]

然后，配置部署参数，Docker Image 是（ghcr.io/[GitHub 账号名]/[Repository 项目名]:[分支名]），然后保存。意思是，部署时，Dokploy 去 Registry 中找到这个 Docker 镜像，把最新镜像拉取下来并部署上线。
填写信息，点击 save
[图片]


配置 GitHub Actions
上面的流程只配置了如何拉取镜像，现在还剩下如何利用 GitHub Actions 构建镜像。这需要在 GitHub Actions 中新增一个 workflow，当我们提交代码到 main 分支的时候，workflow 会自动执行，构建镜像并 push 到 GitHub 镜像中心。
[图片]
[图片]
需要注意和调整的地方
1. Azure Web App 名称：AZURE_WEBAPP_NAME 需要替换为你实际的 Azure Web App 名称。
2. 发布配置文件：你需要按照注释中的步骤，从 Azure 门户下载发布配置文件，并将其内容作为名为 AZURE_WEBAPP_PUBLISH_PROFILE 的密钥添加到 GitHub 仓库中。
3. 项目路径：AZURE_WEBAPP_PACKAGE_PATH 默认为仓库根目录，如果你的 Node.JS 项目不在根目录下，需要将其修改为实际的项目路径。
4. Node.JS 版本：NODE_VERSION 可以根据你的实际项目进行调整。
需要注意的是结尾有个触发 Dokploy 重新部署的逻辑，这里涉及到 Deployment Webhook URL，Dokploy 上部署的项目都有一个 Deployment Webhook URL，只要访问这个 URL 就会自动触发重新构建
[图片]

测试访问
待部署成功之后，我们同样可以绑定域名，配置 DNS 解析，然后就可以通过域名进行访问了。

如果遇到 build 失败的问题，处理思路与 vercel 同理

Dokploy 其他功能
Dokploy 的功能还有很多，一篇文章很难讲完，下面列举几个我觉得不错的功能。

- 自动清理 Docker 容器
如果你长期使用服务器既构建又部署，很容易导致太多没用的 Docker 容器占用磁盘空间，导致磁盘空间满了而访问不了，可以在 Server 设置中开启 Daily Docker Cleanup，就会每天自动清理不用的 Docker 容器。

- 服务器监控
Dokploy 还自带了服务器监控的能力，你可以直接查看服务器的 CPU 利用率、内存利用率、磁盘空间，以及网络 IO 等。
[图片]

- 数据库部署和备份
Dokploy 也可以部署数据库，常见的数据库 Postgres、MySQL、MongoDB 都支持，部署之后，设置了外网访问端口就可以访问了。
[图片]

在 External Port 中设置一个端口号，然后保存就可以得到一个 DB URL，只要防火墙配置中允许访问服务器的这个端口号，那么就可以连接数据库了。
[图片]

下面用免费的 Navicat Premium Lite 配置好数据库连接信息测试连接没问题。
[图片]

- 模板
我最喜欢的就是模板功能，很多优秀的开源项目都可以一键部署，例如我现在的个人博客 Ghost、统计分析工具 Plausible 都是通过 Dokploy 一键部署的。你甚至可以一键部署 Supabase、Wordpress、Pocketbase 等项目，希望将来支持的应用越来越多。
[图片]
除此之外，Dokploy 还支持管理其他的服务器，支持管理证书等等，有些功能我也还没有用上，等将来用上了再来分享。

[图片]

六、如何挖掘需求、获得源源不断的产品 idea

6.1 幸福的方式

核心关键词是收集抱怨。
养成收集抱怨的习惯，认真享受生活。日积月累，你会有做不完的产品 idea。

世界上只有两种人，一种人「完全没有产品 idea」，一种人「产品 idea 多到做不完」。

我仔细思考，发现这两人只有一个区别： 是否有「收集抱怨」的习惯。 

最重要的品质是耐心。

他们都带着各自的习惯，去享受自己的生活。日积月累，习惯于在自己生活中收集抱怨的人，自然而然就收集到了海量的、不断深入的原生 idea （ organic idea）。

去做这样的产品，你的幸福感会很强。因为这样的机会，只属于你，同时满足热爱、擅长、被人需要。

对于我所在的「以 AI 应用开发 AI 应用」这个小小的领域举例，在我享受生活的过程中、在和同行交流的过程中，我会发现一大批产品机会。这些产品机会，全部同时满足热爱、擅长、被人需要。

[图片]

例如
1. 每个做产品的团队都需要找 KOL。能否做一个 7x24 自动联系 KOL、自动沟通、自动检测结果的 Agent 产品？技术上是可以实现的。
2. 小型开发团队做产品，设计感不强。能否做出来一个产品或者一个解决方案，让小型开发团队快速拥有专业、高端、漂亮的产品界面和交互？  技术上也是可以实现，比如可以使用类似 https://same.new 的技术。https://same.new  所解决的问题，和我提的这个问题有重叠的部分，但是侧重点不同。
3. 小型开发团队需要做 SEO，能否做出来一个产品，自动帮助一个产品做 SEO 呢？
4. 承接 3，哪怕我们把“SEO”进一步细分到“外链建设”，都大有可为。能否 7x24 自动联系 Guest Post 的产品？能否有 7x24 自动提交导航站、目录站的产品？
5. 每个 MVP 产品都需要找种子用户。能否提供一个产品，收一个打包价格（如$1000），自动帮它找到尽量多的精准用户？实现方案也难，可以用 Agent 方案，去做自动投放、自动发帖、自动回帖等等。
6. ……

你想想看，这些产品 idea 来自哪里？ 不就是因为我在享受自己生活的过程中，不断在收集抱怨吗？来自自己的抱怨、朋友的抱怨、同行的抱怨。 

如果你不在「以 AI 应用开发 AI 应用」这个圈子里，你可能无法发现这些产品机会，你甚至无法了解这些产品机会为啥会让这个圈子的人兴奋，更谈不上看到他们的商业价值啦。

每个人都有自己独特的生活、独特的体感、独特的优势。独特的你，请从今天开始认真生活，好好的收集抱怨吧。 

在学员群里，大家可以互相启发，互相去看看别人的抱怨。 在你还没养成收集抱怨的习惯之前，你可能明明每天都会遇到很多抱怨，但是却没有意识到它们是抱怨、它们是产品机会点。

[图片]

6.2 功利的方式

核心关键词是供需失衡。
养成「寻找供需失衡点」的习惯，能发现很多可以赚钱，甚至可以快速见效的机会。

「寻找供需失衡点」，在不同的平台，有不同的机会。

供需失衡，往往是以「关键词」的方式出现的。

A. 通过 Google 搜索平台寻找

通过 Google 搜索平台寻找有利可图的搜索词

有利可图，是指搜索量尚可、搜索结果少、竞争不激烈。

生财有术的哥飞，是这个领域的专家。他辅导了很多人，通过这样的方式，拿到结果。

找「有利可图」的搜索词，思考以下问题
1. 为什么会有人搜索这个词？
2. 他们是谁？
3. 他们真实需求是什么？
4. 我们要制作一个怎样的产品，能满足他们的真实需求？
5. 我这个产品的盈利方式是怎样的？
6. 我们要到哪里去推广我们的产品，从而接触到更多用户？

我们可以借助一些工具来完成。

常见工具：

- https://trends.google.com/ （Google 官方工具，免费）
- http://semrush.com/  （淘宝有共享版本比较便宜）
- https://ahrefs.com/ （淘宝有共享版本比较便宜）

在判断是否有利可图环节，里面我最喜欢的工具是 Semrush
它可以直接告诉你每个词的竞争程度如何、需要你建立多少个外链就能登上 Google 搜索结果首页。

对于新手来说，早期可以去

我们以 card generator 这个词为例，在 Semrush 上，你首先需要关注到下图红框区域。竞争较大，不是一个对新手来说有利可图的词
[图片]

但是 tarot card generator 更像一个对新手有利可图的词。美国搜索量每个月 8K，竞争程度只有 29%，相对比较容易做到首页。
  
注：这个词只是示例，实际上它的搜索量偏小，你可以做到有利润，但是不会有特别高的利润规模。 请尽量去找到找到 30K 以上的美国搜索量、竞争程度绿色的词。

[图片]

再介绍另外一个方法： 通过一个种子词，快速找到可能的有利可图词。

假设我们对 tarot （塔罗牌）有点兴趣，我们可以以它为种子词。如下图所示。
注意用筛选条件，帮助你提高效率。
这里面，能够快速找到一些有利可图的词。
你可以一一深入分析，选择最有把握的来做。 —— 此处说的“有把握”，是指你能回答好本文开头的几个问题。
[图片]

B. 通过新闻寻找

特点：该方式可快速见效。是否能够持续有效却不一定，需要同时看趋势和你后续的努力。

刚才我们提到，供需失衡点，往往是以「关键词」的形式出现的

在 2025 年 1 月中旬，小红书 和 Tiktok 就是你要找的关键词。因为那个时候，Tiktok 美国突然下架了，有大量的“Tiktok 难民”逃离到小红书，这里面会但是很多的「供需失衡」。

比如
1. 老外想要给自己取中文名
2. 老外想要把自己 TikTok 的视频加上中英双语字幕
3. 老外想把小红书上的视频进行翻译，因为他看不懂。

在新闻刚刚发生的那一瞬间，需求强烈、供给几乎为零、竞争几乎为零！ 也就几天的窗口期，如果你能尽快发布产品、解决问题，你很快就能够获得真实用户、获得正反馈！

你可以结合他们的需求，快速发布产品。

C. 通过新技术寻找

特点：该方式可快速见效。是否能够持续有效，需要你对该技术的发展前景有预判。

方式和上一条“通过新闻寻找”很类似。

当一些新技术发布的时候，普通人很想体验。这一瞬间，就有供需失衡。

例如，2025 年 2 月春季期间，DeepSeek 火爆全国，这就是一个供需失衡： 官方的版本不稳定，根本无法使用。后来，大家也知道，这个机会被问小白和腾讯元宝抓住了。

尤其是腾讯元宝 。它本身是一个很老的产品，一直不愠不火，排不上号。由于它承接了 DeepSeek 在 2025 年 2 月的这一波流量，  后来它就直接起飞，每个月的用户都创新高。

到哪里寻找新技术呢？

以下都可以，从易到难：

1. 多刷浸泡 AI 自媒体
2. 多刷海外的开源模型社区 huggingface.com
3. 多刷 paper

我最喜欢的 2 和 3，比起二手自媒体，2 和 3 的方法，能够第一时间得到最一手的信息。
我建议你从 2 开始。

下图是 huggingface 的 trending 技术展示。
[图片]

最后再讲一个值得注意的地方：你一定要对新技术是否有前景，有预判。 因为，每周、每个月都会出现新的技术。大部分新技术，都是过眼云烟，不值得跟进。

预判能力，来自你的软实力。没有办法教，你可以靠时间去积累。

如果你完全无法判断的话，不妨试试：每个新技术都跟进，快速做产品。 大力出奇迹。我知道也有一些朋友，用这个方式取得了不错的成绩。

D. 「暗影复刻」策略

在小众垂类里挑一家头部 SaaS产品，复刻其 20 % 的核心价值（往往只对应 2-3 个功能），加上一两个该垂类用户一直想要却迟迟没排期的特性，然后用超低年费切入，最好再配合一个免费版。

为什么有效？ 小团队无法与完整产品硬碰硬，但只要解决目标群的“单点痛 + 被忽视需求”，就能迅速截留高意向客群。

一句话记忆：暗影复刻 = “只抄大厂 20 % + 补 1个痛点”，靠更快、更便宜、更专注赢得小量高粘用户


方法论框架（STEP 模型）

Select → Trim → Extend → Prove
暂时无法在飞书文档外展示此内容

实战流程（小白可照抄）

1. 快速调研
  - 浏览目标 SaaS 的 Reddit / Twitter / 产品路标，复制典型抱怨到表格。
  - 选出 重复率最高 + 自己能搞定 的 1-2 个痛点。
  - 可以使用ChatGPT-o3、ChatGPT-o3-pro、ChatGPT Deep Research工具，帮我们我们调研

2. 假 MVP
  - 直接用V0/bolt/lovable完成界面原型的流程，录屏发给 5 位潜在用户，看他们是否愿意预付 5 美元。

3. 真实MVP
  - 在第二步的基础上，套上API，完成有真实功能的产品MVP
  - 建议API采用coze/n8n快速实现，「积木式创新」

4. 上线 + 要钱
  - 免费层 = 主流 SaaS 同款功能（但有水印/限额）。
  - 专业层 = “被忽略特性” + 去水印，每月 5-9 美元；同时预设企业私有部署年费。

5. 放大渠道
  - 插件优先：同步做 Chrome / ChatGPT /VS Code / Cursor 插件，把大厂流量变漏斗。
  - 程序化 SEO：为每个痛点、每个用例生成独立落地页。

典型案例
暂时无法在飞书文档外展示此内容

练习

1. 作业 1：挑一个你常用 SaaS，列出 10 条社区抱怨，打分找出最适合影子化的痛点。
2. 作业 2：使用课程内提到的工具(建议：v0/same + n8n/coze + 任意starter)，在 48 小时内做出能“收钱”的最小流程；演示并汇报所花时间、成本、用户反馈。
3. 作业 3：写一份包含「免费层 / 专业层 / 私有部署层」的三明治定价表，并说明价格背后的成本结构。


总结

- 暗影复刻 ≠ 偷代码，而是精准剪裁+痛点补洞。
- 关键成功因素：极致聚焦 → 迅速收费 → 持续寻找新缺口。
- 对于小白：最难的不是写代码，而是敢于让用户付款、敢于删功能。


E. 「服务产品化」策略

在 Fiverr/Upwork 等平台上挑选一个高频小服务（月订单 500+），将其 80% 的重复性工作自动化，保留 20% 的人工调优环节，然后用 SaaS 订阅模式替代按次付费，配合免费试用快速获客。

为什么有效？ 服务商已经验证了市场需求，你只需要把"人力密集"变成"软件密集"，用更低成本、更快交付、更稳定质量来颠覆传统服务模式。

一句话记忆：服务产品化 = "抄热门服务 + 自动化 80% + SaaS产品化"，用软件效率击败人工服务

方法论框架（SOAP 模型）
Screen → Optimize → Automate → Package
暂时无法在飞书文档外展示此内容

实战流程

1. 快速调研
  1. 筛选服务：在 Fiverr 搜索框输入关键词（如"logo design"、"data entry"、"SEO audit"），按"Best Selling"排序
  2. 数据收集：选择月订单 300+ 的服务，复制其服务描述、交付物、客户评价到表格
  3. 可行性评估：问自己"这个服务的 80% 工作，能用现有 API 和工具完成吗？"
  4. 辅助工具：使用 ChatGPT-o3、Claude 等 AI 工具分析服务流程的自动化可能性

2. 流程分解
  1. 拆解步骤：把选中的服务拆解成 3-5 个标准步骤
  2. 标记类型：每个步骤标记为"可自动化"、"需人工"、"混合模式"
  3. API 匹配：为可自动化步骤找到对应的 API 或工具（如 OpenAI API、Canva API、Zapier）
  
3. MVP 搭建
  1. 工具选择：使用 V0/Bolt/Lovable 快速搭建界面
  2. API 集成：通过 Coze/N8N 实现后端自动化流程
  
4. 测试验证：
  1. 找 3-5 个朋友测试完整流程，记录问题和改进点
  2. 上架Fiverr，测试是否买家能够满意。手动交付服务的同时，推荐产品链接给它。

5. 定价上线
  1. 根据服务的不同情况，做定价策略

6. 获客渠道
  1. SEO 优先：针对原服务关键词做 SEO 页面（"free logo maker"、"automated SEO audit"）
  2. 社区营销：在相关 Reddit、Facebook 群组分享免费工具

7. 内容营销：制作"vs 人工服务"的对比内容

典型案例
暂时无法在飞书文档外展示此内容

练习

作业 1：服务筛选
1. 在 Fiverr 选择 3 个不同类别的热门服务（如设计、文案、数据处理）
2. 分析每个服务的标准流程，判断自动化可行性
3. 选出最适合的 1 个服务，说明选择理由
作业 2：MVP 实现
1. 使用课程推荐工具（V0 + Coze/N8N）搭建自动化流程
2. 在 72 小时内完成可演示的 MVP
3. 记录开发时间、使用的 API、遇到的问题

最重要的心态：不要试图完全替代人工，而是在关键环节提供更好的体验。人工服务的存在就是你的市场调研报告！

[图片]

七、如何获取健康且持续的流量？

备注：
1. 这部分内容来自我在生财有术的精华帖，有删改。该方法长期有效。
2. 在 2024 年底，Google 对于“程序化 SEO”做了较大的算法更新，它比以前更加强调价值了。你的页面内容是否是 AI 生成的关系并不大， 重要的是，你的页面内容是否对用户有价值？
3. 建议大家带着本讲的思路，拆解下面的网站：
  1. https://www.textstudio.com/
  2. https://www.yeschat.ai/

1. 无限、高品质的流量来自哪里

答案是搜索引擎。

来自搜索引擎的流量，是用户主动行为。流量精准，连绵不绝。

只有流量就足够了吗？
不够。
你得想办法留住流量。不然你的网站做不大。

有一些网站的数据，它每天的新访客占比甚至到了 90% 以上，这是典型的「留不住用户」的表现。我称之为「过路流量」。

2. 怎么留住从搜索引擎来的流量

从搜索引擎过来的流量，固然有办法提高，但它们大多是是新访客。因为老访客有其他方式访问你的网站，不太需要从搜索引擎找它。

怎么留住它们？ 价值。
你的网站内容得有价值。

有价值到这样的程度 —— 在用户通过 Google 找到了它以后，他会加入收藏夹、在未来反复访问、甚至会推荐给别人。

流量改变存量，存量改变世界。

我们想改变世界。
我们得两手抓，两手都要硬。

3. 搜索引擎喜欢什么样的网站

过去，现在和未来，搜索引擎喜欢什么样的网站？
全世界所有的搜索引擎，有三个不变的、公开的共性。做到以下三点，你的网站，不用再担心流量问题。
1）原创内容
2）持续更新的内容
3）高质量且相关的外链

你的内容，在搜索引擎准备收录时，它是第一次见到，没在别的地方见到过。
你的内容池子，会不断更新。
你的网站，拥有权重高且相关的外链。 注意，「外链质量」的重要程度，远大于「外链数量」。

关于外链的话题，我推荐吴军《数学之美》书中的一章，《PageRank — Google 的民主表决式网名》。这是我在中文世界中见过的最正派、最通俗易懂的关于 PageRank 的解读。

请多看几遍上述三点。

我这套获取网站流量的方法为什么不会失效？因为这套方法所依赖的根基，是现代搜索引擎在过去十年没有变、未来十年也不会变的核心算法。

常常有人问我：小排哥，今年 Google 的算法有什么变化？
我会告诉他，
与其关注「今年有什么变化」，不如关注「未来十年有什么不变」。

4. 如何从搜索引擎获取无限流量

拥有一个「持续更新原创内容」的网站，并且建立有价值的为数不多的外链。
这就够了吗？
不，还远远不够好。

我们很容易举出反例。比如，所有的原创博客，都符合这个条件。他们绝大多数都做不大，因为内容不够多，更新得太慢。
人哪能和机器比呢，别忘了，我们是一穷二白、啥也没有的屌丝。大团队可以靠人力，咱们小团队，需要靠机器。

你一个人写博客，还要求是高质量的博客，产生内容的速度，能比上生财有术吗？能比上天涯、猫扑、虎扑吗？
因此，让我们做一次升级，通过一些技术手段，引入「自动化」这个要素。我们要网站能够自动持续更新。

第一次升级：坚持长期主义，原创内容 ≠ 有价值的内容

拥有一个「自动持续更新原创内容」的网站，并且建立有价值的为数不多的外链。

还是不太对劲。
我们漏了价值观环节。

举个反例，你可以通过「狗屁不通文章生成器」https://suulnnka.GitHub.io/BullshitGenerator/index.HTML 对「今天中午吃什么」这个话题生成数千字的「原创文章」。它们真的狗屁不通，没有任何价值。
另一个反例，还有一种叫做 Article Rewrite 的技术，可以将你从其他内容源采集的文章进行「伪原创」。它们也毫无价值。 

「Article Rewrite」之所以短期可行，是因为它是在和搜索引擎算法斗智斗勇，暂时蒙蔽搜索引擎的双眼。 

同样的，「Article Rewrite」之所以长期看来不可行，也是因为它是在和搜索引擎算法斗智斗勇。搜索引擎就算今天能被你骗过，你能保证它永远不升级吗？ Google 的算法工程师领那份工资，可不是白领的。

事实上，得益于今天人工智能 NLP 技术的发展， Google 识别「Article Rewrite」已经越来越容易了。留给 「Article Rewrite」 的时间已经越来越少。

所以，坚持长期主义，我们需要谨记：原创内容 ≠ 有价值的内容。

「利他」是生财有术社群践行的核心价值观。「利他」的内容，就是有价值的。
在你做「Article Rewrite」 之前、在你用「狗屁不通文章生成器」之前，想想看，你产生的内容，是否「利他」？
相比之下，「狗屁不通文章生成器」的本身，反而是「利他」的，起码他有娱乐作用。

让我们引入价值要素，继续升级。

第二次升级：让内容合法

拥有一个「自动持续更新有价值的原创内容」的网站，并且建立有价值的为数不多的外链。
只要你能做到这一条，你根本不用担心流量。

在我的成功经验里，我几乎不会去建立外链。
因为当内容有价值了，自然有人去分享这些内容，形成了天然的外链。
衡量一个产品好不好，有一个最简单的角度 —— 是否有用户心甘情愿向自己的朋友推荐它。

对网站来说，这层推荐，就形成了外链。 
我们如果只专注到「有价值的原创内容」，就根本不用考虑外链的事情。

到了此处，还有一个小问题漏了。
合法问题。

「有价值」和「合法」是完全不重叠的两个事物。

著名的 P 站有价值吗？有啊，否则不会有那么多人每天去访问它，还付费。但是它不合法。
V 屁 N 有价值吗？有啊。但是，你在中国做个卖 V 屁 N 的生意试试看？

让我们继续升级。

第三次升级：通过做网站「长期能赚大钱」

拥有一个「自动持续更新合法的有价值的原创内容」的网站，并且建立有价值的为数不多的外链。

这句话虽然长，但请打印出来贴墙上。
只要能做到这句话，你的流量就会连绵不绝，你的网站就改变了世界。

说来简单。拥有一个「自动持续更新合法的有价值的原创内容」的网站。
这么多花花绿绿的关键词，是不是觉得特别难做到？

难就对了。
难的事才有意义。

记得我在《如何真正用好别人的认知和经验》里怎么说的吗？ 不难的事，人人都可以做到，没有差异化、也没有壁垒，做不大、做不长。

在「长远能赚大钱」 这件事情上，我们做的事，需要的技能越难越好。「短期挣小钱」 倒是可以不符合这条规则，甚至「越简单越好」。

「送外卖」 是一件简单的、能长期做、能挣小钱的事。

生财有术社群内的「外卖 CPS 保姆级教程」是简单的、不一定能长期做，能挣小钱的事。

「难」是相对的，我们追求的是「因为我特有的技能组合，使这件事对于大多数人很难，但对于自己不算太难」。

同样，举个题外的例子，「风险投资」这个词中的「风险」也是相对的。只是你觉得他们很有「风险」而已。对于专业的「风险投资」比如凯鹏华盈，能做到几十年的复合增长率 20% 甚至更高，它可不认为自己的事业有风险。「风险」不是风险投资行业的关键技能，「避险」才是。

说回来。我们的目标是，通过做网站「长期能赚大钱」。 它是一件困难的事。
我会为大家拆解这件困难的事，这才是我这套方法的价值。

5. 「自动持续更新」来自哪里

来自爬虫或者 API 。
比爬虫更好的是 API 。
不用赘述，大家应该已经很清楚了。如果只停留在这里，和做「垃圾站」是没有区别的。

请往下看，千万不要走邪路。

6. 「合法的」来自哪里

来自协议（ License ）。
有一些内容源，提供了有合法操作空间的协议，可以免费将它的内容用于商用。

例 1：Unsplash

https://unsplash.com/ 国外最大的图片分享网站之一。它的协议你可以理解为 「基本上你用来干啥都可以，都不用跟他打招呼」。详见 https://unsplash.com/license

[图片]

例 2：CC-BY-SA 协议

如果一个内容，根据 CC-BY-SA 许可协议发布，意味着人们只要正确地署上创作者的名字并根据相同的许可协议发布他们的作品，就可以批量复制您的作品，甚至可以销售它们。 这个协议有多个版本，请同学们自行 Google 。

顺便提一句，使用 CC-BY-SA 协议的内容源非常多，尤其是国外网站。请自行动手研究，我保证，你能挖到很多你不曾想过的宝藏。

例 3：WTFPL

还有一个神奇的协议，叫做 WTFPL ，全称是 Do What the Fuck You Want to Public License 。直译是「你他妈干啥都行协议」。不过， 使用这个协议的内容源还不多。

这个世界上有非常多允许你操作的协议，以上三例只是沧海一粟。请自行研究。

7. 「有价值的原创内容」来自哪里

来自在法律允许范围内的二次创作。

复制别人的书籍内容贴到你网站上，是非法的。但是，看完别人的书，归纳出重点，再分享，是合法且有价值的——这就是樊登读书会、得到每天听本书依赖于此。

抄袭别人写的歌是非法的。但是，国际惯例（以及美国法律明确规定），不超过 8 个小节的「抄袭」叫做「采样」，不构成抄袭。

徐真真的《当妮走了》脑海中反复闪现的「每次当妮走了，我发誓不会堕落」这一段可以说就是这首歌的亮点，而就是这几句采样了 GACKT 的作品《Last Song》（有一种未经考证的说法是，两首歌采用了同一个授权过的采样源）。
        
大家可以去听一下这两首歌，也许你会觉得「擦，太像了吧」。但是，它是合法的二次创作，徐真真的歌在各大音乐商店都能正常上架。

徐真真的歌有价值吗？有啊，它可比《Last Song》火多了。

但是，要实现「自动化的有价值的二次创作」，还蛮难的。没有一定之法，需要大家自动开动脑筋了。

拆解完成，让我们串起来。

1）找到一个内容源：
首先你需要找到一个内容源，它自身的内容池不仅量大，而且不断持续更新的。

2）内容源协议：
这个内容源，在协议上允许你进行二次创作。

3）构思有价值的二次创作：
你需要构思一个有价值的二次创作方式。有价值是核心。衡量标准：经过你的二次创作后，是否提供了附加价值？这个附加价值是否「利他」？是否有人愿意转发你的二次创作内容？

4）创作方式：
这个二次创作方式，可以通过编写代码，自动完成。

8. 二次创作从哪里开始

有没有什么快速的方法，能打通以上环节？ 没有。需要积累。

我能知道很多能行得通又有价值的内容源，是因为我根本就是这些内容源的用户，我知道它们的一切。
我能知道很多能够自动化二次创作的方法，是因为我每天混 GitHub ，知道最新的技术有哪些，能干什么，不能干什么。
我能知道什么样的自动化二次创作方式好使，什么样的二次创作方式不好使，是因为我见得多，对于别人用同样手段的网站分析得多。
我能知道什么样的自动化二次创作内容用户有需求，什么样的二次创作内容用户不需要，因为我的底色是产品经理，我对用户的需求和痛点很敏感。

但是，我还是想表达一下诚意，抛砖引玉一个你能马上实操的内容源和二次创作方式——如果你不知道怎么开始，那就从 Unsplash 开始。

你马上就可以去做。但是你得做得快、做得好、做得有壁垒，否则后人分分钟超过你，你的二次创作就不再是原创了。

Unsplash 官方提供了 API ，你可以抓取它的所有内容。它的图片内容有数百万之多。
这就意味着，你的网站，有数百万内容之多。

内容源允许二次创作吗？
允许。

Unsplash 的协议允许你对它的内容干几乎任何事情。

1）怎么做有简单的价值的二次创作

对于新手来说，最简单的就是翻译。但是我非常不推荐。
翻译的门槛太低了。一旦有第二个人做，对于搜索引擎来说，就不再是「原创」了。

2）怎么做复杂的、有价值的二次创作

到 GitHub 上找开源的、效果好的、图片处理类工具的代码。
比如，以下方法的单例或组合：

a. 风格转化 
最简单的方式是滤镜。请自行 GitHub 寻找图片风格处理的代码。

b. 自动去背景
俗称「抠图」。  （ 请自行 GitHub 搜索  image background removal 。我验证过效果好的神经网络至少有 U^2-net 、 BASNet  、DeepLabV3 三种 ）。

c. 风格迁移 
请自行 GitHub 搜索 image style transfer  。

d. 自动为图片增加维度 
让照片动起来、吗咿呀嘿 等等等等。

e. 自动为图片自动打标签或者描述文字 
请自行 GitHub 搜索 deep learning image caption 。
……

方法太多了。如果你经常上 GitHub ，你能对超出十种图片处理手段倒背如流。

抠图，效果如图所示。来自一个 U^2-net 的抠图类库。

[图片]
风格迁移，效果如图所示。来自 Fast Style Transfer in TensorFlow 。

为图片自动生成描述文字，效果如图所示。

[图片]

如果我做，我可能会选用 2 和 5 的组合。如果做的是中文网站，我还会把 5 生成的图片描述翻译为中文（但我会倾向于先做英文站，赚美元）。

之所以想做这个产品，是源于我自身痛点和需求：我常常做 PPT 、做图时，需要找一些不带背景的图插入进去。以前，我总是得先找到图片、再通过 https://www.remove.bg/ 网站手动完成「抠图」操作。

[图片]
如果有人能够提供一个「能搜索的、无版权的透明图片库」，内容多到百万级的规模，我一定会每天使用。我甚至愿意以每月 10 美元的价格付费订阅使用。

2 能解决我的这痛点， 5 能让你网站和图片拥有大量原创的文字描述，便于搜索引擎索引到它们、也便于从网站里直接搜索。

如果有人打算真用 2 和 5 结合的方式来做这个产品，请私聊我。我喜欢这个产品，我也相信这个产品能成功，我愿意提供咨询和帮助。
试想这个产品，「超大型 PNG 图库，每张图都没有背景，还能让你使用文字描述的方式搜索你需要的无背景、无版权图片，供你制作 PPT 和宣传图时随意使用」。

它的内容库量级几乎是无限的，拥有近乎无限个原创网页和图片，因此它会从搜索引擎获得很多流量。
它是有用的工具产品，因此它会获得自然流量，还会被人推荐给朋友。甚至会被用户列为「设计师必备」。
它如此有用，当你第一次不经意间通过 Google 搜索「可爱的白色小猫 四脚朝天 透明 PNG 」找到它以后，你会把网站加入收藏夹，以后直接打开它。
它能改变世界，哪怕只是一点点。

我为什么敢公开我对 Unsplash 内容二次创作创业的思考？因为这是一个「就算公开了，别人也很难做到」类型的秘密。 

看完本文，愿意动手去做、且有能力动手去做、能坚持做出来的人，不会超过数十人的规模。更何况，上文提到了，哪怕是仅针对 Unsplash 这一个源站，通过各种组合创新，还会有无穷无尽的变化玩法。

Unsplash 不过是食材之一，就像猪肉一样。全世界有成百上千种以猪肉为食材的菜谱。我刚才只不过公开了其中的「鱼香肉丝」、「水煮肉片」、「小炒肉」、「回锅肉」、「盐煎肉」几道入门家常菜的菜谱。

我希望能和这数十人交朋友，一起成长。
如果你不在这数十人范围内，也没关系，咱们同样能交朋友。如果我的思路为你的其他项目有启发，希望你可以不吝告知，我会非常荣幸和开心。

9. 总结

方法层面
要获取免费的、无限的流量，你需要一个「自动持续更新合法的有价值的原创内容」的网站。

1）「自动」「持续更新」来自内容源的 API ，或爬虫。
2）「合法」来自内容源的协议
3）「原创」「价值」 来自于有价值的二次创作。最好是 GitHub 上找高级代码，最差是翻译。
4）「价值」的体现是：有人愿意主动分享、收藏你的网站。功利的层面上讲，有人为了创造免费的外链。

价值观层面
1）与其关注「今年有什么变化」，不如关注「未来十年有什么不变」。
2）价值和利他，是万能之法。不仅来自道德要求，更是来自长远的经济利益考虑。
3）凡是值得做的事，都值得做很久。凡是不能做很久的事，都不值得做。

八、Idea to Business的完整流程

下面是我自己的流程。
最关键的是洞察需求。  只要你找到的是真需求，后面的过程会是简单的、自然而然发生的。
其次是PMF，这是决定是否能够成为一门Business最重要的里程碑。

总览
Idea → 洞察需求 →  发布MVP →  PMF(Product-Market Fit）  →  GTM Fit (Go-to-Market Fit)    →  Business

8.0 需求洞察阶段

动作
- 洞察需求
- 借助AI工具快速制作产品原型。它可以只包含界面和交互，不需要包含实际功能。
关键
- 从真需求出发。不要盲目去抄榜单。真需求满足如下填空题： (谁？)   在 （？）  场景下愿意花  （？）      钱解决  （？）   问题。  但凡不能同时填这4个空的，都不是真需求。
- 从自己的优势出发。如果你是Web3圈子的人、通过Web3赚到过钱，那你去做Web3的工具，就是你的优势，你更有把握做成；反之，如果你不是Web3圈子的人、也从来没有通过Web3赚到过钱，你也想做Web3工具，那成功概率会低很多。常见的误区是，你能够完美填好上面的填空题，但目标领域并不是你的优势领域，你连怎么接触目标用户都不知道。
成功标准
- 形成一个虽然还没做、但是你知道只要做了就大概率能赚到钱的产品构思、以及产品原型

8.1 MVP阶段

动作
- 只做核心功能，不做多语言、不做付费、不做登录。
关键
- 借助AI工具，快速发布。 ( ship fast)
- 快速验证，快速失败   ( fail fast)
冷启动
- 目标人群推广：访谈真正的目标用户，观察他们的反馈。目前用户最好是直接来自线下，其次是建立Disrcord或微信群等社区。
- 通用推广：只做Product Hunt等少量的动作，详见基础篇
- 钞能力：每天投入较少的成本进行投放，花钱买时间。 按照最低出价，每天只花$10~$100即可。因为这个阶段不需要量大，只需要精准，目的是获得认知。
根据反馈进行迭代
- 线下最重要的反馈路径：对真正的目标用户线下访谈、电话访谈，从而获得认知
- 线上最重要的反馈路径：每天观察Clarify的用户录像，找到改进点。
成功标准
- 产品能够自传播
- 产品持续一段时间（如：1个月）能够保持每天2000以上的自然访客
- 如果一直不成功，那就放着，不用迭代。（快速失败，fail fast）

8.2 正式产品

动作
- 找一个成熟的Starter，把MVP的功能进行重构。 找Starter是为了速度快。详见进阶篇第三课。
- Checklist
  - Landing Page
  - 用户登陆
  - 用户订阅
  - 多语言
  - 博客
  - 法律页面
  - News Letter (可选)
  - 客服（至少让用户通过邮件可以找到你，如果做live chat就更好）
初步尝试扩量
- 找到社交媒体流量，尤其是KOL。先找一些免费的，或者低价的。
根据反馈进行迭代
- 通过和MVP阶段类似的方式，但是，需要额外关注： 付费率情况。围绕商业转化率做迭代。
- 付费比例是多少？从访问到付费中间的漏斗是怎样的，分别漏了多少？为什么？
成功标准
- Product-Market Fit（产品-市场契合度）：你的产品真正解决了目标用户的痛点，且有足够多的用户愿意持续使用/付费。  这是创业早期最重要的里程碑：在此之前专注于验证需求；在此之后才能规模化投入市场、渠道和团队。
- 持续盈利。一般来说，我只关注这一个指标。但是也有人关注其他指标，见下面的判断指标列表。
- 有盈利，就会很从容。你可以选择把盈利用来扩大投放扩量，也可以选择重并投入迭代产品，还可以用盈利去做新产品。（我个人来说，我倾向于选择的是不断用盈利去做新产品，因为我热爱做产品的过程）
其他判断指标（常见，并非唯一，可选）
- 留存率/复购率：用户使用/购买后愿意继续回来。
- 净推荐值（NPS）：愿意向他人推荐的用户占比显著升高。
- 付费转化率 & CAC/LTV：获客成本（CAC）低于客户终身价值（LTV），且差距在扩大。
- 用户主动行为：自发分享、催促功能迭代、愿意参与测试等。
- 市场拉力 ＞ 推力：广告投放停止后，自然流量仍呈增长或保持稳定。

8.3 放大

动作
- 不断用盈利来驱动迭代，包括产品迭代，也包括流量获取策略迭代等等。
- 持续降低服务成本。如果量级扩大到一定规模，可以考虑通过私有化部署的方式，将API成本降低。
- 持续Launch，巩固和扩大声量。如：可再次到Produnct Hunt发布。Product Hunt是允许你添加功能后，反复发布的（参考这个产品，已经Launch过很多次）
根据反馈进行迭代
- 方式和前面的过程类似，但是，需要额外关注：在现有产品中做新功能的机会、做新产品的机会。
  - 例如，做文生图的时候，可能会有用户询问能不能做换脸、AI生成LOGO等等，积累到足够的信心后，可以单独开产品，也可以单独做功能。
  - 例如，Toolify.ai 这个产品，今天和两年前已经非常不同了。它在不断长出新功能，有些新功能还单独变成了新产品。
- 测试不同的流量渠道、流量手段。
成功标准
- Go-to-Market Fit（GTM Fit），也有人叫 Scale-Market Fit。把已经验证有效的产品，放到一套同样可验证、可复制、可扩大的获客与盈利机制里，让增长从“偶然”变成“可预测”。
- 形成正向循环。

8.4 稳定

动作
- 保持最低成本运营，利润最大化。抽出兵力考虑新产品。
成功标准
- 以同样的人员投入规模，持续发布新产品



九、产品设计流程

简单产品，往往只需要一两个核心界面，不太依赖规范的产品设计流程，直接用Cursor做就行，想到哪里做到哪里。

但是，对于复杂产品，有多个界面，界面之间有不同的逻辑关系，不能想到哪里做到哪里，否则会频繁返工。

我们需要引入产品设计流程。

我们身边有一些朋友，在缺乏整体产品设计的前提下直接用Cursor开干，我最多见过全部推翻重做5次的。 因此我认为有必要跟大家简单讲讲，产品设计流程。


9.1 传统互联网公司的产品设计流程

无论用什么工具，都绕不开这两个流程！

我们可不断探索，其中哪些环节，可以加速。  

A. 从草图，到高保真，到设计图

草图的作用是方便讨论、方便自我思考、团队协作。
最好是在白板上面画。以方便为主。

[图片]

B. 从一个界面，到多个界面，包含逻辑关系

提前规划好各个页面的关系。

好比是设计一栋楼，需要先有这栋楼的蓝图。

[图片]

全世界有很多人，都正在用不同工具，去尝试加速其中的环节，我们都可以参考。



9.2 我的方法

特别提示：
- 每一步都需要你亲自参与到反馈、打磨的过程当中。你可以把AI当成伙伴，反复和他协作。
- 不求“AI一次做好”。


A. 让ChatGPT出需求

我直接把竞品的链接发给了它，作为讨论的起点。

[图片]

等他分析完成后，我先让他出一个版本的需求

[图片]


B. 让Claude出线框原型

不满意就反复聊天，直到满意

也可以自己在白板上面画。
[图片]


C. 让Stitch做美化

[图片]

[图片]



D. 可交互的高保真原型

我们在课程基础篇里提到的lovable/V0/same.new/Bolt.new，都可以做到

可以每次做一页，也可以一次让它做多页（需要的时间较长）。

[图片]



E. 发布高保真原型


在lovable/V0/same.new/Bolt.new里反复聊天，直到所有界面都做完。

发布为一个公开的URL，方便你分享给目标用户，进行讨论，得到反馈后可以继续迭代。


F. Cursor打磨

从lovable/V0/same.new/Bolt.new下载所有代码到Cursor里，开发实际功能。

9.3 其他方法分享

该方法并非我原创，我使用得也不多。

它是北京SCAI实验室的兔老师，推荐给我一个挺好的方法，初步测试感觉不错。也分享给大家。

原理仍然是9.1里讲到的“产品设计流程”，但是它比较巧妙。

1. 直接用Cursor，不需要使用其它工具。
2. 强调“用HTML做原型”，避免过早引入框架，节省大模型的脑力，让它专心做设计。
3. 一次出多个页面，并且用最简单的方式(iframe)衔接了页面关系

你可以带着上面学到的知识，去分析下面的提示词。

序号
演示
提示词
1
炫酷音乐APP
[图片]
参考我上传的UI的风格。
我想开发一个酷炫的音乐APP，现在需要输出高保真的原型图，请通过以下方式帮我完成所有界面的原型设计，并确保这些原型界面可以直接用于开发：
1、用户体验分析：先分析这个 App 的主要功能和用户需求，确定核心交互逻辑。
2、产品界面规划：作为产品经理，定义关键界面，确保信息架构合理。
3、高保真 UI 设计：作为 UI 设计师，设计贴近真实 iOS/Android 设计规范的界面，使用现代化的 UI 元素，使其具有良好的视觉体验。
4、HTML 原型实现：使用 HTML + Tailwind CSS（或 Bootstrap）生成所有原型界面，并使用 FontAwesome（或其他开源 UI 组件）让界面更加精美、接近真实的 App 设计。
拆分代码文件，保持结构清晰：
5、每个界面应作为独立的 HTML 文件存放，例如 home.html、profile.html、settings.html 等。
- index.html 作为主入口，不直接写入所有界面的 HTML 代码，而是使用 iframe 的方式嵌入这些 HTML 片段，并将所有页面直接平铺展示在 index 页面中，而不是跳转链接。
- 真实感增强：
  - 界面尺寸应模拟 iPhone 16 Pro，并让界面圆角化，使其更像真实的手机界面。
  - 使用真实的 UI 图片，而非占位符图片（可从 Unsplash、Pexels、Apple 官方 UI 资源中选择）。
  - 添加顶部状态栏（模拟 iOS 状态栏），并包含 App 导航栏（类似 iOS 底部 Tab Bar）。
请按照以上要求生成完整的 HTML 代码，并确保其可用于实际开发。
2
生日管家类APP
[图片]
参考我上传的UI的风格。
我想开发一个生日管家类的APP，现在需要输出高保真的原型图，请通过以下方式帮我完成所有界面的原型设计，并确保这些原型界面可以直接用于开发：
1、用户体验分析：先分析这个 App 的主要功能和用户需求，确定核心交互逻辑。
2、产品界面规划：作为产品经理，定义关键界面，确保信息架构合理。
3、高保真 UI 设计：作为 UI 设计师，设计贴近真实 iOS/Android 设计规范的界面，使用现代化的 UI 元素，使其具有良好的视觉体验。
4、HTML 原型实现：使用 HTML + Tailwind CSS（或 Bootstrap）生成所有原型界面，并使用 FontAwesome（或其他开源 UI 组件）让界面更加精美、接近真实的 App 设计。
拆分代码文件，保持结构清晰：
5、每个界面应作为独立的 HTML 文件存放，例如 home.html、profile.html、settings.html 等。
- index.html 作为主入口，不直接写入所有界面的 HTML 代码，而是使用 iframe 的方式嵌入这些 HTML 片段，并将所有页面直接平铺展示在 index 页面中，而不是跳转链接。
- 真实感增强：
  - 界面尺寸应模拟 iPhone 15 Pro，并让界面圆角化，使其更像真实的手机界面。
  - 使用真实的 UI 图片，而非占位符图片（可从 Unsplash、Pexels、Apple 官方 UI 资源中选择）。
  - 添加顶部状态栏（模拟 iOS 状态栏），并包含 App 导航栏（类似 iOS 底部 Tab Bar）。
请按照以上要求生成完整的 HTML 代码，并确保其可用于实际开发。
3
城市交通可视大屏
[图片]
参考我上传的UI的风格。
我想开发一个城市交通可视大屏的web站点，现在需要输出高保真的原型图，请通过以下方式帮我完成所有界面的原型设计，并确保这些原型界面可以直接用于开发：
1、用户体验分析：先分析这个 web 的主要功能和用户需求，确定核心交互逻辑。
2、产品界面规划：作为产品经理，定义关键界面，确保信息架构合理。
3、高保真 UI 设计：作为 UI 设计师，设计贴近真实web 设计规范的界面，使用现代化的 UI 元素，使其具有良好的视觉体验。
4、HTML 原型实现：使用 HTML + Tailwind CSS（或 Bootstrap）生成所有原型界面，并使用 FontAwesome（或其他开源 UI 组件）让界面更加精美、接近真实的 web设计。
拆分代码文件，保持结构清晰：
5、每个界面应作为独立的 HTML 文件存放，例如 home.html、profile.html、settings.html 等。
- index.html 作为主入口，不直接写入所有界面的 HTML 代码，而是使用 iframe 的方式嵌入这些 HTML 片段，并将所有页面直接竖铺展示在 index 页面中，而不是跳转链接。
- 真实感增强：
  - 使用真实的 UI 图片，而非占位符图片（可从 Unsplash、Pexels、Apple 官方 UI 资源中选择）。
请按照以上要求生成完整的 HTML 代码，并确保其可用于实际开发。

[图片]

问答（持续更新）

刚学 NextJS，建议怎么上手？

请花时间完成 NextJS 官方的教程。 

最好的教程，是 NextJS 官方的教程。如果你觉得看英文太累，一定要找个国内的视频来看的话，我暂且推荐 https://www.bilibili.com/video/BV157pRe8EyD  本质上它是把 NextJS 官方文档，带着你过一遍。 

学完后请自测，是否完全清楚以下概念：
- 组件（Components）
  - 服务器组件（Server Components） - 默认在服务器上渲染的组件，减少客户端 JavaScript 体积，并对 SEO 非常友好
  - 客户端组件（Client Components） - 通过"use client"指令定义的在浏览器中渲染的交互组件
- Page
- API 路由 - 通过 route.ts 文件创建后端 API 端点
- 布局系统（Layouts） - 嵌套布局组件允许多个页面共享 UI 结构
- 中间件（Middleware） - 在请求完成前运行的代码，用于认证、重定向等
- 环境变量 - 安全地管理不同环境的配置
- 边缘运行时（Edge Runtime） - 在 CDN 边缘节点上运行代码，提供更快的响应
- App Rounter
- 数据获取方法： 
  - 服务器组件中直接使用 fetch
  - 缓存和重新验证策略
  - 静态生成（SSG）和服务器端渲染（SSR）
- 渲染策略： 
  - 静态生成（Static Generation）
  - 服务器端渲染（Server-Side Rendering）
  - 客户端渲染（Client-Side Rendering）
  - 增量静态再生成（Incremental Static Regeneration）
- Streaming 与 Suspense - 支持 UI 的部分加载和流式传输
- 动态导入（Dynamic Imports） - 按需加载组件和模块以优化性能

为什么我的 Cursor 比别人的更笨？

因为你没有花时间学习「内功」😄
你在玩弄 Cursor 上比别人多花的时间，就是你在「内功篇」比别人少花的时间。
请一定要花足量的时间在“补齐内功”上。无论是 NextJS 还是 Supabase，市面上都有无数多的优秀教程了，视频的、图文的都有。

我是程序员，怎么入局出海产品？

2025.3.17

恭喜你！如果你是程序员，你学习起来比别人更快。

你的路径应该是从分析成功的产品开始。

当你遇到一个技术平平、用户量大、团队小的产品时，你应该感到兴奋。你需要应用各种工具，去回答以下问题
1. 它的用户是咱们来的？
2. 它的用户为什么会付费？
3. 如果我来做，我会怎么做，从而有希望超过它？
4. 这个产品对我有什么启发，我有没有机会做出差异化的功能、差异化的痛点、差异化的获客方式？

并养成习惯。

然后，你还需要养成收集抱怨的习惯，去关注生活中的痛点。

我在调试 Google 登录的时候，梯子不好用，但正常浏览网页时梯子是好用的。

同样的问题还包括：
- 无法在Cursor里使用Github Commit功能提交代码
- 无法做Terminal/Cursor Terminal使用claude code

因为你的梯子使用的是“代理/系统”功能，本质上是一个代理，不是一个真正的系统级微屁恩。

请换成支持 TUN 模式（或“VPN 模式”、或“增强模式”）的梯子客户端软件，并在安装的时候赋予它们系统管理员权限。

例如，我的 Mac 电脑，使用的是 ClashX Pro ，这个组合非常省心 ； 而在我的 Windows 电脑上，我直接使用了商业的 VPN 软件，不是代理软件。
[图片]
[图片]

有没有可以联网搜索的大模型 API？

OpenRouter 上的模型都可以，加上一个参数就行
[图片]

为什么我部署海外的网站国内明明可以访问，大家做国内网站，还非要去备案、做 ICP、放到国内呢？

因为
1. 有被墙的风险，无法保障服务的稳定性。海外的服务器无法被境内监管部门监管，因此，一旦你的网站上出现了一些可能需要被监管的内容，就会立即被墙。
2. 理论上讲，从境外服务器对境内用户提供服务，是违法的。

综上，如果您做的是国内产品，请一定要遵守相关法律法规，取得相应的备案。


我每次和cursor对话，终端这里好像都报错，但测试窗口又成功，只是有些小细节需要调整，那我想问下，这个终端报错要处理吗？
[图片]
遇到这种问题，可以养成 contrl+c 停止服务，手动重新npm run dev运行服务 的习惯～～ 
另外，不建议让Cursor自动帮你启动npm run dev，那会造成很多困扰。  这个服务自己启动、自己管理比较好。

如何找到目标用户验证需求
- 解答：  
  - 社群调研：Reddit/X的细分板块、竞品评论区挖掘痛点。  
  - 案例参考：AI工具站可通过Google Ads或SEO关键词（KD<40）引流。  
  - MVP策略：先上线核心功能（如登录/支付），再根据反馈迭代。


如何把V0和starter kit合并

这里要感谢moore助教的内容以及Ash焚芯的图片制作

[图片]



如何控制学习进度：

课程内容与学习路径问题
- 问题：学员对学习路径不清晰，如“学完Next.js后是继续看数据库还是先做项目？”  
- 解答：  
  - 建议路径：Next.js → React → TypeScript → JavaScript，优先掌握Next.js框架，再逐步深入底层技术。  
  - 实践优先：通过Starter Kit快速搭建项目，边做边学内功篇内容（如数据库、ShadCN）。  
  - 课程更新：手册中部分SQL示例因Supabase更新需调整（如alter table auth.users报错需删除第二行）

课程的核心思想是分阶段学习和实施，而不是试图一次性完成所有事情或急于从一开始就推出一个完整的产品。
- 遵循手册/结构： 第一张图片强调“按照手册，把手册里的东西都弄懂就好”。这意味着要理解你正在构建的模块化性质（例如，在 Next.js 中，知道代码的哪个部分处理图像，哪个部分处理页面，每个部分有什么功能以及放在哪里）。这暗示了一种结构化的基础学习方法。
- 逐步实施： 一旦你达到对结构和组件一定程度的理解，然后你就可以“开始实战，开始做网站，开始搞流量”。这表明从理论理解到实际应用的阶段性转变。
- 增量解决问题： “在这个过程中遇到问题一点一点的解决。” 这强化了在构建过程中出现问题时逐步解决它们，而不是试图预见和解决所有问题。
- 学习后增量实现目标： 刘小排指出：“你搞不出来是因为你‘边学边干’，慢是对的。我的意思是，当你全部学会之后，再去达到一周一个的目标。”这是关键一点：首先专注于学习基础知识，然后再为产品开发设定积极的短期目标。
- 第一个产品需要时间： 刘小排提到：“第一个产品，一两个月搞出来，跑通流程。” 这设定了一个现实的期望，即最初的项目需要时间才能启动，因为你可能仍在学习和完善你的流程。
- 迭代改进与加速： 北京 SCAI 学生的事例清楚地说明了这一点：
  - 第一个产品：3-4 个月
  - 第二个产品：大约 1 个月
  - 第三个产品：不到一周（并且现在带来了可观的收入） 这表明随着技能和经验的积累，开发时间会迅速缩短。
学习慢就是快：
“学习慢就是快”的理念在信息中得到了隐含的支持，特别是刘小排的观点。
- 先掌握基础知识： 通过花时间“全部学会”（正如刘小排所建议的）并彻底理解“手册”和模块化结构（正如无极所建议的），你就能建立坚实的基础。这种最初“慢”的深入学习阶段可以避免未来的障碍和返工。
- 避免“边学边干”在初始产品中的陷阱： 刘小排承认“边学边干”可能会阻碍产品快速完成。虽然“边学边干”是一种有价值的长期策略，但对于初始产品的完成，预先进行更专注的学习阶段实际上可以使后续的构建过程更快更顺畅。
- 随着时间建立效率： 那个第一个产品用了 3-4 个月，但第三个产品不到一周的学生案例，正是“学习慢就是快”的体现。最初“慢”的学习以及在前几个项目上投入的时间，积累了必要的技能、流程和知识储备。这使得后续项目的执行速度大大加快。你变得更有效率，犯更少的错误，并且知道如何有效地利用你的工具和知识。
- 迭代成功： 信息暗示，最初“慢”的节奏并非低效，而是为了培养未来更快生产和更大成功的能力。第三个产品带来的收入，正是通过早期较慢阶段所建立的学习和发展轨迹的直接结果。
本质上，建议是彻底投入基础学习和最初可能较慢的项目。 这种看似“慢”的方法能积累专业知识和提高效率，最终在长期内带来更快、更成功的成果。

【新增】Stripe风控避坑
  1. 为什么必须重视支付风控？
  出海SaaS或AI工具项目一旦上线，支付环节是高风险区域。尤其你面对的是全球用户，骗子和“黑卡党”活跃，Stripe、PayPal等支付平台会主动风控，甚至封号、冻结资金，直接影响收入。

---
  2. 典型翻车案例（真实聊天总结）
  - 用户用盗刷卡、黑卡尝试下单，支付失败；
  - 如果失败订单多，Stripe会怀疑你平台“高风险”，甚至主动封禁；
  - 一旦封号：
    - 账户余额和未结算款项冻结，5天后强制退回买家；
    - 你自己无法主动提现；
    - 申诉困难，基本无力回天；
  - 大量同行、甚至大公司也中招，尤其不懂“风控配置”的。

---
  3. 新手必做配置：Stripe Radar
  Radar是Stripe的内置风控系统，必须打开并合理配置：
  ✅ 启用“高风险卡拦截”
   ✅ 启用“可疑IP、设备拦截”
   ✅ 配置“拒绝高风险国家”【如你只面向欧美客户】
   ✅ 定期查看风控报告，及时拉黑异常用户

---
  4. 实操建议
暂时无法在飞书文档外展示此内容

---
  5. 补充提醒
  ❗ 遇到封号，账户内钱很难主动提现，基本只能等Stripe退回客户；
   ❗ 黑卡下单不仅让你拿不到钱，还可能导致账户整体风控评级下降；
   ❗ 如果前期没有做好风控配置，容易被批量“刷单-封号-退款”套路搞崩；
   ❗ 出海做SaaS、AI产品，风控和合规和技术同等重要，切勿忽视。


【新增】关键词 KD 值的理解与选择
 1. 什么是 KD 值？
KD = Keyword Difficulty
 即：关键词难度系数
反映的是：
这个关键词想在 Google 搜索结果前几页排名的难度
KD 越高，竞争越激烈，SEO优化成本越高

---
2. 不同平台 KD 值为什么不同？
常见关键词工具：
暂时无法在飞书文档外展示此内容
原因：
每个平台数据源不同
统计口径不一致
有的重视外链情况，有的重视页面内容
实战建议：
选用自己常用、信任的数据平台，保持统一标准
需要严格控制 SEO 难度，建议参考 Ahrefs 数据
KD 只是参考，流量、转化、竞争对手布局同样重要

---
3. KD 之外的关键评估指标：
搜索量
趋势变化
竞争对手质量
自身资源情况
SERP 结构（前 10 页网站的强弱）
总结：
KD 只是辅助，选词最终看整体 SEO 投入产出比。

---
4. 常见误区与补充说明
KD 高 ≠ 完全没机会，特殊技巧下仍有可能突破
KD 低 ≠ 一定轻松，具体看 SERP 竞争情况
多平台数据不一致很正常，不用纠结数字差异


【新增】本地和线上数据加载速度不一样？其实是缓存在搞鬼
✅ 典型原因总结：
1. 开发模式（Development Mode）和生产模式（Production Mode）差异
本地默认是开发模式（next dev），Next.js 会有额外的缓存、HMR（热更新）、不稳定的缓存清理。
线上是生产模式（next build + next start 或 Vercel 自动构建），缓存和静态资源严格受控。
开发模式下，很多缓存逻辑被忽略或不稳定，导致你误以为有缓存问题，其实生产环境根本没有。

---
2. 浏览器缓存差异
本地你反复调试，浏览器容易缓存 API 响应或页面内容。
线上部署，CDN（如 Vercel、Cloudflare）接管资源分发，缓存策略统一规范，很多实时内容都是 fresh 的。

---
3. API 代理/网络层差异
本地环境你可能用代理、mock、V2ray 等，导致请求实际走的路径不同，缓存行为也不同。
线上真实走 Supabase、数据库、Auth Server，请求链路不同，缓存受控。

---
4. 数据库和 Supabase 缓存
线上你用 Supabase，有内置的行级缓存或边缘缓存（尤其 Edge Functions）。
本地自己开 Supabase Studio 或者 mock DB，没有这些缓存层。

---
5. Next.js revalidate / ISR 配置
你如果用了 getStaticProps、getServerSideProps、revalidate 参数，线上行为非常严格。
本地为了开发体验，Next.js 可能不会严格遵守这些策略，数据感觉“缓存没清理”。

---
✅ 典型案例：
暂时无法在飞书文档外展示此内容

---
✅ 你可以检查：
确认本地是不是 next dev 模式
看线上是不是有 revalidate 配置
检查浏览器 DevTools，Network 里的 Cache-Control
确认 Supabase 是否启用了行级缓存或边缘函数
查看 API 响应 Header，线上和本地 Cache-Control 有区别吗



【新增】解析视频的api搭建思路示例
1. 什么是视频解析？ 🎥
视频解析就是从视频中提取有价值的信息，比如转录、语音识别和字幕生成。通过特定的算法和工具，我们能够解读视频中的语音、文字，甚至整个内容的背景。
2. 常用的工具和技术 🛠️
•
Gemini （gemini-flash和pro）🌟：直接解析视频，提取文字并分析视频内容。不仅能提取音频，还能实时分析视频的各类信息。
•
ChatGPT 🤖：擅长将视频中的语音转成文字。无论是对话内容还是复杂的视频信息，ChatGPT都能帮助你进行转录，并支持多种语言的识别。
•
Whisper 🎤：一个高效的音频转文字工具，可以将视频中的语音转成字幕。特别适合批量处理视频，精准度高，自动生成字幕，节省时间。
3. 视频解析的步骤 🔄
•
准备视频 🎬：首先，确保视频格式是常见的 MP4 格式。对于长视频，可以分段处理，提高解析效率。
•
提取语音 🎧：使用 Whisper 或其他类似工具，从视频中提取语音并进行转录。如果使用 Gemini，它能直接从视频中分析并提取文字。
•
生成字幕 📝：使用 Whisper 自动生成字幕，按时间轴标注每个视频片段。根据视频的长度，生成字幕的时间会有所不同。
•
调整和优化 ⚙️：生成的字幕可能需要一些手动调整，尤其是时间戳部分。调整完毕后，字幕可以实时显示在视频中，或者以字幕文件（如 SRT 格式）保存。
•
增强分析 🔍：提取的文本可以用 ChatGPT 进行语义分析，提炼重点内容。如果视频内容较复杂，可以使用 Gemini 深入理解视频的结构和信息。
4. 相关工具和资源 📚
•
Gemini 🔮：高效的视频内容分析工具，适合实时反馈和大规模解析。
•
Whisper 🗣️：优秀的语音转文本工具，支持多种语言，能准确提取视频中的语音。
•
ChatGPT 💬：对提取的文本进行进一步处理和语义分析，帮助解读复杂的内容。
5. 成本与效率 💰⏱️
视频解析的成本可能会根据视频的大小、解析精度以及模型的计算时间而有所不同。例如，解析一个3.5GB的视频可能需要10美元或更高。为节省成本，可以合理分配时间，优化解析过程，提高效率。


【新增】关于 Docker
Docker 是一个轻量级的容器化平台，可以将应用及其依赖打包成容器，方便在不同的环境中部署。开发过程中，很多任务都需要模拟或隔离运行环境，尤其在进行后端开发、AI 开发、以及大规模应用部署时。虚拟化和容器化是两种常见的技术，以下是它们的应用场景：
Docker：用于轻量级的容器化管理，适合快速部署和开发小型应用或微服务。例如，可以用 Docker 来运行数据库容器、API 服务、或搭建整个开发环境。
虚拟化：例如使用 VMware、Proxmox 或 Hyper-V 进行系统虚拟化。虚拟化适用于需要完整操作系统环境的开发任务，尤其是当你需要隔离不同的开发环境时，虚拟化的管理能力比 Docker 更强。
