# 云存储图片上传实施方案

## 一、方案对比

### 1. 腾讯云COS（推荐）
- **优势**：国内访问快、价格便宜、与腾讯云视频点播集成好
- **价格**：
  - 存储：¥0.099/GB/月
  - 流量：¥0.50/GB（国内）
  - API调用：¥0.01/万次
- **免费额度**：新用户50GB存储+10GB流量

### 2. 阿里云OSS
- **优势**：稳定性好、功能全面
- **价格**：
  - 存储：¥0.12/GB/月
  - 流量：¥0.50/GB（国内）
  - API调用：¥0.01/万次

### 3. 七牛云
- **优势**：专注CDN、免费额度多
- **价格**：
  - 存储：免费10GB
  - 流量：免费10GB/月
  - 超出后：¥0.165/GB存储，¥0.29/GB流量

## 二、腾讯云COS实施步骤

### 步骤1：注册并配置腾讯云COS

1. **注册腾讯云账号**
   - 访问 https://cloud.tencent.com/
   - 完成实名认证

2. **创建存储桶**
   ```
   名称：deepsea-courses
   地域：选择离服务器最近的地域（如：ap-guangzhou）
   访问权限：公有读私有写
   ```

3. **获取密钥**
   - 访问：https://console.cloud.tencent.com/cam/capi
   - 创建密钥并保存：
     - SecretId
     - SecretKey

4. **配置跨域访问**
   在存储桶设置中添加CORS规则：
   ```json
   {
     "AllowedOrigins": ["*"],
     "AllowedMethods": ["GET", "POST", "PUT", "DELETE", "HEAD"],
     "AllowedHeaders": ["*"],
     "ExposeHeaders": ["ETag"],
     "MaxAgeSeconds": 3600
   }
   ```

### 步骤2：安装SDK并配置

```bash
# 安装腾讯云COS SDK
npm install cos-nodejs-sdk-v5
```

### 步骤3：创建云存储上传工具

创建文件：`lib/cos-upload.ts`

```typescript
import COS from 'cos-nodejs-sdk-v5'
import { Readable } from 'stream'

// 初始化COS实例
const cos = new COS({
  SecretId: process.env.TENCENT_SECRET_ID!,
  SecretKey: process.env.TENCENT_SECRET_KEY!,
})

const BUCKET = process.env.COS_BUCKET || 'deepsea-courses-1234567890'
const REGION = process.env.COS_REGION || 'ap-guangzhou'

export interface UploadResult {
  url: string
  key: string
  etag: string
}

/**
 * 上传文件到COS
 */
export async function uploadToCOS(
  buffer: Buffer,
  key: string,
  contentType: string
): Promise<UploadResult> {
  return new Promise((resolve, reject) => {
    cos.putObject({
      Bucket: BUCKET,
      Region: REGION,
      Key: key,
      Body: buffer,
      ContentType: contentType,
      // 设置缓存策略
      CacheControl: 'public, max-age=31536000',
    }, (err, data) => {
      if (err) {
        reject(err)
      } else {
        // 构建访问URL
        const url = `https://${BUCKET}.cos.${REGION}.myqcloud.com/${key}`
        resolve({
          url,
          key,
          etag: data.ETag
        })
      }
    })
  })
}

/**
 * 删除COS文件
 */
export async function deleteFromCOS(key: string): Promise<void> {
  return new Promise((resolve, reject) => {
    cos.deleteObject({
      Bucket: BUCKET,
      Region: REGION,
      Key: key,
    }, (err) => {
      if (err) {
        reject(err)
      } else {
        resolve()
      }
    })
  })
}

/**
 * 生成带签名的临时访问URL（用于私有文件）
 */
export function getSignedUrl(key: string, expires = 3600): string {
  return cos.getObjectUrl({
    Bucket: BUCKET,
    Region: REGION,
    Key: key,
    Expires: expires,
    Sign: true,
  })
}

/**
 * 批量上传文件
 */
export async function batchUploadToCOS(
  files: Array<{
    buffer: Buffer
    key: string
    contentType: string
  }>
): Promise<UploadResult[]> {
  const uploadPromises = files.map(file => 
    uploadToCOS(file.buffer, file.key, file.contentType)
  )
  return Promise.all(uploadPromises)
}
```

### 步骤4：更新图片上传API

更新文件：`app/api/upload/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { validateFile, generateFileName, UploadError } from '@/lib/upload'
import { uploadToCOS } from '@/lib/cos-upload'
import sharp from 'sharp'

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    
    if (!session) {
      return NextResponse.json(
        { error: '请先登录' },
        { status: 401 }
      )
    }

    const formData = await request.formData()
    const file = formData.get('file') as File
    const type = formData.get('type') as string || 'general'

    if (!file) {
      return NextResponse.json(
        { error: '请选择要上传的文件' },
        { status: 400 }
      )
    }

    // 验证文件
    try {
      validateFile({
        size: file.size,
        mimetype: file.type
      })
    } catch (error) {
      if (error instanceof UploadError) {
        return NextResponse.json(
          { error: error.message },
          { status: 400 }
        )
      }
      throw error
    }

    // 将文件转换为Buffer
    const bytes = await file.arrayBuffer()
    const buffer = Buffer.from(bytes)

    // 根据类型生成文件路径
    const timestamp = Date.now()
    const random = Math.random().toString(36).substring(2, 8)
    const ext = file.name.split('.').pop()
    const filename = `${timestamp}-${random}.${ext}`
    
    let key: string
    let processedBuffer = buffer
    
    switch (type) {
      case 'avatar':
        key = `avatars/${session.user.id}/${filename}`
        // 处理头像：裁剪为正方形并压缩
        processedBuffer = await sharp(buffer)
          .resize(400, 400, {
            fit: 'cover',
            position: 'center'
          })
          .jpeg({ quality: 85 })
          .toBuffer()
        break
        
      case 'course':
        key = `courses/images/${filename}`
        // 处理课程图片：限制最大尺寸
        const metadata = await sharp(buffer).metadata()
        if (metadata.width! > 1920 || metadata.height! > 1080) {
          processedBuffer = await sharp(buffer)
            .resize(1920, 1080, {
              fit: 'inside',
              withoutEnlargement: true
            })
            .jpeg({ quality: 90 })
            .toBuffer()
        }
        break
        
      case 'post':
        key = `posts/${session.user.id}/${filename}`
        // 处理动态图片
        processedBuffer = await sharp(buffer)
          .resize(1200, null, {
            fit: 'inside',
            withoutEnlargement: true
          })
          .jpeg({ quality: 85 })
          .toBuffer()
        break
        
      default:
        key = `general/${filename}`
    }

    // 上传到腾讯云COS
    const result = await uploadToCOS(
      processedBuffer,
      key,
      file.type
    )

    // 如果需要，可以在数据库中记录上传信息
    // await prisma.upload.create({
    //   data: {
    //     userId: session.user.id,
    //     url: result.url,
    //     key: result.key,
    //     type: type,
    //     size: processedBuffer.length,
    //     mimeType: file.type,
    //   }
    // })

    return NextResponse.json({
      url: result.url,
      key: result.key,
      message: '上传成功'
    })

  } catch (error) {
    console.error('Upload error:', error)
    return NextResponse.json(
      { error: '上传失败，请稍后重试' },
      { status: 500 }
    )
  }
}

// 删除文件的API
export async function DELETE(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    
    if (!session) {
      return NextResponse.json(
        { error: '请先登录' },
        { status: 401 }
      )
    }

    const { key } = await request.json()
    
    if (!key) {
      return NextResponse.json(
        { error: '缺少文件key' },
        { status: 400 }
      )
    }

    // 从COS删除文件
    await deleteFromCOS(key)

    return NextResponse.json({
      message: '删除成功'
    })

  } catch (error) {
    console.error('Delete error:', error)
    return NextResponse.json(
      { error: '删除失败' },
      { status: 500 }
    )
  }
}
```

### 步骤5：创建图片上传组件

创建文件：`components/image-uploader.tsx`

```typescript
'use client'

import { useState, useCallback } from 'react'
import { Upload, X, Loader2, Image as ImageIcon } from 'lucide-react'
import Image from 'next/image'

interface ImageUploaderProps {
  value?: string
  onChange?: (url: string) => void
  type?: 'avatar' | 'course' | 'post' | 'general'
  accept?: string
  maxSize?: number // MB
  className?: string
}

export function ImageUploader({
  value,
  onChange,
  type = 'general',
  accept = 'image/*',
  maxSize = 5,
  className = ''
}: ImageUploaderProps) {
  const [uploading, setUploading] = useState(false)
  const [progress, setProgress] = useState(0)
  const [error, setError] = useState<string | null>(null)
  const [preview, setPreview] = useState<string | null>(value || null)

  const handleUpload = useCallback(async (file: File) => {
    // 验证文件大小
    if (file.size > maxSize * 1024 * 1024) {
      setError(`文件大小不能超过 ${maxSize}MB`)
      return
    }

    // 显示预览
    const reader = new FileReader()
    reader.onload = (e) => {
      setPreview(e.target?.result as string)
    }
    reader.readAsDataURL(file)

    // 开始上传
    setUploading(true)
    setError(null)
    
    const formData = new FormData()
    formData.append('file', file)
    formData.append('type', type)

    try {
      // 模拟上传进度
      const progressInterval = setInterval(() => {
        setProgress(prev => Math.min(prev + 10, 90))
      }, 200)

      const response = await fetch('/api/upload', {
        method: 'POST',
        body: formData
      })

      clearInterval(progressInterval)
      setProgress(100)

      if (!response.ok) {
        const data = await response.json()
        throw new Error(data.error || '上传失败')
      }

      const data = await response.json()
      
      // 通知父组件
      if (onChange) {
        onChange(data.url)
      }
      
      // 更新预览为最终URL
      setPreview(data.url)
      
    } catch (err) {
      setError(err instanceof Error ? err.message : '上传失败')
      setPreview(null)
    } finally {
      setUploading(false)
      setProgress(0)
    }
  }, [type, maxSize, onChange])

  const handleFileSelect = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (file) {
      handleUpload(file)
    }
  }, [handleUpload])

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault()
    const file = e.dataTransfer.files[0]
    if (file && file.type.startsWith('image/')) {
      handleUpload(file)
    }
  }, [handleUpload])

  const handleRemove = useCallback(() => {
    setPreview(null)
    setError(null)
    if (onChange) {
      onChange('')
    }
  }, [onChange])

  return (
    <div className={`relative ${className}`}>
      <div
        className="relative border-2 border-dashed border-gray-300 rounded-lg overflow-hidden transition-colors hover:border-gray-400"
        onDrop={handleDrop}
        onDragOver={(e) => e.preventDefault()}
      >
        {preview ? (
          // 显示预览
          <div className="relative aspect-video">
            <Image
              src={preview}
              alt="Preview"
              fill
              className="object-cover"
            />
            {!uploading && (
              <button
                onClick={handleRemove}
                className="absolute top-2 right-2 p-1 bg-red-500 text-white rounded-full hover:bg-red-600 transition-colors"
              >
                <X className="w-4 h-4" />
              </button>
            )}
            {uploading && (
              <div className="absolute inset-0 bg-black/50 flex items-center justify-center">
                <div className="text-center text-white">
                  <Loader2 className="w-8 h-8 animate-spin mx-auto mb-2" />
                  <div className="text-sm">上传中 {progress}%</div>
                </div>
              </div>
            )}
          </div>
        ) : (
          // 显示上传区域
          <label className="block cursor-pointer p-8">
            <input
              type="file"
              accept={accept}
              onChange={handleFileSelect}
              className="hidden"
              disabled={uploading}
            />
            <div className="text-center">
              <ImageIcon className="w-12 h-12 text-gray-400 mx-auto mb-2" />
              <p className="text-sm text-gray-600">
                点击或拖拽图片到此处上传
              </p>
              <p className="text-xs text-gray-500 mt-1">
                支持 JPG、PNG、WebP 格式，最大 {maxSize}MB
              </p>
            </div>
          </label>
        )}
      </div>
      
      {error && (
        <p className="mt-2 text-sm text-red-600">{error}</p>
      )}
    </div>
  )
}
```

### 步骤6：在课程编辑器中使用

更新文件：`components/course-editor.tsx`（添加图片上传按钮）

```typescript
import { ImageUploader } from './image-uploader'

// 在工具栏中添加图片上传器
<ImageUploader
  type="course"
  onChange={(url) => {
    // 在编辑器中插入图片
    const imageMarkdown = `\n![课程图片](${url})\n`
    const newContent = content + imageMarkdown
    onChange(newContent)
  }}
/>
```

### 步骤7：环境变量配置

更新 `.env.local`：

```env
# 腾讯云配置
TENCENT_SECRET_ID=your-secret-id
TENCENT_SECRET_KEY=your-secret-key
COS_BUCKET=deepsea-courses-1234567890
COS_REGION=ap-guangzhou

# CDN域名（可选，用于加速）
CDN_DOMAIN=https://cdn.deepsea.com
```

### 步骤8：配置CDN加速（可选但推荐）

1. **在腾讯云开通CDN**
   - 添加加速域名
   - 源站类型选择COS
   - 配置缓存规则

2. **更新代码使用CDN域名**

```typescript
// lib/cos-upload.ts
const getCdnUrl = (key: string): string => {
  if (process.env.CDN_DOMAIN) {
    return `${process.env.CDN_DOMAIN}/${key}`
  }
  return `https://${BUCKET}.cos.${REGION}.myqcloud.com/${key}`
}
```

## 三、成本估算

### 小型网站（月活1000用户）
- 存储：10GB × ¥0.099 = ¥0.99
- 流量：50GB × ¥0.50 = ¥25
- **月费用**：约¥26

### 中型网站（月活10000用户）
- 存储：100GB × ¥0.099 = ¥9.9
- 流量：500GB × ¥0.50 = ¥250
- **月费用**：约¥260

### 优化建议
1. 开启CDN缓存，减少回源流量
2. 设置合理的图片压缩参数
3. 使用WebP格式（可节省30%流量）
4. 实施图片懒加载

## 四、安全配置

### 1. 防盗链设置

在COS控制台配置防盗链：
```
允许的Referer：
- https://deepsea.com
- https://www.deepsea.com
- http://localhost:3000 (开发环境)
```

### 2. 上传限制

```typescript
// 在验证函数中添加更多限制
export function validateCourseImage(file: File) {
  // 文件大小限制
  if (file.size > 10 * 1024 * 1024) {
    throw new Error('图片大小不能超过10MB')
  }
  
  // 文件类型限制
  const allowedTypes = ['image/jpeg', 'image/png', 'image/webp']
  if (!allowedTypes.includes(file.type)) {
    throw new Error('只支持 JPG、PNG、WebP 格式')
  }
  
  // 文件名安全检查
  const safeFilename = file.name.replace(/[^a-zA-Z0-9.-]/g, '_')
  
  return { valid: true, safeFilename }
}
```

### 3. 访问权限控制

对于付费课程的图片，可以使用私有存储桶+临时签名URL：

```typescript
// 生成临时访问URL
const getTempUrl = async (key: string) => {
  // 检查用户权限
  const hasAccess = await checkUserAccess(userId, courseId)
  
  if (!hasAccess) {
    throw new Error('无权访问')
  }
  
  // 生成30分钟有效的签名URL
  return getSignedUrl(key, 1800)
}
```

## 五、故障排查

### 常见问题

1. **CORS错误**
   - 检查COS存储桶的CORS配置
   - 确保允许的域名包含您的网站

2. **上传超时**
   - 检查网络连接
   - 减小图片大小
   - 使用分片上传（大文件）

3. **403错误**
   - 检查密钥配置
   - 验证存储桶权限
   - 检查防盗链设置

4. **图片不显示**
   - 检查URL是否正确
   - 验证CDN是否生效
   - 清除浏览器缓存

## 六、迁移现有图片

如果您已有本地图片需要迁移到云端：

```typescript
// scripts/migrate-images.ts
import fs from 'fs'
import path from 'path'
import { uploadToCOS } from '../lib/cos-upload'

async function migrateImages() {
  const localDir = './public/uploads/images'
  const files = fs.readdirSync(localDir)
  
  for (const file of files) {
    const filePath = path.join(localDir, file)
    const buffer = fs.readFileSync(filePath)
    
    try {
      const result = await uploadToCOS(
        buffer,
        `migrated/${file}`,
        'image/jpeg'
      )
      console.log(`已迁移: ${file} -> ${result.url}`)
    } catch (error) {
      console.error(`迁移失败: ${file}`, error)
    }
  }
}

migrateImages()
```

## 总结

使用云存储的优势：
1. ✅ 用户可以从任何地方访问
2. ✅ 自动备份，数据安全
3. ✅ CDN加速，访问更快
4. ✅ 不占用服务器空间
5. ✅ 支持大规模扩展

实施建议：
1. 先在开发环境测试
2. 准备好图片迁移计划
3. 监控流量费用
4. 定期清理无用文件